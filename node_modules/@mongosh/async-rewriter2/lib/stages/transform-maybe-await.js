"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const babel = __importStar(require("@babel/core"));
exports.default = ({ types: t }) => {
    function asNodeKey(v) { return v; }
    const isGeneratedInnerFunction = asNodeKey(Symbol('isGeneratedInnerFunction'));
    const isGeneratedHelper = asNodeKey(Symbol('isGeneratedHelper'));
    const isOriginalBody = asNodeKey(Symbol('isOriginalBody'));
    const isAlwaysSyncFunction = asNodeKey(Symbol('isAlwaysSyncFunction'));
    const isExpandedTypeof = asNodeKey(Symbol('isExpandedTypeof'));
    const identifierGroupKey = '@@mongosh.identifierGroup';
    const syntheticPromiseSymbolTemplate = babel.template.statement(`
    const SP_IDENTIFIER = Symbol.for("@@mongosh.syntheticPromise");
  `);
    const markSyntheticPromiseTemplate = babel.template.statement(`
    function MSP_IDENTIFIER(p) {
      return Object.defineProperty(p, SP_IDENTIFIER, {
        value: true
      });
    }
  `);
    const isSyntheticPromiseTemplate = babel.template.statement(`
    function ISP_IDENTIFIER(p) {
      return p && p[SP_IDENTIFIER];
    }
  `);
    const assertNotSyntheticPromiseTemplate = babel.template.statement(`
    function ANSP_IDENTIFIER(p, s) {
      if (p && p[SP_IDENTIFIER]) {
        throw new CUSTOM_ERROR_BUILDER(
          'Result of expression "' + s + '" cannot be used in this context',
          'SyntheticPromiseInAlwaysSyncContext');
      }
      return p;
    }
  `);
    const asyncTryCatchWrapperTemplate = babel.template.expression(`
    async () => {
      try {
        ORIGINAL_CODE;
      } catch (err) {
        if (FUNCTION_STATE_IDENTIFIER === "sync") {
          SYNC_RETURN_VALUE_IDENTIFIER = err;
          FUNCTION_STATE_IDENTIFIER = "threw";
        } else throw err;
      } finally {
        if (FUNCTION_STATE_IDENTIFIER !== "threw") FUNCTION_STATE_IDENTIFIER = "returned";
      }
    }
  `);
    const expressionHolderVariableTemplate = babel.template.statement(`
    let EXPRESSION_HOLDER_IDENTIFIER;`);
    const wrapperFunctionTemplate = babel.template.statements(`
    let FUNCTION_STATE_IDENTIFIER = "sync",
        SYNC_RETURN_VALUE_IDENTIFIER;

    const ASYNC_RETURN_VALUE_IDENTIFIER = (ASYNC_TRY_CATCH_WRAPPER)();

    if (FUNCTION_STATE_IDENTIFIER === "returned")
      return SYNC_RETURN_VALUE_IDENTIFIER;
    else if (FUNCTION_STATE_IDENTIFIER === "threw")
      throw SYNC_RETURN_VALUE_IDENTIFIER;
    FUNCTION_STATE_IDENTIFIER = "async";
    return MSP_IDENTIFIER(ASYNC_RETURN_VALUE_IDENTIFIER);
  `);
    const awaitSyntheticPromiseTemplate = babel.template.expression(`(
    ORIGINAL_SOURCE,
    EXPRESSION_HOLDER = NODE,
    ISP_IDENTIFIER(EXPRESSION_HOLDER) ? await EXPRESSION_HOLDER : EXPRESSION_HOLDER
  )`, {
        allowAwaitOutsideFunction: true
    });
    const assertNotSyntheticExpressionTemplate = babel.template.expression(`
    ANSP_IDENTIFIER(NODE, ORIGINAL_SOURCE)
  `);
    const rethrowTemplate = babel.template.statement(`
    try {
      ORIGINAL_CODE;
    } catch (err) {
      throw err;
    }
  `);
    const demangleErrorTemplate = babel.template.statement(String.raw `
    function DE_IDENTIFIER(err) {
      if (Object.prototype.toString.call(err) === '[object Error]' &&
          err.message.includes('\ufeff')) {
        err.message = err.message.replace(/\(\s*"\ufeff(.+?)\ufeff"\s*,(?:[^\(]|\([^\)]*\))*\)/g, '$1');
      }
      return err;
    }
  `, { placeholderPattern: false, placeholderWhitelist: new Set(['DE_IDENTIFIER']) });
    const returnValueWrapperTemplate = babel.template.expression(`(
    SYNC_RETURN_VALUE_IDENTIFIER = NODE,
    FUNCTION_STATE_IDENTIFIER === 'async' ? SYNC_RETURN_VALUE_IDENTIFIER : null
  )`);
    return {
        pre(file) {
            this.file = file;
        },
        visitor: {
            BlockStatement(path) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
                if (!path.parentPath.isFunction())
                    return;
                if (path.parentPath.getData(identifierGroupKey))
                    return;
                if (path.parentPath.node[isGeneratedInnerFunction])
                    return;
                if (path.parentPath.node[isGeneratedHelper])
                    return;
                const originalSource = path.parent.start !== undefined ?
                    this.file.code.slice((_a = path.parent.start) !== null && _a !== void 0 ? _a : undefined, (_b = path.parent.end) !== null && _b !== void 0 ? _b : undefined) :
                    'function () { [unknown code] }';
                const encodedOriginalSource = encodeURIComponent(originalSource);
                const originalSourceNode = t.expressionStatement(t.stringLiteral(`<async_rewriter>${encodedOriginalSource}</>`));
                const existingIdentifiers = (_c = path.findParent(path => !!path.getData(identifierGroupKey))) === null || _c === void 0 ? void 0 : _c.getData(identifierGroupKey);
                const functionState = path.scope.generateUidIdentifier('fs');
                const synchronousReturnValue = path.scope.generateUidIdentifier('srv');
                const asynchronousReturnValue = path.scope.generateUidIdentifier('arv');
                const expressionHolder = (_d = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.expressionHolder) !== null && _d !== void 0 ? _d : path.scope.generateUidIdentifier('ex');
                const markSyntheticPromise = (_e = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.markSyntheticPromise) !== null && _e !== void 0 ? _e : path.scope.generateUidIdentifier('msp');
                const isSyntheticPromise = (_f = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.isSyntheticPromise) !== null && _f !== void 0 ? _f : path.scope.generateUidIdentifier('isp');
                const assertNotSyntheticPromise = (_g = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.assertNotSyntheticPromise) !== null && _g !== void 0 ? _g : path.scope.generateUidIdentifier('ansp');
                const syntheticPromiseSymbol = (_h = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.syntheticPromiseSymbol) !== null && _h !== void 0 ? _h : path.scope.generateUidIdentifier('sp');
                const demangleError = (_j = existingIdentifiers === null || existingIdentifiers === void 0 ? void 0 : existingIdentifiers.demangleError) !== null && _j !== void 0 ? _j : path.scope.generateUidIdentifier('de');
                const identifiersGroup = {
                    functionState,
                    synchronousReturnValue,
                    asynchronousReturnValue,
                    expressionHolder,
                    markSyntheticPromise,
                    isSyntheticPromise,
                    assertNotSyntheticPromise,
                    syntheticPromiseSymbol,
                    demangleError
                };
                path.parentPath.setData(identifierGroupKey, identifiersGroup);
                const commonHelpers = existingIdentifiers ? [] : [
                    Object.assign(syntheticPromiseSymbolTemplate({
                        SP_IDENTIFIER: syntheticPromiseSymbol
                    }), { [isGeneratedHelper]: true }),
                    Object.assign(expressionHolderVariableTemplate({
                        EXPRESSION_HOLDER_IDENTIFIER: expressionHolder
                    }), { [isGeneratedHelper]: true })
                ];
                const promiseHelpers = existingIdentifiers ? [] : [
                    ...commonHelpers,
                    Object.assign(markSyntheticPromiseTemplate({
                        MSP_IDENTIFIER: markSyntheticPromise,
                        SP_IDENTIFIER: syntheticPromiseSymbol
                    }), { [isGeneratedHelper]: true }),
                    Object.assign(isSyntheticPromiseTemplate({
                        ISP_IDENTIFIER: isSyntheticPromise,
                        SP_IDENTIFIER: syntheticPromiseSymbol
                    }), { [isGeneratedHelper]: true }),
                    Object.assign(demangleErrorTemplate({
                        DE_IDENTIFIER: demangleError
                    }), { [isGeneratedHelper]: true })
                ];
                const syncFnHelpers = [
                    ...commonHelpers,
                    Object.assign(assertNotSyntheticPromiseTemplate({
                        ANSP_IDENTIFIER: assertNotSyntheticPromise,
                        SP_IDENTIFIER: syntheticPromiseSymbol,
                        CUSTOM_ERROR_BUILDER: (_k = this.opts.customErrorBuilder) !== null && _k !== void 0 ? _k : t.identifier('Error')
                    }), { [isGeneratedHelper]: true })
                ];
                if (path.parentPath.node.async) {
                    path.replaceWith(t.blockStatement([
                        originalSourceNode,
                        ...promiseHelpers,
                        rethrowTemplate({
                            ORIGINAL_CODE: path.node.body
                        })
                    ]));
                    return;
                }
                if (path.parentPath.node.generator ||
                    (path.parentPath.isClassMethod() &&
                        path.parentPath.node.key.type === 'Identifier' &&
                        path.parentPath.node.key.name === 'constructor')) {
                    Object.assign(path.parentPath.node, { [isAlwaysSyncFunction]: true });
                    path.replaceWith(t.blockStatement([
                        originalSourceNode,
                        ...syncFnHelpers,
                        rethrowTemplate({
                            ORIGINAL_CODE: path.node.body
                        })
                    ]));
                    return;
                }
                const asyncTryCatchWrapper = Object.assign(asyncTryCatchWrapperTemplate({
                    FUNCTION_STATE_IDENTIFIER: functionState,
                    SYNC_RETURN_VALUE_IDENTIFIER: synchronousReturnValue,
                    ORIGINAL_CODE: Object.assign(path.node, { [isOriginalBody]: true })
                }), { [isGeneratedInnerFunction]: true });
                const wrapperFunction = wrapperFunctionTemplate({
                    FUNCTION_STATE_IDENTIFIER: functionState,
                    SYNC_RETURN_VALUE_IDENTIFIER: synchronousReturnValue,
                    ASYNC_RETURN_VALUE_IDENTIFIER: asynchronousReturnValue,
                    MSP_IDENTIFIER: markSyntheticPromise,
                    ASYNC_TRY_CATCH_WRAPPER: asyncTryCatchWrapper
                });
                path.replaceWith(t.blockStatement([
                    originalSourceNode,
                    ...promiseHelpers,
                    ...wrapperFunction
                ]));
            },
            UnaryExpression: {
                enter(path) {
                    if (path.node.operator === 'typeof' && path.node.argument.type === 'Identifier' && !path.node[isExpandedTypeof]) {
                        path.replaceWith(t.conditionalExpression(t.binaryExpression('===', { ...path.node, [isGeneratedHelper]: true, [isExpandedTypeof]: true }, t.stringLiteral('undefined')), t.stringLiteral('undefined'), { ...path.node, [isExpandedTypeof]: true }));
                    }
                }
            },
            Expression: {
                enter(path) {
                    var _a, _b;
                    if (path.parentPath.isArrowFunctionExpression() && path.key === 'body') {
                        path.replaceWith(t.blockStatement([
                            t.returnStatement(path.node)
                        ]));
                    }
                    if ((_b = (_a = path.find(path => path.isFunction() || !!path.node[isGeneratedHelper])) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b[isGeneratedHelper]) {
                        return path.skip();
                    }
                },
                exit(path) {
                    var _a, _b, _c, _d, _e, _f;
                    const functionParent = path.getFunctionParent();
                    if (!functionParent)
                        return;
                    if (!functionParent.node.async &&
                        !functionParent.node[isAlwaysSyncFunction])
                        return;
                    let identifierGroup;
                    if (functionParent.node[isGeneratedInnerFunction]) {
                        if (!((_b = (_a = path.findParent(path => path.isFunction() || !!path.node[isOriginalBody])) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b[isOriginalBody])) {
                            return;
                        }
                        identifierGroup = (_d = (_c = functionParent.getFunctionParent()) === null || _c === void 0 ? void 0 : _c.getData) === null || _d === void 0 ? void 0 : _d.call(_c, identifierGroupKey);
                        if (!identifierGroup) {
                            throw new Error('Parent of generated inner function does not have existing identifiers available');
                        }
                        if (path.parentPath.isReturnStatement() && !path.node[isGeneratedHelper]) {
                            path.replaceWith(Object.assign(returnValueWrapperTemplate({
                                SYNC_RETURN_VALUE_IDENTIFIER: identifierGroup.synchronousReturnValue,
                                FUNCTION_STATE_IDENTIFIER: identifierGroup.functionState,
                                NODE: path.node
                            }), { [isGeneratedHelper]: true }));
                            return;
                        }
                    }
                    else {
                        identifierGroup = functionParent.getData(identifierGroupKey);
                    }
                    if (path.parentPath.isCallExpression() &&
                        path.key === 'callee' &&
                        (path.isMemberExpression() ||
                            path.isImport() ||
                            (path.isIdentifier() && path.node.name === 'eval'))) {
                        return;
                    }
                    if (path.parentPath.isAssignmentExpression() && path.key === 'left')
                        return;
                    if (path.parentPath.isForXStatement() && path.key === 'left')
                        return;
                    if (path.parentPath.isUpdateExpression())
                        return;
                    if (path.parentPath.isUnaryExpression() && path.parentPath.node.operator === 'delete')
                        return;
                    if (path.isLiteral() ||
                        path.isArrayExpression() ||
                        path.isObjectExpression() ||
                        path.isFunctionExpression() ||
                        path.isArrowFunctionExpression() ||
                        path.isClassExpression() ||
                        path.isAssignmentExpression() ||
                        path.isBinaryExpression() ||
                        path.isConditionalExpression() ||
                        path.isLogicalExpression() ||
                        path.isSequenceExpression() ||
                        path.isParenthesizedExpression() ||
                        path.isUnaryExpression() ||
                        path.isSuper() ||
                        path.isThisExpression() ||
                        path.isAwaitExpression() ||
                        path.parentPath.isAwaitExpression()) {
                        return;
                    }
                    if (path.isIdentifier() && path.scope.hasBinding(path.node.name))
                        return;
                    const { expressionHolder, isSyntheticPromise, assertNotSyntheticPromise } = identifierGroup;
                    const prettyOriginalString = limitStringLength(path.node.start !== undefined ?
                        this.file.code.slice((_e = path.node.start) !== null && _e !== void 0 ? _e : undefined, (_f = path.node.end) !== null && _f !== void 0 ? _f : undefined) :
                        '<unknown>', 24);
                    if (!functionParent.node.async) {
                        path.replaceWith(Object.assign(assertNotSyntheticExpressionTemplate({
                            ORIGINAL_SOURCE: t.stringLiteral(prettyOriginalString),
                            NODE: path.node,
                            ANSP_IDENTIFIER: assertNotSyntheticPromise
                        }), { [isGeneratedHelper]: true }));
                        return;
                    }
                    const originalSource = t.stringLiteral('\ufeff' + prettyOriginalString + '\ufeff');
                    path.replaceWith(Object.assign(awaitSyntheticPromiseTemplate({
                        ORIGINAL_SOURCE: originalSource,
                        EXPRESSION_HOLDER: expressionHolder,
                        ISP_IDENTIFIER: isSyntheticPromise,
                        NODE: path.node
                    }), { [isGeneratedHelper]: true }));
                    path.skip();
                }
            },
            CatchClause: {
                exit(path) {
                    var _a;
                    if (path.node[isGeneratedHelper] || !path.node.param || path.node.param.type !== 'Identifier')
                        return;
                    const existingIdentifiers = (_a = path.findParent(path => !!path.getData(identifierGroupKey))) === null || _a === void 0 ? void 0 : _a.getData(identifierGroupKey);
                    if (!existingIdentifiers)
                        return;
                    path.replaceWith(Object.assign(t.catchClause(path.node.param, t.blockStatement([
                        t.expressionStatement(t.assignmentExpression('=', path.node.param, t.callExpression(existingIdentifiers.demangleError, [path.node.param]))),
                        path.node.body
                    ])), { [isGeneratedHelper]: true }));
                }
            }
        }
    };
};
function limitStringLength(input, maxLength) {
    if (input.length <= maxLength)
        return input;
    return input.slice(0, (maxLength - 5) * 0.7) +
        ' ... ' +
        input.slice(input.length - (maxLength - 5) * 0.3);
}
//# sourceMappingURL=transform-maybe-await.js.map