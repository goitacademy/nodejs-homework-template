'use strict';
const TypedArray = Object.getPrototypeOf(Uint8Array);
Array.prototype.forEach = function (callback, thisArg) {
    if (this == null) {
        throw new TypeError('Array.prototype.forEach called on null or undefined');
    }
    let T;
    let k;
    const O = Object(this);
    const len = O.length >>> 0;
    if (typeof callback !== 'function') {
        throw new TypeError(callback + ' is not a function');
    }
    if (arguments.length > 1) {
        T = thisArg;
    }
    k = 0;
    while (k < len) {
        let kValue;
        if (k in O) {
            kValue = O[k];
            callback.call(T, kValue, k, O);
        }
        k++;
    }
};
Array.prototype.map = function (callback) {
    let T;
    let k;
    if (this == null) {
        throw new TypeError('this is null or not defined');
    }
    const O = Object(this);
    const len = O.length >>> 0;
    if (typeof callback !== 'function') {
        throw new TypeError(callback + ' is not a function');
    }
    if (arguments.length > 1) {
        T = arguments[1];
    }
    const A = new O.constructor(len);
    k = 0;
    while (k < len) {
        let kValue;
        let mappedValue;
        if (k in O) {
            kValue = O[k];
            mappedValue = callback.call(T, kValue, k, O);
            A[k] = mappedValue;
        }
        k++;
    }
    return A;
};
Array.prototype.some = function (fun, thisArg) {
    if (this == null) {
        throw new TypeError('Array.prototype.some called on null or undefined');
    }
    if (typeof fun !== 'function') {
        throw new TypeError();
    }
    const t = Object(this);
    const len = t.length >>> 0;
    for (let i = 0; i < len; i++) {
        if (i in t && fun.call(thisArg, t[i], i, t)) {
            return true;
        }
    }
    return false;
};
Array.prototype.every = function (callbackfn, thisArg) {
    let T;
    let k;
    if (this == null) {
        throw new TypeError('this is null or not defined');
    }
    const O = Object(this);
    const len = O.length >>> 0;
    if (typeof callbackfn !== 'function' && Object.prototype.toString.call(callbackfn) !== '[object Function]') {
        throw new TypeError();
    }
    if (arguments.length > 1) {
        T = thisArg;
    }
    k = 0;
    while (k < len) {
        let kValue;
        if (k in O) {
            let testResult;
            kValue = O[k];
            if (T)
                testResult = callbackfn.call(T, kValue, k, O);
            else
                testResult = callbackfn(kValue, k, O);
            if (!testResult) {
                return false;
            }
        }
        k++;
    }
    return true;
};
Array.prototype.filter = function (func, thisArg) {
    if (!(typeof func === 'function' && this)) {
        throw new TypeError();
    }
    const len = this.length >>> 0;
    const res = new Array(len);
    const t = this;
    let c = 0;
    let i = -1;
    let kValue;
    if (thisArg === undefined) {
        while (++i !== len) {
            if (i in this) {
                kValue = t[i];
                if (func(t[i], i, t)) {
                    res[c++] = kValue;
                }
            }
        }
    }
    else {
        while (++i !== len) {
            if (i in this) {
                kValue = t[i];
                if (func.call(thisArg, t[i], i, t)) {
                    res[c++] = kValue;
                }
            }
        }
    }
    res.length = c;
    return res;
};
Object.defineProperty(Array.prototype, 'find', {
    value: function (predicate) {
        if (this == null) {
            throw TypeError('"this" is null or not defined');
        }
        const o = Object(this);
        const len = o.length >>> 0;
        if (typeof predicate !== 'function') {
            throw TypeError('predicate must be a function');
        }
        const thisArg = arguments[1];
        let k = 0;
        while (k < len) {
            const kValue = o[k];
            if (predicate.call(thisArg, kValue, k, o)) {
                return kValue;
            }
            k++;
        }
        return undefined;
    },
    configurable: true,
    writable: true
});
Object.defineProperty(Array.prototype, 'findIndex', {
    value: function (predicate) {
        if (this == null) {
            throw new TypeError('"this" is null or not defined');
        }
        const o = Object(this);
        const len = o.length >>> 0;
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }
        const thisArg = arguments[1];
        let k = 0;
        while (k < len) {
            const kValue = o[k];
            if (predicate.call(thisArg, kValue, k, o)) {
                return k;
            }
            k++;
        }
        return -1;
    },
    configurable: true,
    writable: true
});
Array.prototype.reduce = function (callback) {
    if (this === null) {
        throw new TypeError('Array.prototype.reduce ' +
            'called on null or undefined');
    }
    if (typeof callback !== 'function') {
        throw new TypeError(callback +
            ' is not a function');
    }
    const o = Object(this);
    const len = o.length >>> 0;
    let k = 0;
    let value;
    if (arguments.length >= 2) {
        value = arguments[1];
    }
    else {
        while (k < len && !(k in o)) {
            k++;
        }
        if (k >= len) {
            throw new TypeError('Reduce of empty array ' +
                'with no initial value');
        }
        value = o[k++];
    }
    while (k < len) {
        if (k in o) {
            value = callback(value, o[k], k, o);
        }
        k++;
    }
    return value;
};
Array.prototype.reduceRight = function (callback) {
    if (this === null || typeof this === 'undefined') {
        throw new TypeError('Array.prototype.reduce called on null or undefined');
    }
    if (typeof callback !== 'function') {
        throw new TypeError(callback + ' is not a function');
    }
    const t = Object(this);
    const len = t.length >>> 0;
    let k = len - 1;
    let value;
    if (arguments.length >= 2) {
        value = arguments[1];
    }
    else {
        while (k >= 0 && !(k in t)) {
            k--;
        }
        if (k < 0) {
            throw new TypeError('Reduce of empty array with no initial value');
        }
        value = t[k--];
    }
    for (; k >= 0; k--) {
        if (k in t) {
            value = callback(value, t[k], k, t);
        }
    }
    return value;
};
Map.prototype.forEach = function (callback, thisArg) {
    [...this].forEach(([key, value]) => {
        callback.call(thisArg, value, key, this);
    });
};
Set.prototype.forEach = function (callback, thisArg) {
    [...this].forEach(value => {
        callback.call(thisArg, value, value, this);
    });
};
const origArraySort = Array.prototype.sort;
Array.prototype.sort = function (compareFn) {
    return origArraySort.call(this, compareFn ? function (...args) {
        return [...(function* () {
                yield compareFn(...args);
            })()][0];
    } : undefined);
};
const origTypedArraySort = TypedArray.prototype.sort;
TypedArray.prototype.sort = function (compareFn) {
    return origTypedArraySort.call(this, compareFn ? function (...args) {
        return [...(function* () {
                yield compareFn(...args);
            })()][0];
    } : undefined);
};
Array.prototype.flatMap = function (...args) {
    return Array.prototype.map.call(this, ...args).flat();
};
TypedArray.prototype.reduce = Array.prototype.reduce;
TypedArray.prototype.reduceRight = Array.prototype.reduceRight;
TypedArray.prototype.findIndex = Array.prototype.findIndex;
TypedArray.prototype.find = Array.prototype.find;
TypedArray.prototype.forEach = Array.prototype.forEach;
TypedArray.prototype.map = Array.prototype.map;
TypedArray.prototype.some = Array.prototype.some;
TypedArray.prototype.every = Array.prototype.every;
TypedArray.prototype.filter = function (func, thisArg) {
    const array = Array.prototype.filter.call(this, func, thisArg);
    return new (this.constructor)(array);
};
const origFptS = Function.prototype.toString;
Function.prototype.toString = function () {
    const source = origFptS.call(this, arguments);
    const match = source.match(/^[^"]*"<async_rewriter>(?<encoded>[^<]*)<\/>";/);
    if (match) {
        return decodeURIComponent(match.groups.encoded);
    }
    return source;
};
//# sourceMappingURL=runtime-support.nocov.js.map