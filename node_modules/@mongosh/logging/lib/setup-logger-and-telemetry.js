"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupLoggerAndTelemetry = void 0;
const mongodb_redact_1 = __importDefault(require("mongodb-redact"));
const history_1 = require("@mongosh/history");
const util_1 = require("util");
const mongodb_log_writer_1 = require("mongodb-log-writer");
const devtools_connect_1 = require("@mongodb-js/devtools-connect");
class MultiSet {
    constructor() {
        this._entries = new Map();
    }
    add(entry) {
        var _a;
        const key = JSON.stringify(Object.entries(entry).sort());
        this._entries.set(key, ((_a = this._entries.get(key)) !== null && _a !== void 0 ? _a : 0) + 1);
    }
    clear() {
        this._entries.clear();
    }
    *[Symbol.iterator]() {
        for (const [key, count] of this._entries) {
            yield [Object.fromEntries(JSON.parse(key)), count];
        }
    }
}
function setupLoggerAndTelemetry(bus, log, analytics, userTraits, mongosh_version) {
    const { logId } = log;
    let userId;
    let telemetryAnonymousId;
    const getTelemetryUserIdentity = () => {
        if (telemetryAnonymousId) {
            return {
                anonymousId: telemetryAnonymousId
            };
        }
        return { userId };
    };
    let hasStartedMongoshRepl = false;
    bus.on('mongosh:start-mongosh-repl', (ev) => {
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000002), 'repl', 'Started REPL', ev);
        hasStartedMongoshRepl = true;
    });
    let usesShellOption = false;
    bus.on('mongosh:start-loading-cli-scripts', (event) => {
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000003), 'repl', 'Start loading CLI scripts');
        usesShellOption = event.usesShellOption;
    });
    bus.on('mongosh:connect', function (args) {
        const connectionUri = (0, history_1.redactURICredentials)(args.uri);
        const { uri: _uri, ...argsWithoutUri } = args;
        const params = {
            session_id: logId,
            userId,
            telemetryAnonymousId,
            connectionUri,
            ...argsWithoutUri
        };
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000004), 'connect', 'Connecting to server', params);
        analytics.track({
            ...getTelemetryUserIdentity(),
            event: 'New Connection',
            properties: {
                mongosh_version,
                session_id: logId,
                ...argsWithoutUri
            }
        });
    });
    bus.on('mongosh:new-user', function (newTelemetryUserIdentity) {
        if (!newTelemetryUserIdentity.anonymousId) {
            userId = newTelemetryUserIdentity.userId;
        }
        telemetryAnonymousId = newTelemetryUserIdentity.anonymousId;
        analytics.identify({
            anonymousId: newTelemetryUserIdentity.anonymousId,
            traits: userTraits
        });
    });
    bus.on('mongosh:update-user', function (updatedTelemetryUserIdentity) {
        if (updatedTelemetryUserIdentity.anonymousId) {
            telemetryAnonymousId = updatedTelemetryUserIdentity.anonymousId;
            analytics.identify({
                anonymousId: updatedTelemetryUserIdentity.anonymousId,
                traits: userTraits
            });
        }
        else {
            userId = updatedTelemetryUserIdentity.userId;
            analytics.identify({
                userId: updatedTelemetryUserIdentity.userId,
                traits: userTraits
            });
        }
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000005), 'config', 'User updated');
    });
    bus.on('mongosh:error', function (error, context) {
        if (context === 'fatal') {
            log.fatal('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000006), context, `${error.name}: ${error.message}`, error);
        }
        else {
            log.error('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000006), context, `${error.name}: ${error.message}`, error);
        }
        if (error.name.includes('Mongosh')) {
            analytics.track({
                ...getTelemetryUserIdentity(),
                event: 'Error',
                properties: {
                    mongosh_version,
                    name: error.name,
                    code: error.code,
                    scope: error.scope,
                    metadata: error.metadata
                }
            });
        }
    });
    bus.on('mongosh:globalconfig-load', function (args) {
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000048), 'config', 'Loading global configuration file', args);
    });
    bus.on('mongosh:evaluate-input', function (args) {
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000007), 'repl', 'Evaluating input', args);
    });
    bus.on('mongosh:use', function (args) {
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000008), 'shell-api', 'Used "use" command', args);
        analytics.track({
            ...getTelemetryUserIdentity(),
            event: 'Use',
            properties: {
                mongosh_version
            }
        });
    });
    bus.on('mongosh:show', function (args) {
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000009), 'shell-api', 'Used "show" command', args);
        analytics.track({
            ...getTelemetryUserIdentity(),
            event: 'Show',
            properties: {
                mongosh_version,
                method: args.method
            }
        });
    });
    bus.on('mongosh:setCtx', function (args) {
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000010), 'shell-api', 'Initialized context', args);
    });
    bus.on('mongosh:api-call-with-arguments', function (args) {
        let arg;
        try {
            arg = JSON.parse(JSON.stringify(args));
        }
        catch (_a) {
            arg = { _inspected: (0, util_1.inspect)(args) };
        }
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000011), 'shell-api', 'Performed API call', (0, mongodb_redact_1.default)(arg));
    });
    bus.on('mongosh:api-load-file', function (args) {
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000012), 'shell-api', 'Loading file via load()', args);
        analytics.track({
            ...getTelemetryUserIdentity(),
            event: hasStartedMongoshRepl ? 'Script Loaded' : 'Script Loaded CLI',
            properties: {
                mongosh_version,
                nested: args.nested,
                ...(hasStartedMongoshRepl ? {} : { shell: usesShellOption })
            }
        });
    });
    bus.on('mongosh:eval-cli-script', function () {
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000013), 'repl', 'Evaluating script passed on the command line');
        analytics.track({
            ...getTelemetryUserIdentity(),
            event: 'Script Evaluated',
            properties: {
                mongosh_version,
                shell: usesShellOption
            }
        });
    });
    bus.on('mongosh:mongoshrc-load', function () {
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000014), 'repl', 'Loading .mongoshrc.js');
        analytics.track({
            ...getTelemetryUserIdentity(),
            event: 'Mongoshrc Loaded',
            properties: {
                mongosh_version
            }
        });
    });
    bus.on('mongosh:mongoshrc-mongorc-warn', function () {
        log.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000015), 'repl', 'Warning about .mongorc.js/.mongoshrc.js mismatch');
        analytics.track({
            ...getTelemetryUserIdentity(),
            event: 'Mongorc Warning',
            properties: {
                mongosh_version
            }
        });
    });
    bus.on('mongosh:crypt-library-load-skip', function (ev) {
        log.info('AUTO-ENCRYPTION', (0, mongodb_log_writer_1.mongoLogId)(1000000050), 'crypt-library', 'Skipping shared library candidate', ev);
    });
    bus.on('mongosh:crypt-library-load-found', function (ev) {
        log.warn('AUTO-ENCRYPTION', (0, mongodb_log_writer_1.mongoLogId)(1000000051), 'crypt-library', 'Accepted shared library candidate', {
            cryptSharedLibPath: ev.cryptSharedLibPath,
            expectedVersion: ev.expectedVersion.versionStr
        });
    });
    bus.on('mongosh-snippets:loaded', function (ev) {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000019), 'snippets', 'Loaded snippets', ev);
    });
    bus.on('mongosh-snippets:npm-lookup', function (ev) {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000020), 'snippets', 'Performing npm lookup', ev);
    });
    bus.on('mongosh-snippets:npm-lookup-stopped', function () {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000021), 'snippets', 'npm lookup stopped');
    });
    bus.on('mongosh-snippets:npm-download-failed', function (ev) {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000022), 'snippets', 'npm download failed', ev);
    });
    bus.on('mongosh-snippets:npm-download-active', function (ev) {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000023), 'snippets', 'npm download active', ev);
    });
    bus.on('mongosh-snippets:fetch-index', function (ev) {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000024), 'snippets', 'Fetching snippet index', ev);
    });
    bus.on('mongosh-snippets:fetch-cache-invalid', function () {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000025), 'snippets', 'Snippet cache invalid');
    });
    bus.on('mongosh-snippets:fetch-index-error', function (ev) {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000026), 'snippets', 'Fetching snippet index failed', ev);
    });
    bus.on('mongosh-snippets:fetch-index-done', function () {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000027), 'snippets', 'Fetching snippet index done');
    });
    bus.on('mongosh-snippets:package-json-edit-error', function (ev) {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000028), 'snippets', 'Modifying snippets package.json failed', ev);
    });
    bus.on('mongosh-snippets:spawn-child', function (ev) {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000029), 'snippets', 'Spawning helper', ev);
    });
    bus.on('mongosh-snippets:load-snippet', function (ev) {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000030), 'snippets', 'Loading snippet', ev);
    });
    bus.on('mongosh-snippets:snippet-command', function (ev) {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000031), 'snippets', 'Running snippet command', ev);
        if (ev.args[0] === 'install') {
            analytics.track({
                ...getTelemetryUserIdentity(),
                event: 'Snippet Install',
                properties: {
                    mongosh_version
                }
            });
        }
    });
    bus.on('mongosh-snippets:transform-error', function (ev) {
        log.info('MONGOSH-SNIPPETS', (0, mongodb_log_writer_1.mongoLogId)(1000000032), 'snippets', 'Rewrote error message', ev);
    });
    const deprecatedApiCalls = new MultiSet();
    const apiCalls = new MultiSet();
    bus.on('mongosh:api-call', function (ev) {
        if (ev.deprecated) {
            deprecatedApiCalls.add({ class: ev.class, method: ev.method });
        }
        if (ev.callDepth === 0 && ev.isAsync) {
            apiCalls.add({ class: ev.class, method: ev.method });
        }
    });
    bus.on('mongosh:evaluate-started', function () {
        deprecatedApiCalls.clear();
        apiCalls.clear();
    });
    bus.on('mongosh:evaluate-finished', function () {
        for (const [entry] of deprecatedApiCalls) {
            log.warn('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000033), 'shell-api', 'Deprecated API call', entry);
            analytics.track({
                ...getTelemetryUserIdentity(),
                event: 'Deprecated Method',
                properties: {
                    mongosh_version,
                    ...entry
                }
            });
        }
        for (const [entry, count] of apiCalls) {
            analytics.track({
                ...getTelemetryUserIdentity(),
                event: 'API Call',
                properties: {
                    mongosh_version,
                    ...entry,
                    count
                }
            });
        }
        deprecatedApiCalls.clear();
        apiCalls.clear();
    });
    (0, devtools_connect_1.hookLogger)(bus, log, 'mongosh', history_1.redactURICredentials);
    bus.on('mongosh-sp:reset-connection-options', function () {
        log.info('MONGOSH-SP', (0, mongodb_log_writer_1.mongoLogId)(1000000040), 'connect', 'Reconnect because of changed connection options');
    });
    bus.on('mongosh-editor:run-edit-command', function (ev) {
        log.error('MONGOSH-EDITOR', (0, mongodb_log_writer_1.mongoLogId)(1000000047), 'editor', 'Open external editor', (0, mongodb_redact_1.default)(ev));
    });
    bus.on('mongosh-editor:read-vscode-extensions-done', function (ev) {
        log.error('MONGOSH-EDITOR', (0, mongodb_log_writer_1.mongoLogId)(1000000043), 'editor', 'Reading vscode extensions from file system succeeded', ev);
    });
    bus.on('mongosh-editor:read-vscode-extensions-failed', function (ev) {
        log.error('MONGOSH-EDITOR', (0, mongodb_log_writer_1.mongoLogId)(1000000044), 'editor', 'Reading vscode extensions from file system failed', {
            ...ev,
            error: ev.error.message
        });
    });
}
exports.setupLoggerAndTelemetry = setupLoggerAndTelemetry;
//# sourceMappingURL=setup-logger-and-telemetry.js.map