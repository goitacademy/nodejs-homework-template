"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCryptLibraryPaths = exports.SHARED_LIBRARY_SUFFIX = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
exports.SHARED_LIBRARY_SUFFIX = process.platform === 'win32' ? 'dll' :
    process.platform === 'darwin' ? 'dylib' : 'so';
async function getCryptLibraryPaths(bus = undefined, pretendProcessExecPathForTesting = undefined) {
    var _a, _b, _c, _d;
    const execPath = pretendProcessExecPathForTesting !== null && pretendProcessExecPathForTesting !== void 0 ? pretendProcessExecPathForTesting : process.execPath;
    let getCryptSharedLibraryVersion;
    try {
        getCryptSharedLibraryVersion = require('mongodb-crypt-library-version');
    }
    catch (err) {
        getCryptSharedLibraryVersion = () => ({ version: BigInt(0), versionStr: '<unknown>' });
    }
    if (execPath === process.argv[1] || pretendProcessExecPathForTesting) {
        const bindir = path_1.default.dirname(execPath);
        const execPathStat = await fs_1.promises.stat(execPath);
        for await (const libraryCandidate of [
            path_1.default.resolve(bindir, '..', 'lib64', `mongosh_crypt_v1.${exports.SHARED_LIBRARY_SUFFIX}`),
            path_1.default.resolve(bindir, '..', 'lib', `mongosh_crypt_v1.${exports.SHARED_LIBRARY_SUFFIX}`),
            path_1.default.resolve(bindir, `mongosh_crypt_v1.${exports.SHARED_LIBRARY_SUFFIX}`)
        ]) {
            try {
                const permissionsMismatch = await ensureMatchingPermissions(libraryCandidate, execPathStat);
                if (permissionsMismatch) {
                    (_a = bus === null || bus === void 0 ? void 0 : bus.emit) === null || _a === void 0 ? void 0 : _a.call(bus, 'mongosh:crypt-library-load-skip', {
                        cryptSharedLibPath: libraryCandidate,
                        reason: 'permissions mismatch',
                        details: permissionsMismatch
                    });
                    continue;
                }
                const version = getCryptSharedLibraryVersion(libraryCandidate);
                const result = {
                    cryptSharedLibPath: libraryCandidate,
                    expectedVersion: version
                };
                (_b = bus === null || bus === void 0 ? void 0 : bus.emit) === null || _b === void 0 ? void 0 : _b.call(bus, 'mongosh:crypt-library-load-found', result);
                return result;
            }
            catch (err) {
                (_c = bus === null || bus === void 0 ? void 0 : bus.emit) === null || _c === void 0 ? void 0 : _c.call(bus, 'mongosh:crypt-library-load-skip', {
                    cryptSharedLibPath: libraryCandidate,
                    reason: err.message
                });
            }
        }
    }
    else {
        (_d = bus === null || bus === void 0 ? void 0 : bus.emit) === null || _d === void 0 ? void 0 : _d.call(bus, 'mongosh:crypt-library-load-skip', {
            cryptSharedLibPath: '',
            reason: 'Skipping CSFLE library searching because this is not a single-executable mongosh'
        });
    }
    return {};
}
exports.getCryptLibraryPaths = getCryptLibraryPaths;
async function ensureMatchingPermissions(filename, execPathStat) {
    if (process.platform === 'win32') {
        return null;
    }
    await fs_1.promises.access(filename, fs_1.constants.R_OK);
    const stat = await fs_1.promises.stat(filename);
    if (((stat.uid !== execPathStat.uid && stat.uid !== process.getuid()) ||
        (stat.gid !== execPathStat.gid && stat.gid !== process.getgid()) ||
        stat.mode & 0o002)) {
        return {
            libraryStat: { uid: stat.uid, gid: stat.gid, mode: stat.mode },
            mongoshStat: { uid: execPathStat.uid, gid: stat.gid },
            currentUser: { uid: process.getuid(), gid: process.getgid() }
        };
    }
    return null;
}
//# sourceMappingURL=crypt-library-paths.js.map