"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = exports.evalFinish = exports.evalStart = void 0;
const domain_1 = require("domain");
const is_recoverable_error_1 = __importDefault(require("is-recoverable-error"));
const readline_1 = require("readline");
const repl_1 = require("repl");
const util_1 = require("util");
exports.evalStart = Symbol('async-repl:evalStart');
exports.evalFinish = Symbol('async-repl:evalFinish');
function disableEvent(emitter, event) {
    const rawListeners = emitter.rawListeners(event);
    emitter.removeAllListeners(event);
    return {
        restore() {
            for (const listener of rawListeners) {
                emitter.on(event, listener);
            }
        }
    };
}
function getPrompt(repl) {
    var _a, _b;
    return (_b = (_a = repl.getPrompt) === null || _a === void 0 ? void 0 : _a.call(repl)) !== null && _b !== void 0 ? _b : repl._prompt;
}
function start(opts) {
    var _a;
    const { asyncEval, wrapCallbackError = err => err, onAsyncSigint } = opts;
    if (onAsyncSigint) {
        opts.breakEvalOnSigint = true;
    }
    const repl = ((_a = opts.start) !== null && _a !== void 0 ? _a : repl_1.start)(opts);
    const originalEval = (0, util_1.promisify)(wrapPauseInput(repl.input, wrapNoSyncDomainError(repl.eval.bind(repl))));
    const setRawMode = (mode) => {
        const input = repl.input;
        const wasInRawMode = input.isRaw;
        if (typeof input.setRawMode === 'function') {
            input.setRawMode(mode);
        }
        return wasInRawMode;
    };
    repl.eval = async (input, context, filename, callback) => {
        var _a, _b;
        let previouslyInRawMode;
        if (onAsyncSigint) {
            previouslyInRawMode = setRawMode(false);
        }
        let result;
        repl.emit(exports.evalStart, { input });
        const origPrompt = getPrompt(repl);
        readline_1.Interface.prototype.setPrompt.call(repl, '');
        try {
            let exitEventPending = false;
            const exitListener = () => { exitEventPending = true; };
            let previousExitListeners = [];
            let sigintListener = undefined;
            let replSigint = undefined;
            let processSigint = undefined;
            try {
                result = await new Promise((resolve, reject) => {
                    if (onAsyncSigint) {
                        sigintListener = async () => {
                            let interruptHandled = false;
                            try {
                                interruptHandled = await onAsyncSigint();
                            }
                            catch (e) {
                            }
                            finally {
                                reject(interruptHandled ? undefined : new Error('Asynchronous execution was interrupted by `SIGINT`'));
                            }
                        };
                        replSigint = disableEvent(repl, 'SIGINT');
                        processSigint = disableEvent(process, 'SIGINT');
                        repl.once('SIGINT', sigintListener);
                    }
                    previousExitListeners = repl.rawListeners('exit');
                    repl.removeAllListeners('exit');
                    repl.once('exit', exitListener);
                    const evalResult = asyncEval(originalEval, input, context, filename);
                    if (sigintListener !== undefined) {
                        process.once('SIGINT', sigintListener);
                    }
                    evalResult.then(resolve, reject);
                });
            }
            finally {
                if (typeof previouslyInRawMode !== 'undefined') {
                    setRawMode(previouslyInRawMode);
                }
                if (sigintListener !== undefined) {
                    repl.removeListener('SIGINT', sigintListener);
                    process.removeListener('SIGINT', sigintListener);
                }
                (_a = replSigint === null || replSigint === void 0 ? void 0 : replSigint.restore) === null || _a === void 0 ? void 0 : _a.call(replSigint);
                (_b = processSigint === null || processSigint === void 0 ? void 0 : processSigint.restore) === null || _b === void 0 ? void 0 : _b.call(processSigint);
                if (getPrompt(repl) === '') {
                    readline_1.Interface.prototype.setPrompt.call(repl, origPrompt);
                }
                repl.removeListener('exit', exitListener);
                for (const listener of previousExitListeners) {
                    repl.on('exit', listener);
                }
                if (exitEventPending) {
                    process.nextTick(() => repl.emit('exit'));
                }
            }
        }
        catch (err) {
            try {
                if ((0, is_recoverable_error_1.default)(input)) {
                    repl.emit(exports.evalFinish, { input, success: false, err, recoverable: true });
                    return callback(new repl_1.Recoverable(err));
                }
                repl.emit(exports.evalFinish, { input, success: false, err, recoverable: false });
                return callback(err);
            }
            catch (callbackErr) {
                return callback(wrapCallbackError(callbackErr));
            }
        }
        try {
            repl.emit(exports.evalFinish, { input, success: true });
            return callback(null, result);
        }
        catch (callbackErr) {
            return callback(wrapCallbackError(callbackErr));
        }
    };
    return repl;
}
exports.start = start;
function wrapNoSyncDomainError(fn) {
    return (...args) => {
        const origEmit = domain_1.Domain.prototype.emit;
        domain_1.Domain.prototype.emit = function (ev, ...eventArgs) {
            if (ev === 'error') {
                this.exit();
                throw eventArgs[0];
            }
            return origEmit.call(this, ev, ...eventArgs);
        };
        try {
            return fn(...args);
        }
        finally {
            domain_1.Domain.prototype.emit = origEmit;
        }
    };
}
function wrapPauseInput(input, fn) {
    return (...args) => {
        const wasReadingAndNeedToWorkaroundWindowsBug = process.platform === 'win32' &&
            input.isTTY &&
            input._handle &&
            input._handle.reading &&
            typeof input._handle.readStop === 'function' &&
            typeof input._handle.readStart === 'function';
        if (wasReadingAndNeedToWorkaroundWindowsBug) {
            input._handle.reading = false;
            input._handle.readStop();
        }
        try {
            return fn(...args);
        }
        finally {
            if (wasReadingAndNeedToWorkaroundWindowsBug && !input._handle.reading) {
                input._handle.reading = true;
                input._handle.readStart();
            }
        }
    };
}
//# sourceMappingURL=async-repl.js.map