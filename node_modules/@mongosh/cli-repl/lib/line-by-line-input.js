"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineByLineInput = void 0;
const stream_1 = require("stream");
const string_decoder_1 = require("string_decoder");
const LINE_ENDING_RE = /\r?\n|\r(?!\n)/;
const CTRL_C = '\u0003';
const CTRL_D = '\u0004';
class LineByLineInput extends stream_1.Readable {
    constructor(readable) {
        super();
        this._onData = (chunk) => {
            if (this._blockOnNewLineEnabled) {
                return this._forwardAndBlockOnNewline(chunk);
            }
            return this._forwardWithoutBlocking(chunk);
        };
        this._originalInput = readable;
        this._forwarding = true;
        this._blockOnNewLineEnabled = true;
        this._charQueue = [];
        this._decoder = new string_decoder_1.StringDecoder('utf-8');
        this._insidePushCalls = 0;
        const isReadableEvent = (name) => name === 'readable' || name === 'data' || name === 'end' || name === 'keypress';
        this.on('removeListener', (name, handler) => {
            if (!isReadableEvent(name)) {
                this._originalInput.removeListener(name, handler);
            }
        });
        this.on('newListener', (name, handler) => {
            if (!isReadableEvent(name)) {
                this._originalInput.addListener(name, handler);
            }
        });
        const proxy = new Proxy(readable, {
            get: (target, property) => {
                if (typeof property === 'string' &&
                    !property.startsWith('_') &&
                    typeof this[property] === 'function') {
                    return this[property].bind(this);
                }
                return target[property];
            }
        });
        return proxy;
    }
    start() {
        this._originalInput.on('data', (chunk) => this._onData(chunk));
        this._originalInput.on('end', () => this._onData(null));
    }
    _read() {
    }
    nextLine() {
        this._resumeForwarding();
        this._flush();
    }
    enableBlockOnNewLine() {
        this._blockOnNewLineEnabled = true;
    }
    disableBlockOnNewline() {
        this._blockOnNewLineEnabled = false;
        this._flush();
    }
    _forwardAndBlockOnNewline(chunk) {
        const chars = chunk === null ? [null] : this._decoder.write(chunk);
        for (const char of chars) {
            const lastCharQueueEntry = this._charQueue.length ?
                this._charQueue[this._charQueue.length - 1] : '';
            const lastCharQueueChar = (lastCharQueueEntry === null || lastCharQueueEntry === void 0 ? void 0 : lastCharQueueEntry.length) ?
                lastCharQueueEntry[lastCharQueueEntry.length - 1] : '';
            if (this._isCtrlC(char) || this._isCtrlD(char)) {
                this.push(char);
            }
            else if ((char === '\n' && lastCharQueueChar === '\r') || (this._isRegularCharacter(char) &&
                lastCharQueueChar !== '' &&
                this._isRegularCharacter(lastCharQueueChar))) {
                this._charQueue[this._charQueue.length - 1] += char;
            }
            else {
                this._charQueue.push(char);
            }
        }
        this._flush();
    }
    _forwardWithoutBlocking(chunk) {
        if (chunk !== null) {
            this._decoder.write(chunk);
        }
        this.push(chunk);
    }
    _pauseForwarding() {
        this._forwarding = false;
    }
    _resumeForwarding() {
        this._forwarding = true;
    }
    _shouldForward() {
        return !this._blockOnNewLineEnabled || this._forwarding;
    }
    _flush() {
        while (this._charQueue.length &&
            this._shouldForward() &&
            !this._originalInput.isPaused() &&
            this._insidePushCalls === 0) {
            const char = this._charQueue.shift();
            if (this._isLineEnding(char)) {
                this._pauseForwarding();
            }
            this.push(char);
        }
    }
    _isRegularCharacter(char) {
        return char !== null && !this._isLineEnding(char) && !this._isCtrlC(char) && !this._isCtrlD(char);
    }
    _isLineEnding(char) {
        return char !== null && LINE_ENDING_RE.test(char);
    }
    _isCtrlD(char) {
        return char === CTRL_D;
    }
    _isCtrlC(char) {
        return char === CTRL_C;
    }
    push(chunk) {
        this._insidePushCalls++;
        try {
            return super.push(chunk);
        }
        finally {
            this._insidePushCalls--;
        }
    }
}
exports.LineByLineInput = LineByLineInput;
//# sourceMappingURL=line-by-line-input.js.map