"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliRepl = void 0;
const errors_1 = require("@mongosh/errors");
const history_1 = require("@mongosh/history");
const i18n_1 = __importDefault(require("@mongosh/i18n"));
const service_provider_core_1 = require("@mongosh/service-provider-core");
const service_provider_server_1 = require("@mongosh/service-provider-server");
const snippet_manager_1 = require("@mongosh/snippet-manager");
const editor_1 = require("@mongosh/editor");
const history_2 = require("@mongosh/history");
const analytics_node_1 = __importDefault(require("analytics-node"));
const askpassword_1 = __importDefault(require("askpassword"));
const events_1 = require("events");
const js_yaml_1 = __importDefault(require("js-yaml"));
const mongodb_connection_string_url_1 = __importDefault(require("mongodb-connection-string-url"));
const semver_1 = __importDefault(require("semver"));
const build_info_1 = require("./build-info");
const config_directory_1 = require("./config-directory");
const error_codes_1 = require("./error-codes");
const format_json_1 = require("./format-json");
const mongodb_log_writer_1 = require("mongodb-log-writer");
const mongosh_repl_1 = __importDefault(require("./mongosh-repl"));
const logging_1 = require("@mongosh/logging");
const types_1 = require("@mongosh/types");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const get_os_info_1 = require("./get-os-info");
const CONNECTING = 'cli-repl.cli-repl.connecting';
class CliRepl {
    constructor(options) {
        var _a, _b;
        this.globalConfig = null;
        this.toggleableAnalytics = new logging_1.ToggleableAnalytics();
        this.warnedAboutInaccessibleFiles = false;
        this.closing = false;
        this.isContainerizedEnvironment = false;
        this.hasOnDiskTelemetryId = false;
        this.bus = new events_1.EventEmitter();
        this.cliOptions = options.shellCliOptions;
        this.input = options.input;
        this.output = options.output;
        this.analyticsOptions = options.analyticsOptions;
        this.onExit = options.onExit;
        const id = new service_provider_core_1.bson.ObjectId().toHexString();
        this.config = {
            userId: id,
            telemetryAnonymousId: id,
            enableTelemetry: true
        };
        this.getCryptLibraryPaths = options.getCryptLibraryPaths;
        this.globalConfigPaths = (_a = options.globalConfigPaths) !== null && _a !== void 0 ? _a : [];
        this.shellHomeDirectory = new config_directory_1.ShellHomeDirectory(options.shellHomePaths);
        this.configDirectory = new config_directory_1.ConfigManager(this.shellHomeDirectory)
            .on('error', (err) => {
            this.bus.emit('mongosh:error', err, 'config');
        })
            .on('new-config', (config) => {
            this.hasOnDiskTelemetryId = !!(config.userId || config.telemetryAnonymousId);
            this.setTelemetryEnabled(config.enableTelemetry);
            this.bus.emit('mongosh:new-user', { userId: config.userId, anonymousId: config.telemetryAnonymousId });
        })
            .on('update-config', (config) => {
            this.hasOnDiskTelemetryId = !!(config.userId || config.telemetryAnonymousId);
            this.setTelemetryEnabled(config.enableTelemetry);
            this.bus.emit('mongosh:update-user', { userId: config.userId, anonymousId: config.telemetryAnonymousId });
        });
        this.logManager = new mongodb_log_writer_1.MongoLogManager({
            directory: this.shellHomeDirectory.localPath('.'),
            retentionDays: 30,
            onerror: (err) => this.bus.emit('mongosh:error', err, 'log'),
            onwarn: (err, path) => this.warnAboutInaccessibleFile(err, path)
        });
        this.output.on('error', (err) => {
            this.bus.emit('mongosh:error', err, 'io');
        });
        this.mongoshRepl = new mongosh_repl_1.default({
            ...options,
            nodeReplOptions: (_b = options.nodeReplOptions) !== null && _b !== void 0 ? _b : {
                terminal: process.env.MONGOSH_FORCE_TERMINAL ? true : undefined,
            },
            bus: this.bus,
            ioProvider: this
        });
    }
    async getIsContainerizedEnvironment() {
        try {
            await fs_1.promises.stat('/.dockerenv');
            return true;
        }
        catch (_a) {
            try {
                const cgroup = await fs_1.promises.readFile('/proc/self/cgroup', 'utf8');
                return /\b(docker|lxc|kubepods)\b/.test(cgroup);
            }
            catch (_b) {
                return false;
            }
        }
    }
    get forceDisableTelemetry() {
        var _a;
        return (((_a = this.globalConfig) === null || _a === void 0 ? void 0 : _a.forceDisableTelemetry) ||
            (this.isContainerizedEnvironment && !this.mongoshRepl.isInteractive));
    }
    async start(driverUri, driverOptions) {
        var _a, _b, _c, _d, _e, _f;
        const { version } = require('../package.json');
        await this.verifyNodeVersion();
        this.isContainerizedEnvironment =
            await this.getIsContainerizedEnvironment();
        if (!this.cliOptions.nodb) {
            const cs = new mongodb_connection_string_url_1.default(driverUri);
            const searchParams = cs.typedSearchParams();
            if (!searchParams.get('appName')) {
                searchParams.set('appName', `mongosh ${version}`);
            }
            if (this.isPasswordMissingURI(cs)) {
                cs.password = encodeURIComponent(await this.requirePassword());
            }
            this.ensurePasswordFieldIsPresentInAuth(driverOptions);
            driverUri = cs.toString();
        }
        try {
            await this.shellHomeDirectory.ensureExists();
        }
        catch (err) {
            this.warnAboutInaccessibleFile(err);
        }
        await this.logManager.cleanupOldLogfiles();
        const logger = await this.logManager.createLogWriter();
        if (!this.cliOptions.quiet) {
            this.output.write(`Current Mongosh Log ID:\t${logger.logId}\n`);
        }
        this.logWriter = logger;
        logger.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000000), 'log', 'Starting log', {
            execPath: process.execPath,
            envInfo: (0, history_2.redactSensitiveData)(this.getLoggedEnvironmentVariables()),
            ...await (0, build_info_1.buildInfo)({ withCryptSharedVersionInfo: true })
        });
        let analyticsSetupError = null;
        try {
            await this.setupAnalytics();
        }
        catch (err) {
            analyticsSetupError = err;
        }
        (0, logging_1.setupLoggerAndTelemetry)(this.bus, logger, this.toggleableAnalytics, {
            platform: process.platform,
            arch: process.arch,
            is_containerized: this.isContainerizedEnvironment,
            ...(await (0, get_os_info_1.getOsInfo)())
        }, require('../package.json').version);
        if (analyticsSetupError) {
            this.bus.emit('mongosh:error', analyticsSetupError, 'analytics');
        }
        try {
            this.config = await this.configDirectory.generateOrReadConfig(this.config);
        }
        catch (err) {
            this.warnAboutInaccessibleFile(err);
        }
        this.globalConfig = await this.loadGlobalConfigFile();
        if (driverOptions.autoEncryption) {
            const origExtraOptions = (_a = driverOptions.autoEncryption.extraOptions) !== null && _a !== void 0 ? _a : {};
            if (origExtraOptions.cryptSharedLibPath) {
                this.cachedCryptLibraryPath = Promise.resolve({
                    cryptSharedLibPath: origExtraOptions.cryptSharedLibPath
                });
            }
            const extraOptions = {
                ...origExtraOptions,
                ...await this.getCryptLibraryOptions()
            };
            driverOptions.autoEncryption = { ...driverOptions.autoEncryption, extraOptions };
        }
        if (Object.keys((_b = driverOptions.autoEncryption) !== null && _b !== void 0 ? _b : {}).join(',') === 'extraOptions') {
            delete driverOptions.autoEncryption;
        }
        driverOptions = await this.prepareOIDCOptions(driverOptions);
        let initialServiceProvider;
        try {
            initialServiceProvider = await this.connect(driverUri, driverOptions);
        }
        catch (err) {
            if (typeof err === 'object' &&
                (err === null || err === void 0 ? void 0 : err.constructor.name) === 'MongoDBOIDCError' &&
                !((_d = String((_c = driverOptions.oidc) === null || _c === void 0 ? void 0 : _c.allowedFlows)) === null || _d === void 0 ? void 0 : _d.includes('device-auth'))) {
                err.message +=
                    '\nConsider specifying --oidcFlows=auth-code,device-auth if you are running mongosh in an environment without browser access.';
            }
            throw err;
        }
        const initialized = await this.mongoshRepl.initialize(initialServiceProvider);
        this.injectReplFunctions();
        const commandLineLoadFiles = (_e = this.cliOptions.fileNames) !== null && _e !== void 0 ? _e : [];
        const evalScripts = (_f = this.cliOptions.eval) !== null && _f !== void 0 ? _f : [];
        const willExecuteCommandLineScripts = commandLineLoadFiles.length > 0 || evalScripts.length > 0;
        const willEnterInteractiveMode = !willExecuteCommandLineScripts || !!this.cliOptions.shell;
        if ((evalScripts.length === 0 || this.cliOptions.shell || commandLineLoadFiles.length > 0) && this.cliOptions.json) {
            throw new errors_1.MongoshRuntimeError('Cannot use --json without --eval or with --shell or with extra files');
        }
        let snippetManager;
        if (this.config.snippetIndexSourceURLs !== '') {
            snippetManager = snippet_manager_1.SnippetManager.create({
                installdir: this.shellHomeDirectory.roamingPath('snippets'),
                instanceState: this.mongoshRepl.runtimeState().instanceState,
                skipInitialIndexLoad: !willEnterInteractiveMode
            });
        }
        editor_1.Editor.create({
            input: this.input,
            vscodeDir: this.shellHomeDirectory.rcPath('.vscode'),
            tmpDir: this.shellHomeDirectory.localPath('editor'),
            instanceState: this.mongoshRepl.runtimeState().instanceState,
            loadExternalCode: this.mongoshRepl.loadExternalCode.bind(this.mongoshRepl)
        });
        if (willExecuteCommandLineScripts) {
            this.mongoshRepl.setIsInteractive(willEnterInteractiveMode);
            this.bus.emit('mongosh:start-loading-cli-scripts', { usesShellOption: !!this.cliOptions.shell });
            const exitCode = await this.loadCommandLineFilesAndEval(commandLineLoadFiles, evalScripts);
            if (exitCode !== 0) {
                await this.exit(exitCode);
                return;
            }
            if (!this.cliOptions.shell) {
                this.setTelemetryEnabled(await this.getConfig('enableTelemetry'));
                await this.exit(0);
                return;
            }
        }
        else {
            this.mongoshRepl.setIsInteractive(true);
        }
        if (!this.cliOptions.norc) {
            await (snippetManager === null || snippetManager === void 0 ? void 0 : snippetManager.loadAllSnippets());
        }
        await this.loadRcFiles();
        this.setTelemetryEnabled(await this.getConfig('enableTelemetry'));
        this.bus.emit('mongosh:start-mongosh-repl', { version });
        await this.mongoshRepl.startRepl(initialized);
    }
    injectReplFunctions() {
        const functions = {
            async buildInfo() {
                return await (0, build_info_1.buildInfo)({ withCryptSharedVersionInfo: true });
            }
        };
        const { context } = this.mongoshRepl.runtimeState().repl;
        for (const [name, impl] of Object.entries(functions)) {
            context[name] = (...args) => {
                return Object.assign(impl(...args), {
                    [Symbol.for('@@mongosh.syntheticPromise')]: true
                });
            };
        }
    }
    async setupAnalytics() {
        var _a, _b, _c;
        if (process.env.IS_MONGOSH_EVERGREEN_CI && !((_a = this.analyticsOptions) === null || _a === void 0 ? void 0 : _a.alwaysEnable)) {
            throw new Error('no analytics setup for the mongosh CI environment');
        }
        const apiKey = (_c = (_b = this.analyticsOptions) === null || _b === void 0 ? void 0 : _b.apiKey) !== null && _c !== void 0 ? _c : (await (0, build_info_1.buildInfo)({ withSegmentApiKey: true })).segmentApiKey;
        if (!apiKey) {
            throw new Error('no analytics API key defined');
        }
        this.segmentAnalytics = new analytics_node_1.default(apiKey, {
            ...this.analyticsOptions,
            axiosConfig: {
                timeout: 1000
            },
            axiosRetryConfig: { retries: 0 }
        });
        this.toggleableAnalytics = new logging_1.ToggleableAnalytics(this.segmentAnalytics);
    }
    setTelemetryEnabled(enabled) {
        if (this.globalConfig === null) {
            return;
        }
        if (enabled && this.hasOnDiskTelemetryId && !this.forceDisableTelemetry) {
            this.toggleableAnalytics.enable();
        }
        else {
            this.toggleableAnalytics.disable();
        }
    }
    async loadCommandLineFilesAndEval(files, evalScripts) {
        let lastEvalResult;
        let exitCode = 0;
        try {
            for (const script of evalScripts) {
                this.bus.emit('mongosh:eval-cli-script');
                lastEvalResult = await this.mongoshRepl.loadExternalCode(script, '@(shell eval)');
            }
        }
        catch (err) {
            exitCode = 1;
            if (this.cliOptions.json) {
                lastEvalResult = err;
            }
            else {
                throw err;
            }
        }
        if (lastEvalResult !== undefined) {
            let formattedResult;
            if (this.cliOptions.json) {
                try {
                    formattedResult = (0, format_json_1.formatForJSONOutput)(lastEvalResult, this.cliOptions.json);
                }
                catch (e) {
                    exitCode = 1;
                    formattedResult = (0, format_json_1.formatForJSONOutput)(e, this.cliOptions.json);
                }
            }
            else {
                formattedResult = this.mongoshRepl.writer(lastEvalResult);
            }
            this.output.write(formattedResult + '\n');
        }
        for (const file of files) {
            if (!this.cliOptions.quiet) {
                this.output.write(`Loading file: ${this.clr(file, 'mongosh:filename')}\n`);
            }
            await this.mongoshRepl.loadExternalFile(file);
        }
        return exitCode;
    }
    async loadRcFiles() {
        if (this.cliOptions.norc) {
            return;
        }
        const legacyPath = this.shellHomeDirectory.rcPath('.mongorc.js');
        const mongoshrcPath = this.shellHomeDirectory.rcPath('.mongoshrc.js');
        const mongoshrcMisspelledPath = this.shellHomeDirectory.rcPath('.mongoshrc');
        let hasMongoshRc = false;
        try {
            await fs_1.promises.stat(mongoshrcPath);
            hasMongoshRc = true;
        }
        catch (_a) { }
        if (hasMongoshRc) {
            try {
                this.bus.emit('mongosh:mongoshrc-load');
                await this.mongoshRepl.loadExternalFile(mongoshrcPath);
            }
            catch (err) {
                this.output.write(this.clr('Error while running ~/.mongoshrc.js:\n', 'mongosh:warning'));
                this.output.write(this.mongoshRepl.writer(err) + '\n');
            }
            return;
        }
        if (this.cliOptions.quiet) {
            return;
        }
        let hasLegacyRc = false;
        try {
            await fs_1.promises.stat(legacyPath);
            hasLegacyRc = true;
        }
        catch (_b) { }
        if (hasLegacyRc) {
            this.bus.emit('mongosh:mongoshrc-mongorc-warn');
            const msg = 'Warning: Found ~/.mongorc.js, but not ~/.mongoshrc.js. ~/.mongorc.js will not be loaded.\n' +
                '  You may want to copy or rename ~/.mongorc.js to ~/.mongoshrc.js.\n';
            this.output.write(this.clr(msg, 'mongosh:warning'));
            return;
        }
        let hasMisspelledFilename = false;
        try {
            await fs_1.promises.stat(mongoshrcMisspelledPath);
            hasMisspelledFilename = true;
        }
        catch (_c) { }
        if (hasMisspelledFilename) {
            const msg = 'Warning: Found ~/.mongoshrc, but not ~/.mongoshrc.js. Did you forget to add .js?\n';
            this.output.write(this.clr(msg, 'mongosh:warning'));
        }
    }
    async loadGlobalConfigFile() {
        var _a, _b;
        let fileContents = '';
        let filename = '';
        for (filename of this.globalConfigPaths) {
            try {
                fileContents = await fs_1.promises.readFile(filename, 'utf8');
                break;
            }
            catch (err) {
                if ((err === null || err === void 0 ? void 0 : err.code) !== 'ENOENT') {
                    this.bus.emit('mongosh:error', err, 'config');
                }
            }
        }
        this.bus.emit('mongosh:globalconfig-load', { filename, found: fileContents.length > 0 });
        try {
            let config;
            if (fileContents.trim().startsWith('{')) {
                config = service_provider_core_1.bson.EJSON.parse(fileContents);
            }
            else {
                config = (_b = (_a = js_yaml_1.default.load(fileContents)) === null || _a === void 0 ? void 0 : _a.mongosh) !== null && _b !== void 0 ? _b : {};
            }
            for (const [key, value] of Object.entries(config)) {
                const validationResult = await types_1.CliUserConfigValidator.validate(key, value);
                if (validationResult) {
                    const msg = `Warning: Ignoring config option "${key}" from ${filename}: ${validationResult}\n`;
                    this.output.write(this.clr(msg, 'mongosh:warning'));
                    delete config[key];
                }
            }
            return config;
        }
        catch (err) {
            this.bus.emit('mongosh:error', err, 'config');
            const msg = `Warning: Could not parse global configuration file at ${filename}: ${err === null || err === void 0 ? void 0 : err.message}\n`;
            this.output.write(this.clr(msg, 'mongosh:warning'));
            return {};
        }
    }
    warnAboutInaccessibleFile(err, path) {
        this.bus.emit('mongosh:error', err, 'config');
        if (this.warnedAboutInaccessibleFiles) {
            return;
        }
        this.warnedAboutInaccessibleFiles = true;
        const msg = `Warning: Could not access file${path ? 'at ' + path : ''}: ${err.message}\n`;
        this.output.write(this.clr(msg, 'mongosh:warning'));
    }
    async connect(driverUri, driverOptions) {
        if (!this.cliOptions.nodb && !this.cliOptions.quiet) {
            this.output.write(i18n_1.default.__(CONNECTING) + '\t\t' + this.clr((0, history_1.redactURICredentials)(driverUri), 'mongosh:uri') + '\n');
        }
        return await service_provider_server_1.CliServiceProvider.connect(driverUri, driverOptions, this.cliOptions, this.bus);
    }
    getHistoryFilePath() {
        return this.shellHomeDirectory.roamingPath('mongosh_repl_history');
    }
    async getConfig(key) {
        var _a, _b, _c;
        return (_c = (_a = this.config[key]) !== null && _a !== void 0 ? _a : (_b = this.globalConfig) === null || _b === void 0 ? void 0 : _b[key]) !== null && _c !== void 0 ? _c : (new types_1.CliUserConfig())[key];
    }
    async setConfig(key, value) {
        if (key === 'forceDisableTelemetry') {
            throw new errors_1.MongoshRuntimeError("The 'forceDisableTelemetry' setting cannot be modified");
        }
        this.config[key] = value;
        if (key === 'enableTelemetry') {
            this.setTelemetryEnabled(this.config.enableTelemetry);
            this.bus.emit('mongosh:update-user', { userId: this.config.userId, anonymousId: this.config.telemetryAnonymousId });
        }
        try {
            await this.configDirectory.writeConfigFile(this.config);
        }
        catch (err) {
            this.warnAboutInaccessibleFile(err, this.configDirectory.path());
        }
        return 'success';
    }
    listConfigOptions() {
        const hiddenKeys = ['userId', 'telemetryAnonymousId', 'disableGreetingMessage', 'forceDisableTelemetry'];
        const keys = Object.keys(new types_1.CliUserConfig());
        return keys.filter(key => !hiddenKeys.includes(key));
    }
    async verifyNodeVersion() {
        if (process.env.MONGOSH_SKIP_NODE_VERSION_CHECK) {
            return;
        }
        const { engines } = require('../package.json');
        const baseNodeVersion = process.version.replace(/-.*$/, '');
        if (!semver_1.default.satisfies(baseNodeVersion, engines.node)) {
            const warning = new errors_1.MongoshWarning(`Mismatched node version. Required version: ${engines.node}. Currently using: ${process.version}. Exiting...\n\n`, error_codes_1.CliReplErrors.NodeVersionMismatch);
            await this._fatalError(warning);
        }
    }
    isPasswordMissingURI(cs) {
        return !!(cs.username &&
            !cs.password &&
            cs.searchParams.get('authMechanism') !== 'GSSAPI');
    }
    ensurePasswordFieldIsPresentInAuth(driverOptions) {
        if (driverOptions.auth && driverOptions.auth.username && !('password' in driverOptions.auth)) {
            driverOptions.auth.password = undefined;
        }
    }
    async requirePassword() {
        const passwordPromise = (0, askpassword_1.default)({
            input: this.input,
            output: this.output,
            replacementCharacter: '*'
        });
        this.output.write('Enter password: ');
        try {
            try {
                return (await passwordPromise).toString();
            }
            finally {
                this.output.write('\n');
            }
        }
        catch (error) {
            await this._fatalError(error);
        }
        return '';
    }
    async _fatalError(error) {
        this.bus.emit('mongosh:error', error, 'fatal');
        this.output.write(this.mongoshRepl.formatError(error) + '\n');
        return this.exit(1);
    }
    async close() {
        var _a, _b;
        if (this.closing) {
            return;
        }
        if (!this.output.destroyed) {
            if (this.output.writableEnded) {
                try {
                    await (0, events_1.once)(this.output, 'close');
                }
                catch (_c) { }
            }
            else {
                await new Promise(resolve => this.output.write('', resolve));
            }
        }
        this.closing = true;
        const analytics = this.segmentAnalytics;
        let flushError = null;
        let flushDuration = null;
        if (analytics) {
            const flushStart = Date.now();
            try {
                await (0, util_1.promisify)(analytics.flush.bind(analytics))();
            }
            catch (err) {
                flushError = err.message;
            }
            finally {
                flushDuration = Date.now() - flushStart;
            }
        }
        (_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.info('MONGOSH', (0, mongodb_log_writer_1.mongoLogId)(1000000045), 'analytics', 'Flushed outstanding data', {
            flushError,
            flushDuration
        });
        await ((_b = this.logWriter) === null || _b === void 0 ? void 0 : _b.flush());
        this.bus.emit('mongosh:closed');
    }
    async exit(code) {
        await this.close();
        await this.onExit(code);
        const error = new errors_1.MongoshInternalError('onExit() unexpectedly returned');
        this.bus.emit('mongosh:error', error, 'fatal');
        throw error;
    }
    async readFileUTF8(filename) {
        const resolved = path_1.default.resolve(filename);
        return {
            contents: await fs_1.promises.readFile(resolved, 'utf8'),
            absolutePath: resolved
        };
    }
    clr(text, style) {
        return this.mongoshRepl.clr(text, style);
    }
    async getCryptLibraryOptions() {
        var _a;
        if (!this.getCryptLibraryPaths) {
            throw new errors_1.MongoshInternalError('This instance of mongosh is not configured for in-use encryption');
        }
        return ((_a = this.cachedCryptLibraryPath) !== null && _a !== void 0 ? _a : (this.cachedCryptLibraryPath = this.getCryptLibraryPaths(this.bus)));
    }
    bugReportErrorMessageInfo() {
        var _a;
        return `Please include the log file for this session (${(_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.logFilePath}).`;
    }
    getLoggedEnvironmentVariables() {
        const { EDITOR, NODE_OPTIONS, TERM } = process.env;
        return { EDITOR, NODE_OPTIONS, TERM };
    }
    async prepareOIDCOptions(driverOptionsIn) {
        var _a, _b, _c, _d, _e, _f;
        var _g, _h, _j, _k, _l;
        const driverOptions = {
            oidc: {},
            authMechanismProperties: {},
            ...driverOptionsIn
        };
        (_a = (_g = driverOptions.oidc).allowedFlows) !== null && _a !== void 0 ? _a : (_g.allowedFlows = ['auth-code']);
        (_b = (_h = driverOptions.oidc).notifyDeviceFlow) !== null && _b !== void 0 ? _b : (_h.notifyDeviceFlow = ({ verificationUrl, userCode }) => {
            this.output.write('\n' +
                `Visit the following URL to complete authentication: ${this.clr(verificationUrl, 'mongosh:uri')}\n` +
                `Enter the following code on that page: ${this.clr(userCode, 'mongosh:uri')}\nWaiting...\n`);
        });
        const [redirectURI, trustedEndpoints, browser] = await Promise.all([
            this.getConfig('oidcRedirectURI'),
            this.getConfig('oidcTrustedEndpoints'),
            this.getConfig('browser')
        ]);
        if (redirectURI !== undefined) {
            (_c = (_j = driverOptions.oidc).redirectURI) !== null && _c !== void 0 ? _c : (_j.redirectURI = redirectURI);
        }
        if (browser !== undefined) {
            (_d = (_k = driverOptions.oidc).openBrowser) !== null && _d !== void 0 ? _d : (_k.openBrowser = browser !== false ? { command: browser } : browser);
        }
        if (trustedEndpoints !== undefined) {
            (_e = (_l = driverOptions.authMechanismProperties).ALLOWED_HOSTS) !== null && _e !== void 0 ? _e : (_l.ALLOWED_HOSTS = trustedEndpoints);
        }
        if (process.env.MONGOSH_OIDC_PARENT_HANDLE) {
            (_f = driverOptions.parentHandle) !== null && _f !== void 0 ? _f : (driverOptions.parentHandle = process.env.MONGOSH_OIDC_PARENT_HANDLE);
        }
        return driverOptions;
    }
}
exports.CliRepl = CliRepl;
//# sourceMappingURL=cli-repl.js.map