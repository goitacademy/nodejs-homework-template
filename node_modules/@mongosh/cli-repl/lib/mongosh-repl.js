"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const autocomplete_1 = __importDefault(require("@mongosh/autocomplete"));
const errors_1 = require("@mongosh/errors");
const history_1 = require("@mongosh/history");
const shell_api_1 = require("@mongosh/shell-api");
const shell_evaluator_1 = require("@mongosh/shell-evaluator");
const types_1 = require("@mongosh/types");
const askcharacter_1 = __importDefault(require("askcharacter"));
const askpassword_1 = __importDefault(require("askpassword"));
const console_1 = require("console");
const events_1 = require("events");
const pretty_repl_1 = __importDefault(require("pretty-repl"));
const repl_1 = require("repl");
const stream_1 = require("stream");
const util_1 = require("util");
const asyncRepl = __importStar(require("./async-repl"));
const clr_1 = __importDefault(require("./clr"));
const constants_1 = require("./constants");
const format_output_1 = __importStar(require("./format-output"));
const js_multiline_to_singleline_1 = require("@mongosh/js-multiline-to-singleline");
const line_by_line_input_1 = require("./line-by-line-input");
function fixupReplForNodeBug38314(repl) {
    {
        const input = new stream_1.PassThrough();
        const output = new stream_1.PassThrough();
        const evalFn = (code, ctx, filename, cb) => cb(new Error('err'));
        const prompt = 'prompt#';
        (0, repl_1.start)({ input, output, eval: evalFn, prompt });
        input.end('s\n');
        if (!String(output.read()).includes('prompt#prompt#')) {
            return;
        }
    }
    const domain = repl._domain;
    const domainErrorListeners = domain.listeners('error');
    const origListener = domainErrorListeners.find((fn) => fn.name === 'debugDomainError');
    if (!origListener) {
        throw new Error('Could not find REPL domain error listener');
    }
    domain.removeListener('error', origListener);
    domain.on('error', function (err) {
        const origDisplayPrompt = repl.displayPrompt;
        repl.displayPrompt = () => { };
        try {
            origListener.call(this, err);
        }
        finally {
            repl.displayPrompt = origDisplayPrompt;
        }
    });
}
class MongoshNodeRepl {
    constructor(options) {
        this.inspectCompact = 0;
        this.inspectDepth = 0;
        this.started = false;
        this.showStackTraces = false;
        this.loadNestingLevel = 0;
        this.redactHistory = 'remove';
        this.rawValueToShellResult = new WeakMap();
        this.input = options.input;
        this.lineByLineInput = new line_by_line_input_1.LineByLineInput(this.input);
        this.output = options.output;
        this.bus = options.bus;
        this.nodeReplOptions = options.nodeReplOptions || {};
        this.shellCliOptions = options.shellCliOptions || {};
        this.ioProvider = options.ioProvider;
        this.insideAutoCompleteOrGetPrompt = false;
        this._runtimeState = null;
    }
    setIsInteractive(value) {
        this.runtimeState().instanceState.isInteractive = value;
    }
    get isInteractive() {
        return this.runtimeState().instanceState.isInteractive;
    }
    async initialize(serviceProvider) {
        var _a, _b, _c, _d, _e, _f, _g;
        const instanceState = new shell_api_1.ShellInstanceState(serviceProvider, this.bus, this.shellCliOptions);
        const shellEvaluator = new shell_evaluator_1.ShellEvaluator(instanceState, (value) => value);
        instanceState.setEvaluationListener(this);
        await instanceState.fetchConnectionInfo();
        let mongodVersion = (_a = instanceState.connectionInfo.buildInfo) === null || _a === void 0 ? void 0 : _a.version;
        const apiVersion = (_c = (_b = serviceProvider.getRawClient()) === null || _b === void 0 ? void 0 : _b.serverApi) === null || _c === void 0 ? void 0 : _c.version;
        if (apiVersion) {
            mongodVersion = (mongodVersion ? mongodVersion + ' ' : '') + `(API Version ${apiVersion})`;
        }
        await this.greet(mongodVersion);
        await this.printBasicConnectivityWarning(instanceState);
        this.inspectCompact = await this.getConfig('inspectCompact');
        this.inspectDepth = await this.getConfig('inspectDepth');
        this.showStackTraces = await this.getConfig('showStackTraces');
        this.redactHistory = await this.getConfig('redactHistory');
        const repl = asyncRepl.start({
            start: pretty_repl_1.default.start,
            input: this.lineByLineInput,
            output: this.output,
            prompt: '',
            writer: this.writer.bind(this),
            breakEvalOnSigint: true,
            preview: false,
            asyncEval: this.eval.bind(this),
            historySize: await this.getConfig('historyLength'),
            wrapCallbackError: (err) => Object.assign(new errors_1.MongoshInternalError(err.message), { stack: err.stack }),
            onAsyncSigint: this.onAsyncSigint.bind(this),
            ...this.nodeReplOptions
        });
        fixupReplForNodeBug38314(repl);
        const console = new console_1.Console({
            stdout: this.output,
            stderr: this.output,
            colorMode: this.getFormatOptions().colors
        });
        delete repl.context.parcelRequire;
        delete repl.context.__webpack_require__;
        delete repl.context.__non_webpack_require__;
        this.onClearCommand = console.clear.bind(console);
        repl.context.console = console;
        repl.context.Date = Date;
        {
            const globalCryptoDescriptor = (_d = Object.getOwnPropertyDescriptor(repl.context, 'crypto')) !== null && _d !== void 0 ? _d : {};
            if (((_e = globalCryptoDescriptor.value) === null || _e === void 0 ? void 0 : _e.subtle) || ((_g = (_f = globalCryptoDescriptor.get) === null || _f === void 0 ? void 0 : _f.call(null)) === null || _g === void 0 ? void 0 : _g.subtle)) {
                delete repl.context.crypto;
                repl.context.crypto = await Promise.resolve().then(() => __importStar(require('node:crypto')));
            }
        }
        this._runtimeState = {
            shellEvaluator,
            instanceState,
            repl,
            console
        };
        const origReplCompleter = (0, util_1.promisify)(repl.completer.bind(repl));
        const mongoshCompleter = autocomplete_1.default.bind(null, instanceState.getAutocompleteParameters());
        repl.completer =
            (0, util_1.callbackify)(async (text) => {
                this.insideAutoCompleteOrGetPrompt = true;
                try {
                    const [[replResults, replOrig], [mongoshResults, , mongoshResultsExclusive]] = await Promise.all([
                        (async () => await origReplCompleter(text) || [[]])(),
                        (async () => await mongoshCompleter(text))()
                    ]);
                    this.bus.emit('mongosh:autocompletion-complete');
                    if (mongoshResultsExclusive) {
                        return [mongoshResults, text];
                    }
                    const replResultPrefix = replOrig ? text.substr(0, text.lastIndexOf(replOrig)) : '';
                    const longReplResults = replResults.map((result) => replResultPrefix + result);
                    const deduped = [...new Set([...longReplResults, ...mongoshResults])];
                    return [deduped, text];
                }
                finally {
                    this.insideAutoCompleteOrGetPrompt = false;
                }
            });
        let originalHistory = null;
        const originalDisplayPrompt = repl.displayPrompt.bind(repl);
        repl.displayPrompt = (...args) => {
            if (!this.started) {
                return;
            }
            originalDisplayPrompt(...args);
            this.lineByLineInput.nextLine();
        };
        if (repl.commands.editor) {
            const originalEditorAction = repl.commands.editor.action.bind(repl);
            repl.commands.editor.action = (...args) => {
                originalHistory = [...repl.history];
                this.lineByLineInput.disableBlockOnNewline();
                return originalEditorAction(...args);
            };
        }
        repl.defineCommand('clear', {
            help: '',
            action: () => {
                repl.displayPrompt();
            }
        });
        repl.line = '';
        const historyFile = this.ioProvider.getHistoryFilePath();
        try {
            await (0, util_1.promisify)(repl.setupHistory).call(repl, historyFile);
            repl.on('flushHistory', () => {
                if (this.redactHistory !== 'keep') {
                    const history = repl.history;
                    (0, history_1.changeHistory)(history, this.redactHistory === 'remove-redact' ? 'redact-sensitive-data' : 'keep-sensitive-data');
                }
            });
            repl.on(asyncRepl.evalFinish, (ev) => {
                if (this.insideAutoCompleteOrGetPrompt) {
                    return;
                }
                const history = repl.history;
                if (ev.success === false && ev.recoverable) {
                    if (originalHistory === null) {
                        originalHistory = history.slice(1);
                    }
                }
                else if (originalHistory !== null) {
                    const newHistoryEntry = (0, js_multiline_to_singleline_1.makeMultilineJSIntoSingleLine)(ev.input);
                    if (newHistoryEntry.length > 0) {
                        originalHistory.unshift(newHistoryEntry);
                    }
                    history.splice(0, history.length, ...originalHistory);
                    originalHistory = null;
                }
            });
        }
        catch (err) {
            const warn = new errors_1.MongoshWarning('Error processing history file: ' + (err === null || err === void 0 ? void 0 : err.message));
            this.output.write(this.writer(warn) + '\n');
        }
        repl.on(asyncRepl.evalStart, () => {
            this.bus.emit('mongosh:evaluate-started');
        });
        repl.on(asyncRepl.evalFinish, () => {
            this.bus.emit('mongosh:evaluate-finished');
        });
        repl.on('exit', async () => {
            try {
                await this.onExit();
            }
            catch (_a) { }
        });
        instanceState.setCtx(repl.context);
        if (!this.shellCliOptions.nodb && !this.shellCliOptions.quiet) {
            const { shellApi } = instanceState;
            const banners = await Promise.all([
                (async () => await shellApi.show('startupWarnings'))(),
                (async () => await shellApi.show('automationNotices'))(),
                (async () => await shellApi.show('nonGenuineMongoDBCheck'))()
            ]);
            for (const banner of banners) {
                if (banner.value) {
                    await shellApi.print(banner);
                }
            }
        }
        return { __initialized: 'yes' };
    }
    async startRepl(_initializationToken) {
        this.started = true;
        const { repl } = this.runtimeState();
        this.lineByLineInput.start();
        this.input.resume();
        repl.setPrompt(await this.getShellPrompt());
        repl.displayPrompt();
    }
    async greet(mongodVersion) {
        if (this.shellCliOptions.quiet) {
            return;
        }
        const { version } = require('../package.json');
        let text = '';
        if (!this.shellCliOptions.nodb) {
            text += `Using MongoDB:\t\t${mongodVersion}\n`;
        }
        text += `${this.clr('Using Mongosh', 'mongosh:section-header')}:\t\t${version}\n`;
        text += `${constants_1.MONGOSH_WIKI}\n`;
        if (!await this.getConfig('disableGreetingMessage')) {
            text += `${constants_1.TELEMETRY_GREETING_MESSAGE}\n`;
            await this.setConfig('disableGreetingMessage', true);
        }
        this.output.write(text);
    }
    async printBasicConnectivityWarning(instanceState) {
        if (this.shellCliOptions.nodb || this.shellCliOptions.quiet) {
            return;
        }
        let err;
        try {
            await instanceState.currentDb.adminCommand({ ping: 1 });
            return;
        }
        catch (error) {
            err = error;
        }
        const text = this.clr('The server failed to respond to a ping and may be unavailable:', 'mongosh:warning');
        this.output.write(text + '\n' + this.formatError(err) + '\n');
    }
    async eval(originalEval, input, context, filename) {
        if (!this.insideAutoCompleteOrGetPrompt) {
            this.lineByLineInput.enableBlockOnNewLine();
        }
        const { repl, shellEvaluator } = this.runtimeState();
        let interrupted = false;
        try {
            const rawValue = await shellEvaluator.customEval(originalEval, input, context, filename);
            if ((typeof rawValue === 'object' && rawValue !== null) || typeof rawValue === 'function') {
                this.rawValueToShellResult.set(rawValue, await (0, shell_api_1.toShellResult)(rawValue));
            }
            if (!this.insideAutoCompleteOrGetPrompt || (0, shell_api_1.getShellApiType)(rawValue) === null) {
                return rawValue;
            }
            return Object.fromEntries(Object.entries(rawValue)
                .filter(([key]) => !key.startsWith('_')));
        }
        catch (err) {
            if (this.runtimeState().instanceState.interrupted.isSet()) {
                interrupted = true;
                this.bus.emit('mongosh:eval-interrupted');
                return undefined;
            }
            if (!isErrorLike(err)) {
                throw new Error(this.formatOutput({
                    value: err
                }));
            }
            throw err;
        }
        finally {
            if (!this.insideAutoCompleteOrGetPrompt && !interrupted) {
                repl.setPrompt(await this.getShellPrompt());
            }
            if (this.loadNestingLevel <= 1) {
                this.bus.emit('mongosh:eval-complete');
            }
        }
    }
    async onLoad(filename) {
        const { contents, absolutePath } = await this.ioProvider.readFileUTF8(filename);
        return {
            resolvedFilename: absolutePath,
            evaluate: async () => {
                this.loadNestingLevel += 1;
                try {
                    await this.loadExternalCode(contents, absolutePath);
                }
                finally {
                    this.loadNestingLevel -= 1;
                }
            }
        };
    }
    async loadExternalFile(filename) {
        await this.runtimeState().instanceState.shellApi.load(filename);
    }
    async loadExternalCode(input, filename) {
        const { repl } = this.runtimeState();
        return await (0, util_1.promisify)(repl.eval.bind(repl))(input, repl.context, filename);
    }
    async onAsyncSigint() {
        var _a;
        const { instanceState } = this.runtimeState();
        if (instanceState.interrupted.isSet()) {
            return true;
        }
        this.output.write('Stopping execution...');
        const mongodVersion = (_a = instanceState.connectionInfo.buildInfo) === null || _a === void 0 ? void 0 : _a.version;
        if (mongodVersion === null || mongodVersion === void 0 ? void 0 : mongodVersion.match(/^(4\.0\.|3\.)\d+/)) {
            this.output.write(this.clr(`\nWARNING: Operations running on the server cannot be killed automatically for MongoDB ${mongodVersion}.` +
                '\n         Please make sure to kill them manually. Killing operations is supported starting with MongoDB 4.1.', 'mongosh:warning'));
        }
        const fullyInterrupted = await instanceState.onInterruptExecution();
        await Promise.race([
            (0, events_1.once)(this.bus, 'mongosh:eval-interrupted'),
            new Promise(setImmediate)
        ]);
        const fullyResumed = await instanceState.onResumeExecution();
        if (!fullyInterrupted || !fullyResumed) {
            this.output.write(this.formatError({
                name: 'MongoshInternalError',
                message: 'Could not re-establish all connections, we suggest to restart the shell.'
            }));
        }
        this.bus.emit('mongosh:interrupt-complete');
        const { repl } = this.runtimeState();
        repl.setPrompt(await this.getShellPrompt());
        return true;
    }
    writer(result) {
        var _a;
        if (isErrorLike(result)) {
            const output = {
                ...result,
                message: result.message || result.errmsg,
                name: result.name || 'MongoshInternalError',
                stack: result.stack
            };
            this.bus.emit('mongosh:error', output, 'repl');
            return this.formatError(output);
        }
        return this.formatShellResult((_a = this.rawValueToShellResult.get(result)) !== null && _a !== void 0 ? _a : { type: null, printable: result });
    }
    formatShellResult(result, extraFormatOptions = {}) {
        return this.formatOutput({ type: result.type, value: result.printable }, extraFormatOptions);
    }
    onPrint(values, type) {
        const extraOptions = type === 'printjson'
            ? {
                compact: false,
                depth: Infinity,
                maxArrayLength: Infinity,
                maxStringLength: Infinity
            }
            : undefined;
        const joined = values
            .map((value) => this.formatShellResult(value, extraOptions))
            .join(' ');
        this.output.write(joined + '\n');
    }
    async onPrompt(question, type) {
        var _a;
        if (type === 'password') {
            const passwordPromise = (0, askpassword_1.default)({
                input: this.input,
                output: this.output,
                replacementCharacter: '*'
            });
            this.output.write(question + '\n');
            return (await passwordPromise).toString();
        }
        else if (type === 'yesno') {
            let result = '';
            while (true) {
                const charPromise = (0, askcharacter_1.default)({
                    input: this.input,
                    output: this.output
                });
                this.output.write(question + ': ');
                result = await charPromise;
                if (result.length > 0 && !result.match(/^[yYnN\r\n]$/)) {
                    this.output.write('\nPlease enter Y or N: ');
                }
                else {
                    break;
                }
            }
            this.output.write('\n');
            return (_a = { 'Y': 'yes', 'N': 'no' }[result.toUpperCase()]) !== null && _a !== void 0 ? _a : '';
        }
        throw new Error(`Unrecognized prompt type ${type}`);
    }
    formatOutput(value, extraFormatOptions = {}) {
        return (0, format_output_1.default)(value, {
            ...this.getFormatOptions(),
            ...extraFormatOptions
        });
    }
    formatError(value) {
        return (0, format_output_1.formatError)(value, this.getFormatOptions());
    }
    clr(text, style) {
        return (0, clr_1.default)(text, style, this.getFormatOptions());
    }
    getFormatOptions() {
        var _a, _b, _c, _d, _e;
        const output = this.output;
        return {
            colors: (_c = (_b = (_a = this._runtimeState) === null || _a === void 0 ? void 0 : _a.repl) === null || _b === void 0 ? void 0 : _b.useColors) !== null && _c !== void 0 ? _c : (output.isTTY && output.getColorDepth() > 1),
            compact: this.inspectCompact,
            depth: this.inspectDepth,
            showStackTraces: this.showStackTraces,
            bugReportErrorMessageInfo: (_e = (_d = this.ioProvider).bugReportErrorMessageInfo) === null || _e === void 0 ? void 0 : _e.call(_d)
        };
    }
    runtimeState() {
        if (this._runtimeState === null) {
            throw new errors_1.MongoshInternalError('Mongosh not initialized yet');
        }
        return this._runtimeState;
    }
    async close() {
        const rs = this._runtimeState;
        if (rs) {
            this._runtimeState = null;
            rs.repl.close();
            await rs.instanceState.close(true);
            await new Promise(resolve => this.output.write('', resolve));
        }
    }
    async onExit(exitCode) {
        await this.close();
        return this.ioProvider.exit(exitCode);
    }
    async getConfig(key) {
        return this.ioProvider.getConfig(key);
    }
    async setConfig(key, value) {
        const result = await this.ioProvider.setConfig(key, value);
        if (result === 'success') {
            if (key === 'historyLength' && this._runtimeState) {
                this.runtimeState().repl.historySize = value;
            }
            if (key === 'inspectCompact') {
                this.inspectCompact = value;
            }
            if (key === 'inspectDepth') {
                this.inspectDepth = value;
            }
            if (key === 'showStackTraces') {
                this.showStackTraces = value;
            }
            if (key === 'redactHistory') {
                this.redactHistory = value;
            }
        }
        return result;
    }
    async resetConfig(key) {
        return await this.setConfig(key, (new types_1.CliUserConfig())[key]);
    }
    async validateConfig(key, value) {
        return types_1.CliUserConfigValidator.validate(key, value);
    }
    listConfigOptions() {
        return this.ioProvider.listConfigOptions();
    }
    async getCryptLibraryOptions() {
        return this.ioProvider.getCryptLibraryOptions();
    }
    async getShellPrompt() {
        const { repl, instanceState } = this.runtimeState();
        try {
            this.insideAutoCompleteOrGetPrompt = true;
            if (typeof repl.context.prompt !== 'undefined') {
                const promptResult = await this.loadExternalCode(`
        (() => {
          switch (typeof prompt) {
            case 'function':
              return prompt();
            case 'string':
              return prompt;
          }
        })()`, '<prompt loader>');
                if (typeof promptResult === 'string') {
                    return promptResult;
                }
            }
        }
        catch (_a) {
        }
        finally {
            this.insideAutoCompleteOrGetPrompt = false;
        }
        try {
            return await instanceState.getDefaultPrompt();
        }
        catch (_b) {
        }
        return '> ';
    }
}
function isErrorLike(value) {
    try {
        return value && (0, shell_api_1.getShellApiType)(value) === null && ((value.message !== undefined && typeof value.stack === 'string') ||
            (value.code !== undefined && value.errmsg !== undefined));
    }
    catch (err) {
        throw new errors_1.MongoshInternalError((err === null || err === void 0 ? void 0 : err.message) || String(err));
    }
}
exports.default = MongoshNodeRepl;
//# sourceMappingURL=mongosh-repl.js.map