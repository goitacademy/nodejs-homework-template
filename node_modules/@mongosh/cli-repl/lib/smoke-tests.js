"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runSmokeTests = void 0;
const child_process_1 = require("child_process");
const assert_1 = __importDefault(require("assert"));
const events_1 = require("events");
const history_1 = require("@mongosh/history");
const smoke_tests_fle_1 = __importDefault(require("./smoke-tests-fle"));
const build_info_1 = require("./build-info");
async function runSmokeTests(smokeTestServer, executable, ...args) {
    console.log('MONGOSH_SMOKE_TEST_SERVER set?', !!smokeTestServer);
    if (process.env.IS_CI) {
        (0, assert_1.default)(!!smokeTestServer, 'Make sure MONGOSH_SMOKE_TEST_SERVER is set in CI');
    }
    const expectFipsSupport = !!process.env.MONGOSH_SMOKE_TEST_OS_HAS_FIPS_SUPPORT && (await (0, build_info_1.buildInfo)()).sharedOpenssl;
    console.log('FIPS support required to pass?', { expectFipsSupport });
    for (const { input, output, testArgs, includeStderr, exitCode } of [{
            input: 'print("He" + "llo" + " Wor" + "ld!")',
            output: /Hello World!/,
            includeStderr: false,
            testArgs: ['--nodb'],
            exitCode: 0
        }, {
            input: '',
            output: /ReferenceError/,
            includeStderr: true,
            testArgs: ['--nodb', '--eval', 'foo.bar()'],
            exitCode: 1
        }, {
            input: '',
            output: /Hello World!/,
            includeStderr: false,
            testArgs: ['--nodb', '--eval', 'print("He" + "llo" + " Wor" + "ld!")'],
            exitCode: 0,
        }, {
            input: 'crypto.createHash("md5").update("hello").digest("hex")',
            output: expectFipsSupport ?
                /disabled for FIPS|digital envelope routines::unsupported/i :
                /disabled for FIPS|digital envelope routines::unsupported|Could not enable FIPS mode/i,
            includeStderr: true,
            testArgs: ['--tlsFIPSMode', '--nodb']
        }, {
            input: 'crypto.createHash("sha256").update("hello").digest("hex")',
            output: expectFipsSupport ?
                /2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824/i :
                /2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824|digital envelope routines::unsupported|Could not enable FIPS mode/i,
            includeStderr: true,
            testArgs: ['--tlsFIPSMode', '--nodb']
        }].concat(smokeTestServer ? [{
            input: `
      const dbname = "testdb_simplesmoke" + new Date().getTime();
      use(dbname);
      db.testcoll.insertOne({ d: new Date() });
      if (Object.keys(EJSON.serialize(db.testcoll.findOne()).d)[0] === '$date') {
        print('Test succeeded');
      }
      db.dropDatabase();`,
            output: /Test succeeded/,
            includeStderr: false,
            exitCode: 0,
            testArgs: [smokeTestServer]
        }, {
            input: smoke_tests_fle_1.default,
            output: /Test succeeded|Test skipped/,
            includeStderr: false,
            exitCode: 0,
            testArgs: [smokeTestServer]
        }] : [])) {
        await runSmokeTest({
            executable,
            args: [...args, ...testArgs],
            input,
            output,
            includeStderr,
            exitCode
        });
    }
    console.log('all tests passed');
}
exports.runSmokeTests = runSmokeTests;
async function runSmokeTest({ executable, args, input, output, exitCode, includeStderr }) {
    var _a;
    const proc = (0, child_process_1.spawn)(executable, [...args], {
        stdio: ['pipe', 'pipe', includeStderr ? 'pipe' : 'inherit']
    });
    let stdout = '';
    let stderr = '';
    proc.stdout.setEncoding('utf8').on('data', (chunk) => { stdout += chunk; });
    (_a = proc.stderr) === null || _a === void 0 ? void 0 : _a.setEncoding('utf8').on('data', (chunk) => { stderr += chunk; });
    proc.stdin.end(input);
    const [[actualExitCode]] = await Promise.all([
        (0, events_1.once)(proc, 'exit'),
        (0, events_1.once)(proc.stdout, 'end'),
        proc.stderr && (0, events_1.once)(proc.stderr, 'end')
    ]);
    const metadata = { input, output, stdout, stderr, executable, actualExitCode, args: args.map(arg => (0, history_1.redactURICredentials)(arg)) };
    try {
        assert_1.default.match(includeStderr ? `${stdout}\n${stderr}` : stdout, output);
        if (exitCode !== undefined) {
            assert_1.default.strictEqual(actualExitCode, exitCode);
        }
        console.error({ status: 'success', ...metadata });
    }
    catch (err) {
        console.error({ status: 'failure', ...metadata });
        throw err;
    }
}
//# sourceMappingURL=smoke-tests.js.map