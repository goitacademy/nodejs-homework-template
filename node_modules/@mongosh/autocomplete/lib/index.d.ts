import { Topologies } from '@mongosh/shell-api';
export interface AutocompleteParameters {
    topology: () => Topologies;
    connectionInfo: () => undefined | {
        is_atlas: boolean;
        is_data_federation: boolean;
        server_version: string;
    };
    apiVersionInfo: () => {
        version: string;
        strict: boolean;
    } | undefined;
    getCollectionCompletionsForCurrentDb: (collName: string) => string[] | Promise<string[]>;
    getDatabaseCompletions: (dbName: string) => string[] | Promise<string[]>;
}
export declare const BASE_COMPLETIONS: ({
    readonly name: "$accumulator";
    readonly value: "$accumulator";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "4.4.0";
} | {
    readonly name: "$addToSet";
    readonly value: "$addToSet";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
} | {
    readonly name: "$avg";
    readonly value: "$avg";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
    readonly projectVersion: "3.2.0";
} | {
    readonly name: "$bottom";
    readonly value: "$bottom";
    readonly score: 1;
    readonly meta: "accumulator:bottom-n";
    readonly version: "5.2.0";
} | {
    readonly name: "$bottomN";
    readonly value: "$bottomN";
    readonly score: 1;
    readonly meta: "accumulator:bottom-n";
    readonly version: "5.2.0";
} | {
    readonly name: "$covariancePop";
    readonly value: "$covariancePop";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$covarianceSamp";
    readonly value: "$covarianceSamp";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$count";
    readonly value: "$count";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "5.0.0";
} | {
    readonly name: "$derivative";
    readonly value: "$derivative";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$denseRank";
    readonly value: "$denseRank";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$documentNumber";
    readonly value: "$documentNumber";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$expMovingAvg";
    readonly value: "$expMovingAvg";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$first";
    readonly value: "$first";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
} | {
    readonly name: "$firstN";
    readonly value: "$firstN";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "5.1.0";
} | {
    readonly name: "$integral";
    readonly value: "$integral";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$last";
    readonly value: "$last";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
} | {
    readonly name: "$lastN";
    readonly value: "$lastN";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "5.2.0";
} | {
    readonly name: "$max";
    readonly value: "$max";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
    readonly projectVersion: "3.2.0";
} | {
    readonly name: "$maxN";
    readonly value: "$maxN";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "5.2.0";
} | {
    readonly name: "$min";
    readonly value: "$min";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
    readonly projectVersion: "3.2.0";
} | {
    readonly name: "$minN";
    readonly value: "$minN";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "5.2.0";
} | {
    readonly name: "$push";
    readonly value: "$push";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
} | {
    readonly name: "$rank";
    readonly value: "$rank";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$stdDevPop";
    readonly value: "$stdDevPop";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "3.2.0";
    readonly projectVersion: "3.2.0";
} | {
    readonly name: "$stdDevSamp";
    readonly value: "$stdDevSamp";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "3.2.0";
    readonly projectVersion: "3.2.0";
} | {
    readonly name: "$shift";
    readonly value: "$shift";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$sum";
    readonly value: "$sum";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
    readonly projectVersion: "3.2.0";
} | {
    readonly name: "$top";
    readonly value: "$top";
    readonly score: 1;
    readonly meta: "accumulator:top-n";
    readonly version: "5.2.0";
} | {
    readonly name: "$topN";
    readonly value: "$topN";
    readonly score: 1;
    readonly meta: "accumulator:top-n";
    readonly version: "5.2.0";
} | {
    readonly name: "$locf";
    readonly value: "$locf";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.3.0";
} | {
    readonly name: "$linearFill";
    readonly value: "$linearFill";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.3.0";
} | {
    readonly name: "Code";
    readonly value: "Code";
    readonly label: "Code";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON Code type";
    readonly snippet: "Code('${1:code}')";
} | {
    readonly name: "ObjectId";
    readonly value: "ObjectId";
    readonly label: "ObjectId";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON ObjectId type";
    readonly snippet: "ObjectId('${1:id}')";
} | {
    readonly name: "Binary";
    readonly value: "Binary";
    readonly label: "Binary";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON Binary type";
    readonly snippet: "Binary('${1:data}', '${2:subType}')";
} | {
    readonly name: "DBRef";
    readonly value: "DBRef";
    readonly label: "DBRef";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON DBRef type";
    readonly snippet: "DBRef('${1:ns}', '${2:oid}')";
} | {
    readonly name: "Timestamp";
    readonly value: "Timestamp";
    readonly label: "Timestamp";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON Timestamp type";
    readonly snippet: "Timestamp(${1:low}, ${2:high})";
} | {
    readonly name: "NumberInt";
    readonly value: "NumberInt";
    readonly label: "NumberInt";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON 32 bit Integer type";
    readonly snippet: "NumberInt(${1:value})";
} | {
    readonly name: "NumberLong";
    readonly value: "NumberLong";
    readonly label: "NumberLong";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON 64 but Integer type";
    readonly snippet: "NumberLong(${1:value})";
} | {
    readonly name: "NumberDecimal";
    readonly value: "NumberDecimal";
    readonly label: "NumberDecimal";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "3.4.0";
    readonly description: "BSON Decimal128 type";
    readonly snippet: "NumberDecimal('${1:value}')";
} | {
    readonly name: "MaxKey";
    readonly value: "MaxKey";
    readonly label: "MaxKey";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON MaxKey type";
    readonly snippet: "MaxKey()";
} | {
    readonly name: "MinKey";
    readonly value: "MinKey";
    readonly label: "MinKey";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON MinKey type";
    readonly snippet: "MinKey()";
} | {
    readonly name: "ISODate";
    readonly value: "ISODate";
    readonly label: "ISODate";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON Date type";
    readonly snippet: "ISODate('${1:date}')";
} | {
    readonly name: "RegExp";
    readonly value: "RegExp";
    readonly label: "RegExp";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON Regex type";
    readonly snippet: "RegExp('${1:source}', '${2:opts}')";
} | {
    readonly name: "$convert";
    readonly value: "$convert";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$ltrim";
    readonly value: "$ltrim";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "3.7.2";
} | {
    readonly name: "$rtrim";
    readonly value: "$rtrim";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "3.7.2";
} | {
    readonly name: "$toBool";
    readonly value: "$toBool";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toDate";
    readonly value: "$toDate";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toDecimal";
    readonly value: "$toDecimal";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toDouble";
    readonly value: "$toDouble";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toInt";
    readonly value: "$toInt";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toLong";
    readonly value: "$toLong";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toObjectId";
    readonly value: "$toObjectId";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toString";
    readonly value: "$toString";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$trim";
    readonly value: "$trim";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "3.7.2";
} | {
    readonly name: "$abs";
    readonly value: "$abs";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$accumulator";
    readonly value: "$accumulator";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "4.4.0";
} | {
    readonly name: "$add";
    readonly value: "$add";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "2.2.0";
} | {
    readonly name: "$allElementsTrue";
    readonly value: "$allElementsTrue";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$and";
    readonly value: "$and";
    readonly score: 1;
    readonly meta: "expr:bool";
    readonly version: "2.2.0";
} | {
    readonly name: "$anyElementTrue";
    readonly value: "$anyElementTrue";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$arrayElemAt";
    readonly value: "$arrayElemAt";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.2.0";
} | {
    readonly name: "$arrayToObject";
    readonly value: "$arrayToObject";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.4";
} | {
    readonly name: "$binarySize";
    readonly value: "$binarySize";
    readonly score: 1;
    readonly meta: "expr:obj";
    readonly version: "4.4.0";
} | {
    readonly name: "$bsonSize";
    readonly value: "$bsonSize";
    readonly score: 1;
    readonly meta: "expr:obj";
    readonly version: "4.4.0";
} | {
    readonly name: "$ceil";
    readonly value: "$ceil";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$cmp";
    readonly value: "$cmp";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$concat";
    readonly value: "$concat";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "2.4.0";
} | {
    readonly name: "$concatArrays";
    readonly value: "$concatArrays";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.2.0";
} | {
    readonly name: "$cond";
    readonly value: "$cond";
    readonly score: 1;
    readonly meta: "expr:cond";
    readonly version: "2.6.0";
} | {
    readonly name: "$dateAdd";
    readonly value: "$dateAdd";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "5.0.0";
} | {
    readonly name: "$dateDiff";
    readonly value: "$dateDiff";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "5.0.0";
} | {
    readonly name: "$dateFromParts";
    readonly value: "$dateFromParts";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.6.0";
} | {
    readonly name: "$dateFromString";
    readonly value: "$dateFromString";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.6.0";
} | {
    readonly name: "$dateSubtract";
    readonly value: "$dateSubtract";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "5.0.0";
} | {
    readonly name: "$dateToParts";
    readonly value: "$dateToParts";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.6.0";
} | {
    readonly name: "$dateToString";
    readonly value: "$dateToString";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.6.0";
} | {
    readonly name: "$dateTrunc";
    readonly value: "$dateTrunc";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "5.0.0";
} | {
    readonly name: "$dayOfMonth";
    readonly value: "$dayOfMonth";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$dayOfWeek";
    readonly value: "$dayOfWeek";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$dayOfYear";
    readonly value: "$dayOfYear";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$dateToString";
    readonly value: "$dateToString";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.0.0";
} | {
    readonly name: "$divide";
    readonly value: "$divide";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "2.2.0";
} | {
    readonly name: "$eq";
    readonly value: "$eq";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$exp";
    readonly value: "$exp";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$filter";
    readonly value: "$filter";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.2.0";
} | {
    readonly name: "$first";
    readonly value: "$first";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "4.4.0";
} | {
    readonly name: "$floor";
    readonly value: "$floor";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$function";
    readonly value: "$function";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "4.4.0";
} | {
    readonly name: "$getField";
    readonly value: "$getField";
    readonly score: 1;
    readonly meta: "expr:get";
    readonly version: "5.0.0";
} | {
    readonly name: "$gt";
    readonly value: "$gt";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$gte";
    readonly value: "$gte";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$hour";
    readonly value: "$hour";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$ifNull";
    readonly value: "$ifNull";
    readonly score: 1;
    readonly meta: "expr:cond";
    readonly version: "2.2.0";
} | {
    readonly name: "$in";
    readonly value: "$in";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.0";
} | {
    readonly name: "$indexOfArray";
    readonly value: "$indexOfArray";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.0";
} | {
    readonly name: "$indexOfBytes";
    readonly value: "$indexOfBytes";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$indexOfCP";
    readonly value: "$indexOfCP";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$isArray";
    readonly value: "$isArray";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.2.0";
} | {
    readonly name: "$isNumber";
    readonly value: "$isNumber";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "4.4.0";
} | {
    readonly name: "$isoDayOfWeek";
    readonly value: "$isoDayOfWeek";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.4.0";
} | {
    readonly name: "$isoWeek";
    readonly value: "$isoWeek";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.4.0";
} | {
    readonly name: "$isoWeekYear";
    readonly value: "$isoWeekYear";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.4.0";
} | {
    readonly name: "$last";
    readonly value: "$last";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "4.4.0";
} | {
    readonly name: "$let";
    readonly value: "$let";
    readonly score: 1;
    readonly meta: "expr:var";
    readonly version: "2.6.0";
} | {
    readonly name: "$literal";
    readonly value: "$literal";
    readonly score: 1;
    readonly meta: "expr:literal";
    readonly version: "2.6.0";
} | {
    readonly name: "$lt";
    readonly value: "$lt";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$lt";
    readonly value: "$lte";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$ln";
    readonly value: "$ln";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$log";
    readonly value: "$log";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$log10";
    readonly value: "$log10";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$map";
    readonly value: "$map";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "2.6.0";
} | {
    readonly name: "$mergeObjects";
    readonly value: "$mergeObjects";
    readonly score: 1;
    readonly meta: "expr:obj";
    readonly version: "3.6.0";
} | {
    readonly name: "$meta";
    readonly value: "$meta";
    readonly score: 1;
    readonly meta: "expr:text";
    readonly version: "2.6.0";
} | {
    readonly name: "$millisecond";
    readonly value: "$millisecond";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.4.0";
} | {
    readonly name: "$minute";
    readonly value: "$minute";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$mod";
    readonly value: "$mod";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "2.2.0";
} | {
    readonly name: "$month";
    readonly value: "$month";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$multiply";
    readonly value: "$multiply";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "2.2.0";
} | {
    readonly name: "$new";
    readonly value: "$new";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$not";
    readonly value: "$not";
    readonly score: 1;
    readonly meta: "expr:bool";
    readonly version: "2.2.0";
} | {
    readonly name: "$objectToArray";
    readonly value: "$objectToArray";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.4";
} | {
    readonly name: "$or";
    readonly value: "$or";
    readonly score: 1;
    readonly meta: "expr:bool";
    readonly version: "2.2.0";
} | {
    readonly name: "$pow";
    readonly value: "$pow";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$range";
    readonly value: "$range";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.0";
} | {
    readonly name: "$reduce";
    readonly value: "$reduce";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.0";
} | {
    readonly name: "$regexFind";
    readonly value: "$regexFind";
    readonly score: 1;
    readonly meta: "expr:regex";
    readonly version: "4.1.11";
} | {
    readonly name: "$regexFindAll";
    readonly value: "$regexFindAll";
    readonly score: 1;
    readonly meta: "expr:regex";
    readonly version: "4.1.11";
} | {
    readonly name: "$regexMatch";
    readonly value: "$regexMatch";
    readonly score: 1;
    readonly meta: "expr:regex";
    readonly version: "4.1.11";
} | {
    readonly name: "$replaceAll";
    readonly value: "$replaceAll";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "4.4.0";
} | {
    readonly name: "$replaceOne";
    readonly value: "$replaceOne";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "4.4.0";
} | {
    readonly name: "$reverseArray";
    readonly value: "$reverseArray";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.0";
} | {
    readonly name: "$second";
    readonly value: "$second";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$setDifference";
    readonly value: "$setDifference";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$setEquals";
    readonly value: "$setEquals";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$setIntersection";
    readonly value: "$setIntersection";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$setIsSubset";
    readonly value: "$setIsSubset";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$setUnion";
    readonly value: "$setUnion";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$size";
    readonly value: "$size";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "2.6.0";
} | {
    readonly name: "$slice";
    readonly value: "$slice";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.2.0";
} | {
    readonly name: "$sortArray";
    readonly value: "$sortArray";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "5.2.0";
} | {
    readonly name: "$split";
    readonly value: "$split";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$sqrt";
    readonly value: "$sqrt";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$strcasecmp";
    readonly value: "$strcasecmp";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "2.2.0";
} | {
    readonly name: "$strLenBytes";
    readonly value: "$strLenBytes";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$strLenCP";
    readonly value: "$strLenCP";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$substr";
    readonly value: "$substr";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "2.2.0";
    readonly deprecated: "3.4.0";
    readonly replacement: "$substrBytes";
} | {
    readonly name: "$substrBytes";
    readonly value: "$substrBytes";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$substrCP";
    readonly value: "$substrCP";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$subtract";
    readonly value: "$subtract";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$switch";
    readonly value: "$switch";
    readonly score: 1;
    readonly meta: "expr:cond";
    readonly version: "3.4.0";
} | {
    readonly name: "$toLower";
    readonly value: "$toLower";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "2.2.0";
} | {
    readonly name: "$toUpper";
    readonly value: "$toUpper";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "2.2.0";
} | {
    readonly name: "$tsSecond";
    readonly value: "$tsSecond";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "5.1.0";
} | {
    readonly name: "$tsIncrement";
    readonly value: "$tsIncrement";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "5.1.0";
} | {
    readonly name: "$trunc";
    readonly value: "$trunc";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$type";
    readonly value: "$type";
    readonly score: 1;
    readonly meta: "expr:type";
    readonly version: "3.4.0";
} | {
    readonly name: "$week";
    readonly value: "$week";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$year";
    readonly value: "$year";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$zip";
    readonly value: "$zip";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.0";
} | {
    readonly name: "$bitAnd";
    readonly value: "$bitAnd";
    readonly score: 1;
    readonly meta: "expr:bit";
    readonly version: "7.0.0";
} | {
    readonly name: "$bitOr";
    readonly value: "$bitOr";
    readonly score: 1;
    readonly meta: "expr:bit";
    readonly version: "7.0.0";
} | {
    readonly name: "$bitXor";
    readonly value: "$bitXor";
    readonly score: 1;
    readonly meta: "expr:bit";
    readonly version: "7.0.0";
} | {
    readonly name: "$bitNot";
    readonly value: "$bitNot";
    readonly score: 1;
    readonly meta: "expr:bit";
    readonly version: "7.0.0";
} | {
    readonly name: "$all";
    readonly value: "$all";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$and";
    readonly value: "$and";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$bitsAllClear";
    readonly value: "$bitsAllClear";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$bitsAllSet";
    readonly value: "$bitsAllSet";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$bitsAnyClear";
    readonly value: "$bitsAnyClear";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$bitsAnySet";
    readonly value: "$bitsAnySet";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$comment";
    readonly value: "$comment";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$elemMatch";
    readonly value: "$elemMatch";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$eq";
    readonly value: "$eq";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$exists";
    readonly value: "$exists";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$expr";
    readonly value: "$expr";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.6.0";
    readonly geospatial: false;
} | {
    readonly name: "$geoIntersects";
    readonly value: "$geoIntersects";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: true;
} | {
    readonly name: "$geoWithin";
    readonly value: "$geoWithin";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: true;
} | {
    readonly name: "$gt";
    readonly value: "$gt";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$gte";
    readonly value: "$gte";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$in";
    readonly value: "$in";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$jsonSchema";
    readonly value: "$jsonSchema";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.6.0";
    readonly geospatial: false;
} | {
    readonly name: "$lt";
    readonly value: "$lt";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$lte";
    readonly value: "$lte";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$mod";
    readonly value: "$mod";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$ne";
    readonly value: "$ne";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$near";
    readonly value: "$near";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: true;
} | {
    readonly name: "$nearSphere";
    readonly value: "$nearSphere";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: true;
} | {
    readonly name: "$nin";
    readonly value: "$nin";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$not";
    readonly value: "$not";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$nor";
    readonly value: "$nor";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$or";
    readonly value: "$or";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$regex";
    readonly value: "$regex";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$size";
    readonly value: "$size";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$slice";
    readonly value: "$slice";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$text";
    readonly value: "$text";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$type";
    readonly value: "$type";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$where";
    readonly value: "$where";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$addFields";
    readonly value: "$addFields";
    readonly label: "$addFields";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Adds new field(s) to a document with a computed value, or reassigns an existing field(s) with a computed value.";
    readonly comment: "/**\n * newField: The new field name.\n * expression: The new field expression.\n */\n";
    readonly snippet: "{\n  ${1:newField}: ${2:expression}, ${3:...}\n}";
} | {
    readonly name: "$bucket";
    readonly value: "$bucket";
    readonly label: "$bucket";
    readonly outputStage: false;
    readonly fullScan: true;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Categorizes incoming documents into groups, called buckets, based on specified boundaries.";
    readonly comment: "/**\n * groupBy: The expression to group by.\n * boundaries: An array of the lower boundaries for each bucket.\n * default: The bucket name for documents that do not fall within the specified boundaries\n * output: {\n *   outputN: Optional. The output object may contain a single or numerous field names used to accumulate values per bucket.\n * }\n */\n";
    readonly snippet: "{\n  groupBy: ${1:expression},\n  boundaries: [ ${2:lowerbound}, ${3:...} ],\n  default: ${4:literal},\n  output: {\n    ${5:outputN}: { ${6:accumulator} }, ${7:...}\n  }\n}";
} | {
    readonly name: "$bucketAuto";
    readonly value: "$bucketAuto";
    readonly label: "$bucketAuto";
    readonly outputStage: false;
    readonly fullScan: true;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Automatically categorizes documents into a specified number of buckets, attempting even distribution if possible.";
    readonly comment: "/**\n * groupBy: The expression to group by.\n * buckets: The desired number of buckets\n * output: {\n *   outputN: Optional. The output object may contain a single or numerous field names used to accumulate values per bucket.\n * }\n * granularity: Optional number series\n */\n";
    readonly snippet: "{\n  groupBy: ${1:expression},\n  buckets: ${2:number},\n  output: {\n    ${3:outputN}: ${4:accumulator}, ${5:...}\n  },\n  granularity: '${6:string}'\n}";
} | {
    readonly name: "$collStats";
    readonly value: "$collStats";
    readonly label: "$collStats";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: true;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [];
    readonly namespaces: readonly ["coll", "view", "timeseries"];
    readonly description: "Returns statistics regarding a collection or view.";
    readonly comment: "/**\n * histograms: Optional latency histograms.\n * storageStats: Optional storage stats.\n */\n";
    readonly snippet: "{\n  latencyStats: {\n    histograms: ${1:boolean}\n  },\n  storageStats: {${2:}},\n}";
} | {
    readonly name: "$count";
    readonly value: "$count";
    readonly label: "$count";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Returns a count of the number of documents at this stage of the aggregation pipeline.";
    readonly comment: "/**\n * Provide the field name for the count.\n */\n";
    readonly snippet: "'${1:string}'";
} | {
    readonly name: "$densify";
    readonly value: "$densify";
    readonly label: "$densify";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "5.1.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Creates new documents to eliminate the gaps in the time or numeric domain at the required granularity level.";
    readonly comment: "/**\n * field: The required field to densify.\n * partitionByFields: The set of fields that acts as a compound key to define each partition.\n * range: {\n *   step: The amount to increment the field value in each document.\n *   unit: If specified field must evaluate to a date for every document in the collection, otherwise must evaluate to a numeric.\n *   bounds: A string or array of numeric/date bounds, corresponding to the type of the field.\n * }\n */\n";
    readonly snippet: "{\n  field: ${1:string},\n  partitionByFields: [${2:string}, ${3:string}, ...],\n  range: {\n    step: ${4:number},\n    unit: ${5:string},\n    bounds: [${6:lowerbound}, ${7:upperbound}, ...]\n  }\n}";
} | {
    readonly name: "$documents";
    readonly value: "$documents";
    readonly label: "$documents";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: true;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.4.9";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db"];
    readonly description: "Returns literal documents from input values.";
    readonly comment: "/**\n * expression: Any valid expression.\n */\n";
    readonly snippet: "{\n  ${1:expression}\n}";
} | {
    readonly name: "$facet";
    readonly value: "$facet";
    readonly label: "$facet";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Allows for multiple parellel aggregations to be specified.";
    readonly comment: "/**\n * outputFieldN: The first output field.\n * stageN: The first aggregation stage.\n */\n";
    readonly snippet: "{\n  ${1:outputFieldN}: [ ${2:stageN}, ${3:...} ]\n}";
} | {
    readonly name: "$fill";
    readonly value: "$fill";
    readonly label: "$fill";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "5.3.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Populates null and missing field values within documents.";
    readonly comment: "/**\n * sortBy: Syntax is the same as $sort, required if \"method\" is used in at least one output spec otherwise optional\n * partitionBy: Optional, default is a single partition. Specification is the same as _id in $group (same as partitionBy in window functions).\n * partitionByFields: Optional, set of fields that acts as a compound key to define each partition.\n * output - Required, object for each field to fill in. For a single field, can be a single object.\n * output.<field> - A field to be filled with value, if missing or null in the current document.\n */\n";
    readonly snippet: "{\n  sortBy: ${1:sortSpec},\n  partitionBy: ${2:expression},\n  partitionByFields: [${3:string}, ${4:string}, ...],\n  output: {\n    field1: {value: ${5:expression}},\n    field2: {method: ${6:string}},\n    ...\n  }\n}";
} | {
    readonly name: "$geoNear";
    readonly value: "$geoNear";
    readonly label: "$geoNear";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Returns documents based on proximity to a geospatial point.";
    readonly comment: "/**\n * near: The point to search near.\n * distanceField: The calculated distance.\n * maxDistance: The maximum distance, in meters, documents can be before being excluded from results.\n * query: Limits results that match the query\n * includeLocs: Optional. Labels and includes the point used to match the document.\n * num: Optional. The maximum number of documents to return.\n * spherical: Defaults to false. Specifies whether to use spherical geometry.\n */\n";
    readonly snippet: "{\n  near: { type: 'Point', coordinates: [ ${1:number}, ${2:number} ] },\n  distanceField: '${3:string}',\n  maxDistance: ${4:number},\n  query: {${5}},\n  includeLocs: '${6}',\n  num: ${7:number},\n  spherical: ${8:boolean}\n}";
} | {
    readonly name: "$graphLookup";
    readonly value: "$graphLookup";
    readonly label: "$graphLookup";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Performs a recursive search on a collection.";
    readonly comment: "/**\n * from: The target collection.\n * startWith: Expression to start.\n * connectFromField: Field to connect.\n * connectToField: Field to connect to.\n * as: Name of the array field.\n * maxDepth: Optional max recursion depth.\n * depthField: Optional Name of the depth field.\n * restrictSearchWithMatch: Optional query.\n */\n";
    readonly snippet: "{\n  from: '${1:string}',\n  startWith: ${2:expression},\n  connectFromField: '${3:string}',\n  connectToField: '${4:string}',\n  as: '${5:string}',\n  maxDepth: ${6:number},\n  depthField: '${7:string}',\n  restrictSearchWithMatch: {${8}}\n}";
} | {
    readonly name: "$group";
    readonly value: "$group";
    readonly label: "$group";
    readonly outputStage: false;
    readonly fullScan: true;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Groups documents by a specified expression.";
    readonly comment: "/**\n * _id: The id of the group.\n * fieldN: The first field name.\n */\n";
    readonly snippet: "{\n  _id: ${1:expression},\n  ${2:fieldN}: {\n    ${3:accumulatorN}: ${4:expressionN}\n  }\n}";
} | {
    readonly name: "$indexStats";
    readonly value: "$indexStats";
    readonly label: "$indexStats";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: true;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.2.0";
    readonly apiVersions: readonly [];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Returns statistics regarding the use of each index for the collection.";
    readonly comment: "/**\n * No parameters.\n */\n";
    readonly snippet: "{}";
} | {
    readonly name: "$limit";
    readonly value: "$limit";
    readonly label: "$limit";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Limits the number of documents that flow into subsequent stages.";
    readonly comment: "/**\n * Provide the number of documents to limit.\n */\n";
    readonly snippet: "${1:number}";
} | {
    readonly name: "$lookup";
    readonly value: "$lookup";
    readonly label: "$lookup";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Performs a join between two collections.";
    readonly comment: "/**\n * from: The target collection.\n * localField: The local join field.\n * foreignField: The target join field.\n * as: The name for the results.\n * pipeline: Optional pipeline to run on the foreign collection.\n * let: Optional variables to use in the pipeline field stages.\n */\n";
    readonly snippet: "{\n  from: ${1:collection},\n  localField: ${2:field},\n  foreignField: ${3:field},\n  as: ${4:result}\n}";
} | {
    readonly name: "$match";
    readonly value: "$match";
    readonly label: "$match";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Filters the document stream to allow only matching documents to pass through to subsequent stages.";
    readonly comment: "/**\n * query: The query in MQL.\n */\n";
    readonly snippet: "{\n  ${1:query}\n}";
} | {
    readonly name: "$merge";
    readonly value: "$merge";
    readonly label: "$merge";
    readonly outputStage: true;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.1.11";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Merges the resulting documents into a collection, optionally overriding existing documents.";
    readonly comment: "/**\n * into: The target collection.\n * on: Fields to  identify.\n * let: Defined variables.\n * whenMatched: Action for matching docs.\n * whenNotMatched: Action for non-matching docs.\n */\n";
    readonly snippet: "{\n  into: '${1:string}',\n  on: '${2:string}',\n  let: '${3:specification(s)}',\n  whenMatched: '${4:string}',\n  whenNotMatched: '${5:string}'\n}";
} | {
    readonly name: "$merge";
    readonly value: "$merge";
    readonly label: "$merge";
    readonly outputStage: true;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["adl"];
    readonly meta: "stage";
    readonly version: "4.0.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Merges the resulting documents into a collection, optionally overriding existing documents.";
    readonly comment: "/**\n * atlas: Location to write the documents from the aggregation pipeline.\n * on: Fields to identify.\n * let: Defined variables.\n * whenMatched: Action for matching docs.\n * whenNotMatched: Action for non-matching docs.\n */\n";
    readonly snippet: "{\n  into: {\n    atlas: {\n      clusterName: '${1:atlasClusterName}',\n      db: '${2:database}',\n      coll: '${3:collection}',\n      projectId: '${4:optionalAtlasProjectId}'\n    }\n  },\n  on: '${5:identifier}',\n  let: { ${6:specification(s)} },\n  whenMatched: '${7:string}',\n  whenNotMatched: '${8:string}'\n}";
} | {
    readonly name: "$out";
    readonly value: "$out";
    readonly label: "$out";
    readonly outputStage: true;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Writes the result of a pipeline to a new or existing collection.";
    readonly comment: "/**\n * Provide the name of the output collection.\n */\n";
    readonly snippet: "'${1:string}'";
} | {
    readonly name: "$out";
    readonly value: "$out";
    readonly label: "$out";
    readonly outputStage: true;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["adl"];
    readonly meta: "stage";
    readonly version: "4.0.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Writes the result of a pipeline to an Atlas cluster or S3 bucket.";
    readonly comment: "/**\n * Use any one of the following:\n * s3: Parameters to save the data to S3.\n * atlas: Parameters to save the data to Atlas. Example:\n * {\n *   atlas: {\n *     db: 'string',\n *     coll: 'string',\n *     projectId: 'string',\n *     clusterName: 'string'\n *   }\n * }\n */\n";
    readonly snippet: "{\n  s3: {\n    bucket: '${1:string}',\n    region: '${2:string}',\n    filename: '${3:string}',\n    format: {\n      name: '${4:string}',\n      maxFileSize: '${5:bytes}',\n      maxRowGroupSize: '${6:string}',\n      columnCompression: '${7:string}'\n    },\n    errorMode: '${8:string}'\n  }\n}";
} | {
    readonly name: "$project";
    readonly value: "$project";
    readonly label: "$project";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Adds new field(s) to a document with a computed value, or reassigns an existing field(s) with a computed value. Unlike $addFields, $project can also remove fields.";
    readonly comment: "/**\n * specifications: The fields to\n *   include or exclude.\n */\n";
    readonly snippet: "{\n  ${1:specification(s)}\n}";
} | {
    readonly name: "$redact";
    readonly value: "$redact";
    readonly label: "$redact";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.6.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Restricts the content for each document based on information stored in the documents themselves";
    readonly comment: "/**\n * expression: Any valid expression that\n * evaluates to $$DESCEND, $$PRUNE, or $$KEEP.\n */\n";
    readonly snippet: "{\n  ${1:expression}\n}";
} | {
    readonly name: "$replaceWith";
    readonly value: "$replaceWith";
    readonly label: "$replaceWith";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Replaces a document with the specified embedded document.";
    readonly comment: "/**\n * replacementDocument: A document or string.\n */\n";
    readonly snippet: "{\n  newWith: ${1:replacementDocument}\n}";
} | {
    readonly name: "$replaceRoot";
    readonly value: "$replaceRoot";
    readonly label: "$replaceRoot";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Replaces a document with the specified embedded document.";
    readonly comment: "/**\n * replacementDocument: A document or string.\n */\n";
    readonly snippet: "{\n  newRoot: ${1:replacementDocument}\n}";
} | {
    readonly name: "$sample";
    readonly value: "$sample";
    readonly label: "$sample";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["coll", "view", "timeseries"];
    readonly description: "Randomly selects the specified number of documents from its input.";
    readonly comment: "/**\n * size: The number of documents to sample.\n */\n";
    readonly snippet: "{\n  size: ${1:number}\n}";
} | {
    readonly name: "$search";
    readonly value: "$search";
    readonly label: "$search";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas"];
    readonly meta: "stage";
    readonly version: "4.1.11";
    readonly apiVersions: readonly [];
    readonly namespaces: readonly ["coll"];
    readonly description: "Performs a full-text search on the specified field(s).";
    readonly comment: "/**\n * index: The name of the Search index.\n * text: Analyzed search, with required fields of query and path, the analyzed field(s) to search.\n * term: Un-analyzed search.\n * compound: Combines ops.\n * span: Find in text field regions.\n * exists: Test for presence of a field.\n * near: Find near number or date.\n * range: Find in numeric or date range.\n */\n";
    readonly snippet: "{\n  index: '${1:string}',\n  text: {\n    query: '${2:string}',\n    path: '${3:string}'\n  }\n}";
} | {
    readonly name: "$searchMeta";
    readonly value: "$searchMeta";
    readonly label: "$searchMeta";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas"];
    readonly meta: "stage";
    readonly version: "4.4.9";
    readonly apiVersions: readonly [];
    readonly namespaces: readonly ["coll"];
    readonly description: "Performs a full-text search on the specified field(s) and gets back only the generated search meta data from a query.";
    readonly comment: "/**\n * index: The name of the Search index.\n * count: The count of the results.\n * facet: {\n *   operator: Analyzed search, with required fields of query and path, can either be replaced with the name of a valid operator.\n *   facets: {\n *     stringFacet: Narrows search results based on unique string values, with required fields of type and path.\n *     numberFacet: Narrows search results by breaking them up into separate ranges of numbers, with required fields of type, path, and boundaries.\n *     dateFacet: Narrows search results by breaking them up into separate ranges of dates, with required fields of type, path, and boundaries.\n *   }\n * }\n */\n";
    readonly snippet: "{\n  index: ${1:string},\n  facet: {\n    operator: {\n      text: {\n        query: ${2:string},\n        path: ${3:string}\n      }\n    },\n    facets: {\n      ${4:stringFacet}: {\n        type: ${5:string},\n        path: ${6:string},\n        numBuckets: ${7:integer}\n      },\n      numberFacet: {\n        type: 'number',\n        path: ${8:string},\n        boundaries: [${9:lowerbound}, ${10:upperbound}, ...],\n        default: ${11:string}\n      }\n    }\n  }\n}";
} | {
    readonly name: "$set";
    readonly value: "$set";
    readonly label: "$set";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Adds new fields to documents. $set outputs documents that contain all existing fields from the input documents and newly added fields.";
    readonly comment: "/**\n * field: The field name\n * expression: The expression.\n */\n";
    readonly snippet: "{\n  ${1:field}: ${2:expression}\n}";
} | {
    readonly name: "$setWindowFields";
    readonly value: "$setWindowFields";
    readonly label: "$setWindowFields";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "5.0.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Capable of partitioning incoming data, and can apply one or more functions to defined windows within each partition.";
    readonly comment: "/**\n * partitionBy: partitioning of data.\n * sortBy: fields to sort by.\n * output: {\n *   path: {\n *     function: The window function to compute over the given window.\n *     window: {\n *       documents: A number of documents before and after the current document.\n *       range: A range of possible values around the value in the current document's sortBy field.\n *       unit: Specifies the units for the window bounds.\n *     }\n *   }\n * }\n */\n";
    readonly snippet: "{\n  partitionBy: ${1:expression},\n  sortBy: ${2:sortSpec},\n  output: {\n    ${3:path}: {\n      ${4:function}: ${5:functionArgs},\n      window: {\n        documents: [${6:lowerbound}, ${7:upperbound}],\n        range: [${8:lowerbound}, ${9:upperbound}],\n        unit: ${10:string}\n      }\n    },\n    ${11:path2}: ...\n  }\n}";
} | {
    readonly name: "$skip";
    readonly value: "$skip";
    readonly label: "$skip";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Skips a specified number of documents before advancing to the next stage.";
    readonly comment: "/**\n * Provide the number of documents to skip.\n */\n";
    readonly snippet: "${1:number}";
} | {
    readonly name: "$sort";
    readonly value: "$sort";
    readonly label: "$sort";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Reorders the document stream by a specified sort key and direction.";
    readonly comment: "/**\n * Provide any number of field/order pairs.\n */\n";
    readonly snippet: "{\n  ${1:field1}: ${2:sortOrder}\n}";
} | {
    readonly name: "$sortByCount";
    readonly value: "$sortByCount";
    readonly label: "$sortByCount";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Groups incoming documents based on the value of a specified expression, then computes the count of documents in each distinct group.";
    readonly comment: "/**\n * expression: Grouping expression or string.\n */\n";
    readonly snippet: "{\n  ${1:expression}\n}";
} | {
    readonly name: "$unionWith";
    readonly value: "$unionWith";
    readonly label: "$unionWith";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Perform a union with a pipeline on another collection.";
    readonly comment: "/**\n * coll: The collection name.\n * pipeline: The pipeline on the other collection.\n */\n";
    readonly snippet: "{\n  coll: '${1:coll}',\n  pipeline: [${2:pipeline}]\n}";
} | {
    readonly name: "$unset";
    readonly value: "$unset";
    readonly label: "$unset";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Excludes fields from the result document.";
    readonly comment: "/**\n * Provide the field name to exclude.\n * To exclude multiple fields, pass the field names in an array.\n */\n";
    readonly snippet: "'${1:string}'";
} | {
    readonly name: "$unwind";
    readonly value: "$unwind";
    readonly label: "$unwind";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Outputs a new document for each element in a specified array. ";
    readonly comment: "/**\n * path: Path to the array field.\n * includeArrayIndex: Optional name for index.\n * preserveNullAndEmptyArrays: Optional\n *   toggle to unwind null and empty values.\n */\n";
    readonly snippet: "{\n  path: ${1:path},\n  includeArrayIndex: '${2:string}',\n  preserveNullAndEmptyArrays: ${3:boolean}\n}";
} | {
    readonly name: "$changeStream";
    readonly value: "$changeStream";
    readonly label: "$changeStream";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: true;
    readonly score: 1;
    readonly env: readonly ["atlas", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db"];
    readonly description: "Returns a Change Stream cursor for the collection.";
    readonly comment: "/**\n * allChangesForCluster: Optional boolean to include all changes in the cluster.\n * fullDocument: Optional value to request a copy of full document when modified by update operations (Introduced in 6.0).\n * fullDocumentBeforeChange: Value to configure whether to return a full document before the change or not.\n * resumeAfter: Specifies a resume token as the logical starting point for the change stream. Cannot be used with startAfter or startAtOperationTime fields.\n * showExpandedEvents: Specifies whether to include additional change events, such as such as DDL and index operations (Introduced in 6.0).\n * startAfter: Specifies a resume token as the logical starting point for the change stream. Cannot be used with resumeAfter or startAtOperationTime fields.\n * startAtOperationTime: Specifies a time as the logical starting point for the change stream. Cannot be used with resumeAfter or startAfter fields.\n */\n";
    readonly snippet: "{\n  allChangesForCluster: ${1:boolean},\n  fullDocument: '${2:string}',\n  fullDocumentBeforeChange: '${3:string}',\n  resumeAfter: ${4:resumeToken},\n  showExpandedEvents: ${5:boolean},\n  startAfter: ${6:resumeToken},\n  startAtOperationTime: ${7:time},\n}";
} | {
    readonly name: "$currentOp";
    readonly value: "$currentOp";
    readonly label: "$currentOp";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: true;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.6.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db"];
    readonly description: "Returns a cursor over information on active and/or dormant operations for the MongoDB deployment as well as inactive sessions that are holding locks as part of a transaction.";
    readonly comment: "/**\n * allUsers: Optional boolean value to specify whether to return operations for all users or not.\n * idleConnections: Optional boolean value to specify whether to return all operations including idle connections or not.\n * idleCursors: Optional boolean value to specify whether to report on cursors that are idle or not.\n * idleSessions: Optional boolean value to specify whether to report on dormant sessions or not.\n * localOps: Optional boolean value to specify whether to report on operations running locally on targetted mongos or not.\n * backtrace: Optional boolean value to specify whether callstack information is returned as part of the waitingForLatch output field.\n */\n";
    readonly snippet: "{\n  allUsers: ${1:false},\n  idleConnections: ${2:false},\n  idleCursors: ${3:false},\n  idleSessions: ${4:true},\n  localOps: ${5:false},\n  backtrace: ${6:false},\n}";
} | {
    readonly name: "$listLocalSessions";
    readonly value: "$listLocalSessions";
    readonly label: "$listLocalSessions";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: true;
    readonly score: 1;
    readonly env: readonly ["atlas", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.6.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db"];
    readonly description: "Lists the sessions cached in memory by the mongod or mongos instance.";
    readonly comment: "/**\n * users: Optional list of users for which local sessions need to be returned.\n * allUsers: Optional boolean value to specify whether to return local sessions for all users or not.\n */\n";
    readonly snippet: "{\n  allUsers: ${1:false},\n  users: [\n    { user: '${2:string}', db: '${3:string}' }\n  ]\n}";
})[];
export declare const MATCH_COMPLETIONS: ({
    readonly name: "$accumulator";
    readonly value: "$accumulator";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "4.4.0";
} | {
    readonly name: "$addToSet";
    readonly value: "$addToSet";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
} | {
    readonly name: "$avg";
    readonly value: "$avg";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
    readonly projectVersion: "3.2.0";
} | {
    readonly name: "$bottom";
    readonly value: "$bottom";
    readonly score: 1;
    readonly meta: "accumulator:bottom-n";
    readonly version: "5.2.0";
} | {
    readonly name: "$bottomN";
    readonly value: "$bottomN";
    readonly score: 1;
    readonly meta: "accumulator:bottom-n";
    readonly version: "5.2.0";
} | {
    readonly name: "$covariancePop";
    readonly value: "$covariancePop";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$covarianceSamp";
    readonly value: "$covarianceSamp";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$count";
    readonly value: "$count";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "5.0.0";
} | {
    readonly name: "$derivative";
    readonly value: "$derivative";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$denseRank";
    readonly value: "$denseRank";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$documentNumber";
    readonly value: "$documentNumber";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$expMovingAvg";
    readonly value: "$expMovingAvg";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$first";
    readonly value: "$first";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
} | {
    readonly name: "$firstN";
    readonly value: "$firstN";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "5.1.0";
} | {
    readonly name: "$integral";
    readonly value: "$integral";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$last";
    readonly value: "$last";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
} | {
    readonly name: "$lastN";
    readonly value: "$lastN";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "5.2.0";
} | {
    readonly name: "$max";
    readonly value: "$max";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
    readonly projectVersion: "3.2.0";
} | {
    readonly name: "$maxN";
    readonly value: "$maxN";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "5.2.0";
} | {
    readonly name: "$min";
    readonly value: "$min";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
    readonly projectVersion: "3.2.0";
} | {
    readonly name: "$minN";
    readonly value: "$minN";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "5.2.0";
} | {
    readonly name: "$push";
    readonly value: "$push";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
} | {
    readonly name: "$rank";
    readonly value: "$rank";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$stdDevPop";
    readonly value: "$stdDevPop";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "3.2.0";
    readonly projectVersion: "3.2.0";
} | {
    readonly name: "$stdDevSamp";
    readonly value: "$stdDevSamp";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "3.2.0";
    readonly projectVersion: "3.2.0";
} | {
    readonly name: "$shift";
    readonly value: "$shift";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.0.0";
} | {
    readonly name: "$sum";
    readonly value: "$sum";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "2.2.0";
    readonly projectVersion: "3.2.0";
} | {
    readonly name: "$top";
    readonly value: "$top";
    readonly score: 1;
    readonly meta: "accumulator:top-n";
    readonly version: "5.2.0";
} | {
    readonly name: "$topN";
    readonly value: "$topN";
    readonly score: 1;
    readonly meta: "accumulator:top-n";
    readonly version: "5.2.0";
} | {
    readonly name: "$locf";
    readonly value: "$locf";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.3.0";
} | {
    readonly name: "$linearFill";
    readonly value: "$linearFill";
    readonly score: 1;
    readonly meta: "accumulator:window";
    readonly version: "5.3.0";
} | {
    readonly name: "Code";
    readonly value: "Code";
    readonly label: "Code";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON Code type";
    readonly snippet: "Code('${1:code}')";
} | {
    readonly name: "ObjectId";
    readonly value: "ObjectId";
    readonly label: "ObjectId";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON ObjectId type";
    readonly snippet: "ObjectId('${1:id}')";
} | {
    readonly name: "Binary";
    readonly value: "Binary";
    readonly label: "Binary";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON Binary type";
    readonly snippet: "Binary('${1:data}', '${2:subType}')";
} | {
    readonly name: "DBRef";
    readonly value: "DBRef";
    readonly label: "DBRef";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON DBRef type";
    readonly snippet: "DBRef('${1:ns}', '${2:oid}')";
} | {
    readonly name: "Timestamp";
    readonly value: "Timestamp";
    readonly label: "Timestamp";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON Timestamp type";
    readonly snippet: "Timestamp(${1:low}, ${2:high})";
} | {
    readonly name: "NumberInt";
    readonly value: "NumberInt";
    readonly label: "NumberInt";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON 32 bit Integer type";
    readonly snippet: "NumberInt(${1:value})";
} | {
    readonly name: "NumberLong";
    readonly value: "NumberLong";
    readonly label: "NumberLong";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON 64 but Integer type";
    readonly snippet: "NumberLong(${1:value})";
} | {
    readonly name: "NumberDecimal";
    readonly value: "NumberDecimal";
    readonly label: "NumberDecimal";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "3.4.0";
    readonly description: "BSON Decimal128 type";
    readonly snippet: "NumberDecimal('${1:value}')";
} | {
    readonly name: "MaxKey";
    readonly value: "MaxKey";
    readonly label: "MaxKey";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON MaxKey type";
    readonly snippet: "MaxKey()";
} | {
    readonly name: "MinKey";
    readonly value: "MinKey";
    readonly label: "MinKey";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON MinKey type";
    readonly snippet: "MinKey()";
} | {
    readonly name: "ISODate";
    readonly value: "ISODate";
    readonly label: "ISODate";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON Date type";
    readonly snippet: "ISODate('${1:date}')";
} | {
    readonly name: "RegExp";
    readonly value: "RegExp";
    readonly label: "RegExp";
    readonly score: 1;
    readonly meta: "bson";
    readonly version: "0.0.0";
    readonly description: "BSON Regex type";
    readonly snippet: "RegExp('${1:source}', '${2:opts}')";
} | {
    readonly name: "$convert";
    readonly value: "$convert";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$ltrim";
    readonly value: "$ltrim";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "3.7.2";
} | {
    readonly name: "$rtrim";
    readonly value: "$rtrim";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "3.7.2";
} | {
    readonly name: "$toBool";
    readonly value: "$toBool";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toDate";
    readonly value: "$toDate";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toDecimal";
    readonly value: "$toDecimal";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toDouble";
    readonly value: "$toDouble";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toInt";
    readonly value: "$toInt";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toLong";
    readonly value: "$toLong";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toObjectId";
    readonly value: "$toObjectId";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$toString";
    readonly value: "$toString";
    readonly score: 1;
    readonly meta: "conv";
    readonly version: "3.7.2";
} | {
    readonly name: "$trim";
    readonly value: "$trim";
    readonly score: 1;
    readonly meta: "accumulator";
    readonly version: "3.7.2";
} | {
    readonly name: "$abs";
    readonly value: "$abs";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$accumulator";
    readonly value: "$accumulator";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "4.4.0";
} | {
    readonly name: "$add";
    readonly value: "$add";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "2.2.0";
} | {
    readonly name: "$allElementsTrue";
    readonly value: "$allElementsTrue";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$and";
    readonly value: "$and";
    readonly score: 1;
    readonly meta: "expr:bool";
    readonly version: "2.2.0";
} | {
    readonly name: "$anyElementTrue";
    readonly value: "$anyElementTrue";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$arrayElemAt";
    readonly value: "$arrayElemAt";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.2.0";
} | {
    readonly name: "$arrayToObject";
    readonly value: "$arrayToObject";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.4";
} | {
    readonly name: "$binarySize";
    readonly value: "$binarySize";
    readonly score: 1;
    readonly meta: "expr:obj";
    readonly version: "4.4.0";
} | {
    readonly name: "$bsonSize";
    readonly value: "$bsonSize";
    readonly score: 1;
    readonly meta: "expr:obj";
    readonly version: "4.4.0";
} | {
    readonly name: "$ceil";
    readonly value: "$ceil";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$cmp";
    readonly value: "$cmp";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$concat";
    readonly value: "$concat";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "2.4.0";
} | {
    readonly name: "$concatArrays";
    readonly value: "$concatArrays";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.2.0";
} | {
    readonly name: "$cond";
    readonly value: "$cond";
    readonly score: 1;
    readonly meta: "expr:cond";
    readonly version: "2.6.0";
} | {
    readonly name: "$dateAdd";
    readonly value: "$dateAdd";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "5.0.0";
} | {
    readonly name: "$dateDiff";
    readonly value: "$dateDiff";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "5.0.0";
} | {
    readonly name: "$dateFromParts";
    readonly value: "$dateFromParts";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.6.0";
} | {
    readonly name: "$dateFromString";
    readonly value: "$dateFromString";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.6.0";
} | {
    readonly name: "$dateSubtract";
    readonly value: "$dateSubtract";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "5.0.0";
} | {
    readonly name: "$dateToParts";
    readonly value: "$dateToParts";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.6.0";
} | {
    readonly name: "$dateToString";
    readonly value: "$dateToString";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.6.0";
} | {
    readonly name: "$dateTrunc";
    readonly value: "$dateTrunc";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "5.0.0";
} | {
    readonly name: "$dayOfMonth";
    readonly value: "$dayOfMonth";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$dayOfWeek";
    readonly value: "$dayOfWeek";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$dayOfYear";
    readonly value: "$dayOfYear";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$dateToString";
    readonly value: "$dateToString";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.0.0";
} | {
    readonly name: "$divide";
    readonly value: "$divide";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "2.2.0";
} | {
    readonly name: "$eq";
    readonly value: "$eq";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$exp";
    readonly value: "$exp";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$filter";
    readonly value: "$filter";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.2.0";
} | {
    readonly name: "$first";
    readonly value: "$first";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "4.4.0";
} | {
    readonly name: "$floor";
    readonly value: "$floor";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$function";
    readonly value: "$function";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "4.4.0";
} | {
    readonly name: "$getField";
    readonly value: "$getField";
    readonly score: 1;
    readonly meta: "expr:get";
    readonly version: "5.0.0";
} | {
    readonly name: "$gt";
    readonly value: "$gt";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$gte";
    readonly value: "$gte";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$hour";
    readonly value: "$hour";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$ifNull";
    readonly value: "$ifNull";
    readonly score: 1;
    readonly meta: "expr:cond";
    readonly version: "2.2.0";
} | {
    readonly name: "$in";
    readonly value: "$in";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.0";
} | {
    readonly name: "$indexOfArray";
    readonly value: "$indexOfArray";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.0";
} | {
    readonly name: "$indexOfBytes";
    readonly value: "$indexOfBytes";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$indexOfCP";
    readonly value: "$indexOfCP";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$isArray";
    readonly value: "$isArray";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.2.0";
} | {
    readonly name: "$isNumber";
    readonly value: "$isNumber";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "4.4.0";
} | {
    readonly name: "$isoDayOfWeek";
    readonly value: "$isoDayOfWeek";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.4.0";
} | {
    readonly name: "$isoWeek";
    readonly value: "$isoWeek";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.4.0";
} | {
    readonly name: "$isoWeekYear";
    readonly value: "$isoWeekYear";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "3.4.0";
} | {
    readonly name: "$last";
    readonly value: "$last";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "4.4.0";
} | {
    readonly name: "$let";
    readonly value: "$let";
    readonly score: 1;
    readonly meta: "expr:var";
    readonly version: "2.6.0";
} | {
    readonly name: "$literal";
    readonly value: "$literal";
    readonly score: 1;
    readonly meta: "expr:literal";
    readonly version: "2.6.0";
} | {
    readonly name: "$lt";
    readonly value: "$lt";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$lt";
    readonly value: "$lte";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$ln";
    readonly value: "$ln";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$log";
    readonly value: "$log";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$log10";
    readonly value: "$log10";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$map";
    readonly value: "$map";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "2.6.0";
} | {
    readonly name: "$mergeObjects";
    readonly value: "$mergeObjects";
    readonly score: 1;
    readonly meta: "expr:obj";
    readonly version: "3.6.0";
} | {
    readonly name: "$meta";
    readonly value: "$meta";
    readonly score: 1;
    readonly meta: "expr:text";
    readonly version: "2.6.0";
} | {
    readonly name: "$millisecond";
    readonly value: "$millisecond";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.4.0";
} | {
    readonly name: "$minute";
    readonly value: "$minute";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$mod";
    readonly value: "$mod";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "2.2.0";
} | {
    readonly name: "$month";
    readonly value: "$month";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$multiply";
    readonly value: "$multiply";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "2.2.0";
} | {
    readonly name: "$new";
    readonly value: "$new";
    readonly score: 1;
    readonly meta: "expr:comp";
    readonly version: "2.2.0";
} | {
    readonly name: "$not";
    readonly value: "$not";
    readonly score: 1;
    readonly meta: "expr:bool";
    readonly version: "2.2.0";
} | {
    readonly name: "$objectToArray";
    readonly value: "$objectToArray";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.4";
} | {
    readonly name: "$or";
    readonly value: "$or";
    readonly score: 1;
    readonly meta: "expr:bool";
    readonly version: "2.2.0";
} | {
    readonly name: "$pow";
    readonly value: "$pow";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$range";
    readonly value: "$range";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.0";
} | {
    readonly name: "$reduce";
    readonly value: "$reduce";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.0";
} | {
    readonly name: "$regexFind";
    readonly value: "$regexFind";
    readonly score: 1;
    readonly meta: "expr:regex";
    readonly version: "4.1.11";
} | {
    readonly name: "$regexFindAll";
    readonly value: "$regexFindAll";
    readonly score: 1;
    readonly meta: "expr:regex";
    readonly version: "4.1.11";
} | {
    readonly name: "$regexMatch";
    readonly value: "$regexMatch";
    readonly score: 1;
    readonly meta: "expr:regex";
    readonly version: "4.1.11";
} | {
    readonly name: "$replaceAll";
    readonly value: "$replaceAll";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "4.4.0";
} | {
    readonly name: "$replaceOne";
    readonly value: "$replaceOne";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "4.4.0";
} | {
    readonly name: "$reverseArray";
    readonly value: "$reverseArray";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.0";
} | {
    readonly name: "$second";
    readonly value: "$second";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$setDifference";
    readonly value: "$setDifference";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$setEquals";
    readonly value: "$setEquals";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$setIntersection";
    readonly value: "$setIntersection";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$setIsSubset";
    readonly value: "$setIsSubset";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$setUnion";
    readonly value: "$setUnion";
    readonly score: 1;
    readonly meta: "expr:set";
    readonly version: "2.6.0";
} | {
    readonly name: "$size";
    readonly value: "$size";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "2.6.0";
} | {
    readonly name: "$slice";
    readonly value: "$slice";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.2.0";
} | {
    readonly name: "$sortArray";
    readonly value: "$sortArray";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "5.2.0";
} | {
    readonly name: "$split";
    readonly value: "$split";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$sqrt";
    readonly value: "$sqrt";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$strcasecmp";
    readonly value: "$strcasecmp";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "2.2.0";
} | {
    readonly name: "$strLenBytes";
    readonly value: "$strLenBytes";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$strLenCP";
    readonly value: "$strLenCP";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$substr";
    readonly value: "$substr";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "2.2.0";
    readonly deprecated: "3.4.0";
    readonly replacement: "$substrBytes";
} | {
    readonly name: "$substrBytes";
    readonly value: "$substrBytes";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$substrCP";
    readonly value: "$substrCP";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "3.4.0";
} | {
    readonly name: "$subtract";
    readonly value: "$subtract";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$switch";
    readonly value: "$switch";
    readonly score: 1;
    readonly meta: "expr:cond";
    readonly version: "3.4.0";
} | {
    readonly name: "$toLower";
    readonly value: "$toLower";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "2.2.0";
} | {
    readonly name: "$toUpper";
    readonly value: "$toUpper";
    readonly score: 1;
    readonly meta: "expr:string";
    readonly version: "2.2.0";
} | {
    readonly name: "$tsSecond";
    readonly value: "$tsSecond";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "5.1.0";
} | {
    readonly name: "$tsIncrement";
    readonly value: "$tsIncrement";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "5.1.0";
} | {
    readonly name: "$trunc";
    readonly value: "$trunc";
    readonly score: 1;
    readonly meta: "expr:arith";
    readonly version: "3.2.0";
} | {
    readonly name: "$type";
    readonly value: "$type";
    readonly score: 1;
    readonly meta: "expr:type";
    readonly version: "3.4.0";
} | {
    readonly name: "$week";
    readonly value: "$week";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$year";
    readonly value: "$year";
    readonly score: 1;
    readonly meta: "expr:date";
    readonly version: "2.2.0";
} | {
    readonly name: "$zip";
    readonly value: "$zip";
    readonly score: 1;
    readonly meta: "expr:array";
    readonly version: "3.4.0";
} | {
    readonly name: "$bitAnd";
    readonly value: "$bitAnd";
    readonly score: 1;
    readonly meta: "expr:bit";
    readonly version: "7.0.0";
} | {
    readonly name: "$bitOr";
    readonly value: "$bitOr";
    readonly score: 1;
    readonly meta: "expr:bit";
    readonly version: "7.0.0";
} | {
    readonly name: "$bitXor";
    readonly value: "$bitXor";
    readonly score: 1;
    readonly meta: "expr:bit";
    readonly version: "7.0.0";
} | {
    readonly name: "$bitNot";
    readonly value: "$bitNot";
    readonly score: 1;
    readonly meta: "expr:bit";
    readonly version: "7.0.0";
} | {
    readonly name: "$all";
    readonly value: "$all";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$and";
    readonly value: "$and";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$bitsAllClear";
    readonly value: "$bitsAllClear";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$bitsAllSet";
    readonly value: "$bitsAllSet";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$bitsAnyClear";
    readonly value: "$bitsAnyClear";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$bitsAnySet";
    readonly value: "$bitsAnySet";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$comment";
    readonly value: "$comment";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$elemMatch";
    readonly value: "$elemMatch";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$eq";
    readonly value: "$eq";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$exists";
    readonly value: "$exists";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$expr";
    readonly value: "$expr";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.6.0";
    readonly geospatial: false;
} | {
    readonly name: "$geoIntersects";
    readonly value: "$geoIntersects";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: true;
} | {
    readonly name: "$geoWithin";
    readonly value: "$geoWithin";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: true;
} | {
    readonly name: "$gt";
    readonly value: "$gt";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$gte";
    readonly value: "$gte";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$in";
    readonly value: "$in";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$jsonSchema";
    readonly value: "$jsonSchema";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "3.6.0";
    readonly geospatial: false;
} | {
    readonly name: "$lt";
    readonly value: "$lt";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$lte";
    readonly value: "$lte";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$mod";
    readonly value: "$mod";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$ne";
    readonly value: "$ne";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$near";
    readonly value: "$near";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: true;
} | {
    readonly name: "$nearSphere";
    readonly value: "$nearSphere";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: true;
} | {
    readonly name: "$nin";
    readonly value: "$nin";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$not";
    readonly value: "$not";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$nor";
    readonly value: "$nor";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$or";
    readonly value: "$or";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$regex";
    readonly value: "$regex";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$size";
    readonly value: "$size";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$slice";
    readonly value: "$slice";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$text";
    readonly value: "$text";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$type";
    readonly value: "$type";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$where";
    readonly value: "$where";
    readonly score: 1;
    readonly meta: "query";
    readonly version: "2.2.0";
    readonly geospatial: false;
} | {
    readonly name: "$addFields";
    readonly value: "$addFields";
    readonly label: "$addFields";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Adds new field(s) to a document with a computed value, or reassigns an existing field(s) with a computed value.";
    readonly comment: "/**\n * newField: The new field name.\n * expression: The new field expression.\n */\n";
    readonly snippet: "{\n  ${1:newField}: ${2:expression}, ${3:...}\n}";
} | {
    readonly name: "$bucket";
    readonly value: "$bucket";
    readonly label: "$bucket";
    readonly outputStage: false;
    readonly fullScan: true;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Categorizes incoming documents into groups, called buckets, based on specified boundaries.";
    readonly comment: "/**\n * groupBy: The expression to group by.\n * boundaries: An array of the lower boundaries for each bucket.\n * default: The bucket name for documents that do not fall within the specified boundaries\n * output: {\n *   outputN: Optional. The output object may contain a single or numerous field names used to accumulate values per bucket.\n * }\n */\n";
    readonly snippet: "{\n  groupBy: ${1:expression},\n  boundaries: [ ${2:lowerbound}, ${3:...} ],\n  default: ${4:literal},\n  output: {\n    ${5:outputN}: { ${6:accumulator} }, ${7:...}\n  }\n}";
} | {
    readonly name: "$bucketAuto";
    readonly value: "$bucketAuto";
    readonly label: "$bucketAuto";
    readonly outputStage: false;
    readonly fullScan: true;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Automatically categorizes documents into a specified number of buckets, attempting even distribution if possible.";
    readonly comment: "/**\n * groupBy: The expression to group by.\n * buckets: The desired number of buckets\n * output: {\n *   outputN: Optional. The output object may contain a single or numerous field names used to accumulate values per bucket.\n * }\n * granularity: Optional number series\n */\n";
    readonly snippet: "{\n  groupBy: ${1:expression},\n  buckets: ${2:number},\n  output: {\n    ${3:outputN}: ${4:accumulator}, ${5:...}\n  },\n  granularity: '${6:string}'\n}";
} | {
    readonly name: "$collStats";
    readonly value: "$collStats";
    readonly label: "$collStats";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: true;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [];
    readonly namespaces: readonly ["coll", "view", "timeseries"];
    readonly description: "Returns statistics regarding a collection or view.";
    readonly comment: "/**\n * histograms: Optional latency histograms.\n * storageStats: Optional storage stats.\n */\n";
    readonly snippet: "{\n  latencyStats: {\n    histograms: ${1:boolean}\n  },\n  storageStats: {${2:}},\n}";
} | {
    readonly name: "$count";
    readonly value: "$count";
    readonly label: "$count";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Returns a count of the number of documents at this stage of the aggregation pipeline.";
    readonly comment: "/**\n * Provide the field name for the count.\n */\n";
    readonly snippet: "'${1:string}'";
} | {
    readonly name: "$densify";
    readonly value: "$densify";
    readonly label: "$densify";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "5.1.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Creates new documents to eliminate the gaps in the time or numeric domain at the required granularity level.";
    readonly comment: "/**\n * field: The required field to densify.\n * partitionByFields: The set of fields that acts as a compound key to define each partition.\n * range: {\n *   step: The amount to increment the field value in each document.\n *   unit: If specified field must evaluate to a date for every document in the collection, otherwise must evaluate to a numeric.\n *   bounds: A string or array of numeric/date bounds, corresponding to the type of the field.\n * }\n */\n";
    readonly snippet: "{\n  field: ${1:string},\n  partitionByFields: [${2:string}, ${3:string}, ...],\n  range: {\n    step: ${4:number},\n    unit: ${5:string},\n    bounds: [${6:lowerbound}, ${7:upperbound}, ...]\n  }\n}";
} | {
    readonly name: "$documents";
    readonly value: "$documents";
    readonly label: "$documents";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: true;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.4.9";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db"];
    readonly description: "Returns literal documents from input values.";
    readonly comment: "/**\n * expression: Any valid expression.\n */\n";
    readonly snippet: "{\n  ${1:expression}\n}";
} | {
    readonly name: "$facet";
    readonly value: "$facet";
    readonly label: "$facet";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Allows for multiple parellel aggregations to be specified.";
    readonly comment: "/**\n * outputFieldN: The first output field.\n * stageN: The first aggregation stage.\n */\n";
    readonly snippet: "{\n  ${1:outputFieldN}: [ ${2:stageN}, ${3:...} ]\n}";
} | {
    readonly name: "$fill";
    readonly value: "$fill";
    readonly label: "$fill";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "5.3.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Populates null and missing field values within documents.";
    readonly comment: "/**\n * sortBy: Syntax is the same as $sort, required if \"method\" is used in at least one output spec otherwise optional\n * partitionBy: Optional, default is a single partition. Specification is the same as _id in $group (same as partitionBy in window functions).\n * partitionByFields: Optional, set of fields that acts as a compound key to define each partition.\n * output - Required, object for each field to fill in. For a single field, can be a single object.\n * output.<field> - A field to be filled with value, if missing or null in the current document.\n */\n";
    readonly snippet: "{\n  sortBy: ${1:sortSpec},\n  partitionBy: ${2:expression},\n  partitionByFields: [${3:string}, ${4:string}, ...],\n  output: {\n    field1: {value: ${5:expression}},\n    field2: {method: ${6:string}},\n    ...\n  }\n}";
} | {
    readonly name: "$geoNear";
    readonly value: "$geoNear";
    readonly label: "$geoNear";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Returns documents based on proximity to a geospatial point.";
    readonly comment: "/**\n * near: The point to search near.\n * distanceField: The calculated distance.\n * maxDistance: The maximum distance, in meters, documents can be before being excluded from results.\n * query: Limits results that match the query\n * includeLocs: Optional. Labels and includes the point used to match the document.\n * num: Optional. The maximum number of documents to return.\n * spherical: Defaults to false. Specifies whether to use spherical geometry.\n */\n";
    readonly snippet: "{\n  near: { type: 'Point', coordinates: [ ${1:number}, ${2:number} ] },\n  distanceField: '${3:string}',\n  maxDistance: ${4:number},\n  query: {${5}},\n  includeLocs: '${6}',\n  num: ${7:number},\n  spherical: ${8:boolean}\n}";
} | {
    readonly name: "$graphLookup";
    readonly value: "$graphLookup";
    readonly label: "$graphLookup";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Performs a recursive search on a collection.";
    readonly comment: "/**\n * from: The target collection.\n * startWith: Expression to start.\n * connectFromField: Field to connect.\n * connectToField: Field to connect to.\n * as: Name of the array field.\n * maxDepth: Optional max recursion depth.\n * depthField: Optional Name of the depth field.\n * restrictSearchWithMatch: Optional query.\n */\n";
    readonly snippet: "{\n  from: '${1:string}',\n  startWith: ${2:expression},\n  connectFromField: '${3:string}',\n  connectToField: '${4:string}',\n  as: '${5:string}',\n  maxDepth: ${6:number},\n  depthField: '${7:string}',\n  restrictSearchWithMatch: {${8}}\n}";
} | {
    readonly name: "$group";
    readonly value: "$group";
    readonly label: "$group";
    readonly outputStage: false;
    readonly fullScan: true;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Groups documents by a specified expression.";
    readonly comment: "/**\n * _id: The id of the group.\n * fieldN: The first field name.\n */\n";
    readonly snippet: "{\n  _id: ${1:expression},\n  ${2:fieldN}: {\n    ${3:accumulatorN}: ${4:expressionN}\n  }\n}";
} | {
    readonly name: "$indexStats";
    readonly value: "$indexStats";
    readonly label: "$indexStats";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: true;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.2.0";
    readonly apiVersions: readonly [];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Returns statistics regarding the use of each index for the collection.";
    readonly comment: "/**\n * No parameters.\n */\n";
    readonly snippet: "{}";
} | {
    readonly name: "$limit";
    readonly value: "$limit";
    readonly label: "$limit";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Limits the number of documents that flow into subsequent stages.";
    readonly comment: "/**\n * Provide the number of documents to limit.\n */\n";
    readonly snippet: "${1:number}";
} | {
    readonly name: "$lookup";
    readonly value: "$lookup";
    readonly label: "$lookup";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Performs a join between two collections.";
    readonly comment: "/**\n * from: The target collection.\n * localField: The local join field.\n * foreignField: The target join field.\n * as: The name for the results.\n * pipeline: Optional pipeline to run on the foreign collection.\n * let: Optional variables to use in the pipeline field stages.\n */\n";
    readonly snippet: "{\n  from: ${1:collection},\n  localField: ${2:field},\n  foreignField: ${3:field},\n  as: ${4:result}\n}";
} | {
    readonly name: "$match";
    readonly value: "$match";
    readonly label: "$match";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Filters the document stream to allow only matching documents to pass through to subsequent stages.";
    readonly comment: "/**\n * query: The query in MQL.\n */\n";
    readonly snippet: "{\n  ${1:query}\n}";
} | {
    readonly name: "$merge";
    readonly value: "$merge";
    readonly label: "$merge";
    readonly outputStage: true;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.1.11";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Merges the resulting documents into a collection, optionally overriding existing documents.";
    readonly comment: "/**\n * into: The target collection.\n * on: Fields to  identify.\n * let: Defined variables.\n * whenMatched: Action for matching docs.\n * whenNotMatched: Action for non-matching docs.\n */\n";
    readonly snippet: "{\n  into: '${1:string}',\n  on: '${2:string}',\n  let: '${3:specification(s)}',\n  whenMatched: '${4:string}',\n  whenNotMatched: '${5:string}'\n}";
} | {
    readonly name: "$merge";
    readonly value: "$merge";
    readonly label: "$merge";
    readonly outputStage: true;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["adl"];
    readonly meta: "stage";
    readonly version: "4.0.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Merges the resulting documents into a collection, optionally overriding existing documents.";
    readonly comment: "/**\n * atlas: Location to write the documents from the aggregation pipeline.\n * on: Fields to identify.\n * let: Defined variables.\n * whenMatched: Action for matching docs.\n * whenNotMatched: Action for non-matching docs.\n */\n";
    readonly snippet: "{\n  into: {\n    atlas: {\n      clusterName: '${1:atlasClusterName}',\n      db: '${2:database}',\n      coll: '${3:collection}',\n      projectId: '${4:optionalAtlasProjectId}'\n    }\n  },\n  on: '${5:identifier}',\n  let: { ${6:specification(s)} },\n  whenMatched: '${7:string}',\n  whenNotMatched: '${8:string}'\n}";
} | {
    readonly name: "$out";
    readonly value: "$out";
    readonly label: "$out";
    readonly outputStage: true;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Writes the result of a pipeline to a new or existing collection.";
    readonly comment: "/**\n * Provide the name of the output collection.\n */\n";
    readonly snippet: "'${1:string}'";
} | {
    readonly name: "$out";
    readonly value: "$out";
    readonly label: "$out";
    readonly outputStage: true;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["adl"];
    readonly meta: "stage";
    readonly version: "4.0.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Writes the result of a pipeline to an Atlas cluster or S3 bucket.";
    readonly comment: "/**\n * Use any one of the following:\n * s3: Parameters to save the data to S3.\n * atlas: Parameters to save the data to Atlas. Example:\n * {\n *   atlas: {\n *     db: 'string',\n *     coll: 'string',\n *     projectId: 'string',\n *     clusterName: 'string'\n *   }\n * }\n */\n";
    readonly snippet: "{\n  s3: {\n    bucket: '${1:string}',\n    region: '${2:string}',\n    filename: '${3:string}',\n    format: {\n      name: '${4:string}',\n      maxFileSize: '${5:bytes}',\n      maxRowGroupSize: '${6:string}',\n      columnCompression: '${7:string}'\n    },\n    errorMode: '${8:string}'\n  }\n}";
} | {
    readonly name: "$project";
    readonly value: "$project";
    readonly label: "$project";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Adds new field(s) to a document with a computed value, or reassigns an existing field(s) with a computed value. Unlike $addFields, $project can also remove fields.";
    readonly comment: "/**\n * specifications: The fields to\n *   include or exclude.\n */\n";
    readonly snippet: "{\n  ${1:specification(s)}\n}";
} | {
    readonly name: "$redact";
    readonly value: "$redact";
    readonly label: "$redact";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.6.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Restricts the content for each document based on information stored in the documents themselves";
    readonly comment: "/**\n * expression: Any valid expression that\n * evaluates to $$DESCEND, $$PRUNE, or $$KEEP.\n */\n";
    readonly snippet: "{\n  ${1:expression}\n}";
} | {
    readonly name: "$replaceWith";
    readonly value: "$replaceWith";
    readonly label: "$replaceWith";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Replaces a document with the specified embedded document.";
    readonly comment: "/**\n * replacementDocument: A document or string.\n */\n";
    readonly snippet: "{\n  newWith: ${1:replacementDocument}\n}";
} | {
    readonly name: "$replaceRoot";
    readonly value: "$replaceRoot";
    readonly label: "$replaceRoot";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Replaces a document with the specified embedded document.";
    readonly comment: "/**\n * replacementDocument: A document or string.\n */\n";
    readonly snippet: "{\n  newRoot: ${1:replacementDocument}\n}";
} | {
    readonly name: "$sample";
    readonly value: "$sample";
    readonly label: "$sample";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["coll", "view", "timeseries"];
    readonly description: "Randomly selects the specified number of documents from its input.";
    readonly comment: "/**\n * size: The number of documents to sample.\n */\n";
    readonly snippet: "{\n  size: ${1:number}\n}";
} | {
    readonly name: "$search";
    readonly value: "$search";
    readonly label: "$search";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas"];
    readonly meta: "stage";
    readonly version: "4.1.11";
    readonly apiVersions: readonly [];
    readonly namespaces: readonly ["coll"];
    readonly description: "Performs a full-text search on the specified field(s).";
    readonly comment: "/**\n * index: The name of the Search index.\n * text: Analyzed search, with required fields of query and path, the analyzed field(s) to search.\n * term: Un-analyzed search.\n * compound: Combines ops.\n * span: Find in text field regions.\n * exists: Test for presence of a field.\n * near: Find near number or date.\n * range: Find in numeric or date range.\n */\n";
    readonly snippet: "{\n  index: '${1:string}',\n  text: {\n    query: '${2:string}',\n    path: '${3:string}'\n  }\n}";
} | {
    readonly name: "$searchMeta";
    readonly value: "$searchMeta";
    readonly label: "$searchMeta";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas"];
    readonly meta: "stage";
    readonly version: "4.4.9";
    readonly apiVersions: readonly [];
    readonly namespaces: readonly ["coll"];
    readonly description: "Performs a full-text search on the specified field(s) and gets back only the generated search meta data from a query.";
    readonly comment: "/**\n * index: The name of the Search index.\n * count: The count of the results.\n * facet: {\n *   operator: Analyzed search, with required fields of query and path, can either be replaced with the name of a valid operator.\n *   facets: {\n *     stringFacet: Narrows search results based on unique string values, with required fields of type and path.\n *     numberFacet: Narrows search results by breaking them up into separate ranges of numbers, with required fields of type, path, and boundaries.\n *     dateFacet: Narrows search results by breaking them up into separate ranges of dates, with required fields of type, path, and boundaries.\n *   }\n * }\n */\n";
    readonly snippet: "{\n  index: ${1:string},\n  facet: {\n    operator: {\n      text: {\n        query: ${2:string},\n        path: ${3:string}\n      }\n    },\n    facets: {\n      ${4:stringFacet}: {\n        type: ${5:string},\n        path: ${6:string},\n        numBuckets: ${7:integer}\n      },\n      numberFacet: {\n        type: 'number',\n        path: ${8:string},\n        boundaries: [${9:lowerbound}, ${10:upperbound}, ...],\n        default: ${11:string}\n      }\n    }\n  }\n}";
} | {
    readonly name: "$set";
    readonly value: "$set";
    readonly label: "$set";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Adds new fields to documents. $set outputs documents that contain all existing fields from the input documents and newly added fields.";
    readonly comment: "/**\n * field: The field name\n * expression: The expression.\n */\n";
    readonly snippet: "{\n  ${1:field}: ${2:expression}\n}";
} | {
    readonly name: "$setWindowFields";
    readonly value: "$setWindowFields";
    readonly label: "$setWindowFields";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "5.0.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Capable of partitioning incoming data, and can apply one or more functions to defined windows within each partition.";
    readonly comment: "/**\n * partitionBy: partitioning of data.\n * sortBy: fields to sort by.\n * output: {\n *   path: {\n *     function: The window function to compute over the given window.\n *     window: {\n *       documents: A number of documents before and after the current document.\n *       range: A range of possible values around the value in the current document's sortBy field.\n *       unit: Specifies the units for the window bounds.\n *     }\n *   }\n * }\n */\n";
    readonly snippet: "{\n  partitionBy: ${1:expression},\n  sortBy: ${2:sortSpec},\n  output: {\n    ${3:path}: {\n      ${4:function}: ${5:functionArgs},\n      window: {\n        documents: [${6:lowerbound}, ${7:upperbound}],\n        range: [${8:lowerbound}, ${9:upperbound}],\n        unit: ${10:string}\n      }\n    },\n    ${11:path2}: ...\n  }\n}";
} | {
    readonly name: "$skip";
    readonly value: "$skip";
    readonly label: "$skip";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Skips a specified number of documents before advancing to the next stage.";
    readonly comment: "/**\n * Provide the number of documents to skip.\n */\n";
    readonly snippet: "${1:number}";
} | {
    readonly name: "$sort";
    readonly value: "$sort";
    readonly label: "$sort";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Reorders the document stream by a specified sort key and direction.";
    readonly comment: "/**\n * Provide any number of field/order pairs.\n */\n";
    readonly snippet: "{\n  ${1:field1}: ${2:sortOrder}\n}";
} | {
    readonly name: "$sortByCount";
    readonly value: "$sortByCount";
    readonly label: "$sortByCount";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Groups incoming documents based on the value of a specified expression, then computes the count of documents in each distinct group.";
    readonly comment: "/**\n * expression: Grouping expression or string.\n */\n";
    readonly snippet: "{\n  ${1:expression}\n}";
} | {
    readonly name: "$unionWith";
    readonly value: "$unionWith";
    readonly label: "$unionWith";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.4.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Perform a union with a pipeline on another collection.";
    readonly comment: "/**\n * coll: The collection name.\n * pipeline: The pipeline on the other collection.\n */\n";
    readonly snippet: "{\n  coll: '${1:coll}',\n  pipeline: [${2:pipeline}]\n}";
} | {
    readonly name: "$unset";
    readonly value: "$unset";
    readonly label: "$unset";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Excludes fields from the result document.";
    readonly comment: "/**\n * Provide the field name to exclude.\n * To exclude multiple fields, pass the field names in an array.\n */\n";
    readonly snippet: "'${1:string}'";
} | {
    readonly name: "$unwind";
    readonly value: "$unwind";
    readonly label: "$unwind";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: false;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "2.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db", "coll", "view", "timeseries"];
    readonly description: "Outputs a new document for each element in a specified array. ";
    readonly comment: "/**\n * path: Path to the array field.\n * includeArrayIndex: Optional name for index.\n * preserveNullAndEmptyArrays: Optional\n *   toggle to unwind null and empty values.\n */\n";
    readonly snippet: "{\n  path: ${1:path},\n  includeArrayIndex: '${2:string}',\n  preserveNullAndEmptyArrays: ${3:boolean}\n}";
} | {
    readonly name: "$changeStream";
    readonly value: "$changeStream";
    readonly label: "$changeStream";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: true;
    readonly score: 1;
    readonly env: readonly ["atlas", "on-prem"];
    readonly meta: "stage";
    readonly version: "4.2.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db"];
    readonly description: "Returns a Change Stream cursor for the collection.";
    readonly comment: "/**\n * allChangesForCluster: Optional boolean to include all changes in the cluster.\n * fullDocument: Optional value to request a copy of full document when modified by update operations (Introduced in 6.0).\n * fullDocumentBeforeChange: Value to configure whether to return a full document before the change or not.\n * resumeAfter: Specifies a resume token as the logical starting point for the change stream. Cannot be used with startAfter or startAtOperationTime fields.\n * showExpandedEvents: Specifies whether to include additional change events, such as such as DDL and index operations (Introduced in 6.0).\n * startAfter: Specifies a resume token as the logical starting point for the change stream. Cannot be used with resumeAfter or startAtOperationTime fields.\n * startAtOperationTime: Specifies a time as the logical starting point for the change stream. Cannot be used with resumeAfter or startAfter fields.\n */\n";
    readonly snippet: "{\n  allChangesForCluster: ${1:boolean},\n  fullDocument: '${2:string}',\n  fullDocumentBeforeChange: '${3:string}',\n  resumeAfter: ${4:resumeToken},\n  showExpandedEvents: ${5:boolean},\n  startAfter: ${6:resumeToken},\n  startAtOperationTime: ${7:time},\n}";
} | {
    readonly name: "$currentOp";
    readonly value: "$currentOp";
    readonly label: "$currentOp";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: true;
    readonly score: 1;
    readonly env: readonly ["atlas", "adl", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.6.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db"];
    readonly description: "Returns a cursor over information on active and/or dormant operations for the MongoDB deployment as well as inactive sessions that are holding locks as part of a transaction.";
    readonly comment: "/**\n * allUsers: Optional boolean value to specify whether to return operations for all users or not.\n * idleConnections: Optional boolean value to specify whether to return all operations including idle connections or not.\n * idleCursors: Optional boolean value to specify whether to report on cursors that are idle or not.\n * idleSessions: Optional boolean value to specify whether to report on dormant sessions or not.\n * localOps: Optional boolean value to specify whether to report on operations running locally on targetted mongos or not.\n * backtrace: Optional boolean value to specify whether callstack information is returned as part of the waitingForLatch output field.\n */\n";
    readonly snippet: "{\n  allUsers: ${1:false},\n  idleConnections: ${2:false},\n  idleCursors: ${3:false},\n  idleSessions: ${4:true},\n  localOps: ${5:false},\n  backtrace: ${6:false},\n}";
} | {
    readonly name: "$listLocalSessions";
    readonly value: "$listLocalSessions";
    readonly label: "$listLocalSessions";
    readonly outputStage: false;
    readonly fullScan: false;
    readonly firstStage: true;
    readonly score: 1;
    readonly env: readonly ["atlas", "on-prem"];
    readonly meta: "stage";
    readonly version: "3.6.0";
    readonly apiVersions: readonly [1];
    readonly namespaces: readonly ["db"];
    readonly description: "Lists the sessions cached in memory by the mongod or mongos instance.";
    readonly comment: "/**\n * users: Optional list of users for which local sessions need to be returned.\n * allUsers: Optional boolean value to specify whether to return local sessions for all users or not.\n */\n";
    readonly snippet: "{\n  allUsers: ${1:false},\n  users: [\n    { user: '${2:string}', db: '${3:string}' }\n  ]\n}";
})[];
declare function completer(params: AutocompleteParameters, line: string): Promise<[string[], string, 'exclusive'] | [string[], string]>;
export default completer;
