"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapCliToDriver = void 0;
const errors_1 = require("@mongosh/errors");
const mongodb_connection_string_url_1 = require("mongodb-connection-string-url");
function setDriver(i, key, value) {
    return { ...i, driverOptions: { ...i.driverOptions, [key]: value } };
}
function setServerApi(i, key, value) {
    var _a;
    const previousServerApi = i.driverOptions.serverApi;
    const serverApi = typeof previousServerApi === 'string' ? { version: previousServerApi } : ((_a = { ...previousServerApi }) !== null && _a !== void 0 ? _a : {});
    serverApi[key] = value;
    return setDriver(i, 'serverApi', serverApi);
}
function setAutoEncrypt(i, key, value) {
    var _a;
    const autoEncryption = (_a = i.driverOptions.autoEncryption) !== null && _a !== void 0 ? _a : {};
    autoEncryption[key] = value;
    return setDriver(i, 'autoEncryption', autoEncryption);
}
function setAutoEncryptExtra(i, key, value) {
    var _a, _b;
    const extraOptions = (_b = (_a = i.driverOptions.autoEncryption) === null || _a === void 0 ? void 0 : _a.extraOptions) !== null && _b !== void 0 ? _b : {};
    extraOptions[key] = value;
    return setAutoEncrypt(i, 'extraOptions', extraOptions);
}
function setAWSKMS(i, key, value) {
    var _a, _b;
    const { kmsProviders } = (_a = i.driverOptions.autoEncryption) !== null && _a !== void 0 ? _a : {};
    const aws = (_b = kmsProviders === null || kmsProviders === void 0 ? void 0 : kmsProviders.aws) !== null && _b !== void 0 ? _b : {};
    aws[key] = value;
    return setAutoEncrypt(i, 'kmsProviders', { ...kmsProviders, aws });
}
function setUrlParam(i, key, value) {
    const connectionString = new mongodb_connection_string_url_1.ConnectionString(i.connectionString, { looseValidation: true });
    const searchParams = connectionString.typedSearchParams();
    if (value === '' || value === undefined) {
        searchParams.delete(key);
    }
    else {
        searchParams.set(key, value);
    }
    return { ...i, connectionString: connectionString.toString() };
}
function setUrl(i, key, value) {
    const connectionString = new mongodb_connection_string_url_1.ConnectionString(i.connectionString, { looseValidation: true });
    connectionString[key] = value;
    return { ...i, connectionString: connectionString.toString() };
}
function setAuthMechProp(i, key, value) {
    const connectionString = new mongodb_connection_string_url_1.ConnectionString(i.connectionString, { looseValidation: true });
    const authMechanismProps = new mongodb_connection_string_url_1.CommaAndColonSeparatedRecord(connectionString.typedSearchParams().get('authMechanismProperties'));
    if (value === '' || value === undefined) {
        authMechanismProps.delete(key);
    }
    else {
        authMechanismProps.set(key, value);
    }
    return setUrlParam(i, 'authMechanismProperties', authMechanismProps);
}
function setAuthMechPropNonUrl(i, key, value) {
    return setDriver(i, 'authMechanismProperties', {
        ...i.driverOptions.authMechanismProperties,
        [key]: value
    });
}
function setOIDC(i, key, value) {
    return setDriver(i, 'oidc', { ...i.driverOptions.oidc, [key]: value });
}
function matchingAllowedHosts(i) {
    const connectionString = new mongodb_connection_string_url_1.ConnectionString(i.connectionString, { looseValidation: true });
    const suffixes = connectionString.hosts.map(hostStr => {
        var _a;
        const { host } = (_a = hostStr.match(/^(?<host>.+?)(?<port>:[^:\]\[]+)?$/)) === null || _a === void 0 ? void 0 : _a.groups;
        if (host.startsWith('[') && host.endsWith(']')) {
            return host.slice(1, -1);
        }
        if (host.match(/^[0-9.]+$/)) {
            return host;
        }
        if (!host.includes('.') || !connectionString.isSRV) {
            return host;
        }
        const parts = host.split('.');
        parts[0] = '*';
        return parts.join('.');
    });
    return [...new Set(suffixes)];
}
const MAPPINGS = {
    apiDeprecationErrors: (i, v) => setServerApi(i, 'deprecationErrors', v),
    apiStrict: (i, v) => setServerApi(i, 'strict', v),
    apiVersion: (i, v) => setServerApi(i, 'version', v),
    awsAccessKeyId: (i, v) => setAWSKMS(i, 'accessKeyId', v),
    awsSecretAccessKey: (i, v) => setAWSKMS(i, 'secretAccessKey', v),
    awsSessionToken: (i, v) => setAWSKMS(i, 'sessionToken', v),
    awsIamSessionToken: (i, v) => setAuthMechProp(i, 'AWS_SESSION_TOKEN', v),
    csfleLibraryPath: (i, v) => setAutoEncryptExtra(i, 'cryptSharedLibPath', v),
    cryptSharedLibPath: (i, v) => setAutoEncryptExtra(i, 'cryptSharedLibPath', v),
    gssapiServiceName: (i, v) => setAuthMechProp(i, 'SERVICE_NAME', v),
    sspiRealmOverride: (i, v) => setAuthMechProp(i, 'SERVICE_REALM', v),
    sspiHostnameCanonicalization: (i, v) => setAuthMechProp(i, 'CANONICALIZE_HOST_NAME', mapGSSAPIHostnameCanonicalization(v)),
    authenticationDatabase: (i, v) => setUrlParam(i, 'authSource', v),
    authenticationMechanism: (i, v) => setUrlParam(i, 'authMechanism', v),
    keyVaultNamespace: (i, v) => setAutoEncrypt(i, 'keyVaultNamespace', v),
    password: (i, v) => setUrl(i, 'password', encodeURIComponent(v)),
    retryWrites: (i, v) => setUrlParam(i, 'retryWrites', v),
    tls: (i, v) => setUrlParam(i, 'tls', v),
    tlsAllowInvalidCertificates: (i, v) => setUrlParam(i, 'tlsAllowInvalidCertificates', v),
    tlsAllowInvalidHostnames: (i, v) => setUrlParam(i, 'tlsAllowInvalidHostnames', v),
    tlsCAFile: (i, v) => setUrlParam(i, 'tlsCAFile', v),
    tlsCRLFile: (i, v) => setUrlParam(i, 'sslCRL', v),
    tlsCertificateKeyFile: (i, v) => setUrlParam(i, 'tlsCertificateKeyFile', v),
    tlsCertificateKeyFilePassword: (i, v) => setUrlParam(i, 'tlsCertificateKeyFilePassword', v),
    tlsUseSystemCA: (i, v) => setDriver(i, 'useSystemCA', v),
    username: (i, v) => setUrl(i, 'username', encodeURIComponent(v)),
    oidcRedirectUri: (i, v) => setOIDC(i, 'redirectURI', v),
    oidcTrustedEndpoint: (i, v) => setAuthMechPropNonUrl(i, 'ALLOWED_HOSTS', v ? matchingAllowedHosts(i) : undefined),
    oidcFlows: (i, v) => setOIDC(i, 'allowedFlows', v.split(',').filter(Boolean)),
    browser: (i, v) => setOIDC(i, 'openBrowser', typeof v === 'string' ? { command: v } : v),
};
function mapOption(i, key, value) {
    var _a, _b;
    return (_b = (_a = MAPPINGS[key]) === null || _a === void 0 ? void 0 : _a.call(MAPPINGS, i, value)) !== null && _b !== void 0 ? _b : i;
}
function mapCliToDriver(options, i) {
    for (const cliOption of Object.keys(options)) {
        const optionValue = options[cliOption];
        if (optionValue !== null && optionValue !== undefined && optionValue !== '') {
            i = mapOption(i, cliOption, optionValue);
        }
    }
    validateConnectionInfoAfterArgMapping(i, options);
    return i;
}
exports.mapCliToDriver = mapCliToDriver;
function mapGSSAPIHostnameCanonicalization(value) {
    if (value === '') {
        return undefined;
    }
    if (value === 'true' || value === 'false') {
        return value === 'true';
    }
    return value;
}
function validateConnectionInfoAfterArgMapping(info, originalOptions) {
    if (!info.connectionString) {
        return;
    }
    const connectionString = new mongodb_connection_string_url_1.ConnectionString(info.connectionString, { looseValidation: true });
    if (connectionString.password && !connectionString.username) {
        let text = 'Invalid connection information: Password specified but no username provided';
        if (originalOptions.password && !originalOptions.port) {
            text += " (did you mean '--port' instead of '-p'?)";
        }
        throw new errors_1.MongoshInvalidInputError(text, errors_1.CommonErrors.InvalidArgument);
    }
    new mongodb_connection_string_url_1.ConnectionString(info.connectionString, { looseValidation: false });
}
exports.default = mapCliToDriver;
//# sourceMappingURL=arg-mapper.js.map