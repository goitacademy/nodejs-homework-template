"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateUri = void 0;
const errors_1 = require("@mongosh/errors");
const i18n_1 = __importDefault(require("@mongosh/i18n"));
const mongodb_connection_string_url_1 = require("mongodb-connection-string-url");
const DEFAULT_HOST = '127.0.0.1';
const DEFAULT_PORT = '27017';
const CONFLICT = 'cli-repl.uri-generator.no-host-port';
const INVALID_HOST = 'cli-repl.uri-generator.invalid-host';
const HOST_LIST_PORT_MISMATCH = 'cli-repl.uri-generator.host-list-port-mismatch';
const DIVERGING_SERVICE_NAME = 'cli-repl.uri-generator.diverging-service-name';
const GSSAPI_SERVICE_NAME_UNSUPPORTED = 'cli-repl.uri-generator.gssapi-service-name-unsupported';
function validateConflicts(options, connectionString) {
    if (options.host || options.port) {
        throw new errors_1.MongoshInvalidInputError(i18n_1.default.__(CONFLICT), errors_1.CommonErrors.InvalidArgument);
    }
    if (options.gssapiServiceName && (connectionString === null || connectionString === void 0 ? void 0 : connectionString.searchParams.has('authMechanismProperties'))) {
        const authProperties = new mongodb_connection_string_url_1.CommaAndColonSeparatedRecord(connectionString.searchParams.get('authMechanismProperties'));
        const serviceName = authProperties.get('SERVICE_NAME');
        if (serviceName !== undefined && options.gssapiServiceName !== serviceName) {
            throw new errors_1.MongoshInvalidInputError(i18n_1.default.__(DIVERGING_SERVICE_NAME), errors_1.CommonErrors.InvalidArgument);
        }
    }
    if (connectionString === null || connectionString === void 0 ? void 0 : connectionString.searchParams.has('gssapiServiceName')) {
        throw new errors_1.MongoshInvalidInputError(i18n_1.default.__(GSSAPI_SERVICE_NAME_UNSUPPORTED), errors_1.CommonErrors.InvalidArgument);
    }
}
function validateHost(host) {
    const invalidCharacter = host.match(/[^a-zA-Z0-9.:\[\]_-]/);
    if (invalidCharacter) {
        throw new errors_1.MongoshInvalidInputError(i18n_1.default.__(INVALID_HOST) + ': ' + invalidCharacter[0], errors_1.CommonErrors.InvalidArgument);
    }
}
function validateHostSeedList(hosts, fixedPort) {
    var _a, _b;
    const trimmedHosts = hosts.split(',').map(h => h.trim()).filter(h => !!h);
    const hostList = [];
    for (const h of trimmedHosts) {
        const { host, port } = (_b = (_a = h.match(/^(?<host>.+?)(:(?<port>\d+))?$/)) === null || _a === void 0 ? void 0 : _a.groups) !== null && _b !== void 0 ? _b : {};
        if (fixedPort && port !== undefined && port !== fixedPort) {
            throw new errors_1.MongoshInvalidInputError(i18n_1.default.__(HOST_LIST_PORT_MISMATCH), errors_1.CommonErrors.InvalidArgument);
        }
        hostList.push(`${host}${(port || fixedPort) ? ':' + (port || fixedPort) : ''}`);
    }
    return hostList;
}
function generateHost(options) {
    if (options.host) {
        validateHost(options.host);
        if (options.host.includes(':')) {
            return options.host.split(':')[0];
        }
        return options.host;
    }
    return DEFAULT_HOST;
}
function generatePort(options) {
    if (options.host && options.host.includes(':')) {
        validateHost(options.host);
        const port = options.host.split(':')[1];
        if (!options.port || options.port === port) {
            return port;
        }
        throw new errors_1.MongoshInvalidInputError(i18n_1.default.__(CONFLICT), errors_1.CommonErrors.InvalidArgument);
    }
    return options.port ? options.port : DEFAULT_PORT;
}
function generateUri(options) {
    if (options.nodb) {
        return '';
    }
    const connectionString = generateUriNormalized(options);
    if (connectionString.hosts.every(host => ['localhost', '127.0.0.1'].includes(host.split(':')[0]))) {
        const params = connectionString.searchParams;
        if (!params.has('serverSelectionTimeoutMS')) {
            params.set('serverSelectionTimeoutMS', '2000');
        }
    }
    return connectionString.toString();
}
exports.generateUri = generateUri;
function generateUriNormalized(options) {
    var _a, _b, _c;
    const uri = options.connectionSpecifier;
    const replSetHostMatch = ((_a = options.host) !== null && _a !== void 0 ? _a : '').match(/^(?<replSetName>[^/]+)\/(?<hosts>(([A-Za-z0-9._-]+|\[[0-9a-fA-F:]+\])(:\d+)?,?)+)$/);
    if (replSetHostMatch) {
        const { replSetName, hosts } = replSetHostMatch.groups;
        const connectionString = new mongodb_connection_string_url_1.ConnectionString(`mongodb://replacemeHost/${encodeURIComponent(uri || '')}`);
        connectionString.hosts = validateHostSeedList(hosts, options.port);
        connectionString.searchParams.set('replicaSet', replSetName);
        return addShellConnectionStringParameters(connectionString);
    }
    const seedList = ((_b = options.host) !== null && _b !== void 0 ? _b : '').match(/^(?<hosts>([A-Za-z0-9._-]+(:\d+)?,?)+)$/);
    if (seedList && ((_c = options.host) === null || _c === void 0 ? void 0 : _c.includes(','))) {
        const { hosts } = seedList.groups;
        const connectionString = new mongodb_connection_string_url_1.ConnectionString(`mongodb://replacemeHost/${encodeURIComponent(uri || '')}`);
        connectionString.hosts = validateHostSeedList(hosts, options.port);
        return addShellConnectionStringParameters(connectionString);
    }
    if (!uri) {
        return new mongodb_connection_string_url_1.ConnectionString(`mongodb://${generateHost(options)}:${generatePort(options)}/?directConnection=true`);
    }
    if (uri.startsWith('mongodb+srv://')) {
        const connectionString = new mongodb_connection_string_url_1.ConnectionString(uri);
        validateConflicts(options, connectionString);
        return connectionString;
    }
    else if (uri.startsWith('mongodb://')) {
        const connectionString = new mongodb_connection_string_url_1.ConnectionString(uri);
        validateConflicts(options, connectionString);
        return addShellConnectionStringParameters(connectionString);
    }
    const uriMatch = /^([A-Za-z0-9][A-Za-z0-9._-]+):?(\d+)?(?:\/(\S*))?$/gi;
    let parts = uriMatch.exec(uri);
    if (parts === null) {
        if (/[/\\. "$]/.test(uri)) {
            throw new errors_1.MongoshInvalidInputError(`Invalid URI: ${uri}`, errors_1.CommonErrors.InvalidArgument);
        }
        else {
            parts = [uri, uri];
        }
    }
    let host = parts === null || parts === void 0 ? void 0 : parts[1];
    const port = parts === null || parts === void 0 ? void 0 : parts[2];
    let dbAndQueryString = parts === null || parts === void 0 ? void 0 : parts[3];
    if (!port && !dbAndQueryString && host.indexOf('.') < 0) {
        dbAndQueryString = host;
        host = undefined;
    }
    if (host || port) {
        validateConflicts(options);
    }
    return addShellConnectionStringParameters(new mongodb_connection_string_url_1.ConnectionString(`mongodb://${host || generateHost(options)}:${port || generatePort(options)}/${encodeURIComponent(dbAndQueryString || '')}`));
}
function addShellConnectionStringParameters(uri) {
    uri = uri.clone();
    const params = uri.searchParams;
    if (!params.has('replicaSet') && !params.has('directConnection') && !params.has('loadBalanced') && uri.hosts.length === 1) {
        params.set('directConnection', 'true');
    }
    return uri;
}
//# sourceMappingURL=uri-generator.js.map