"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InterruptFlag = exports.MongoshInterruptedError = void 0;
const errors_1 = require("@mongosh/errors");
const kUncatchable = Symbol.for('@@mongosh.uncatchable');
class MongoshInterruptedError extends errors_1.MongoshBaseError {
    constructor() {
        super('MongoshInterruptedError', 'execution was interrupted');
        this[_a] = true;
    }
}
exports.MongoshInterruptedError = MongoshInterruptedError;
_a = kUncatchable;
class InterruptFlag {
    constructor() {
        this.interrupted = false;
        this.onInterruptListeners = [];
    }
    isSet() {
        return this.interrupted;
    }
    checkpoint() {
        if (this.interrupted) {
            throw new MongoshInterruptedError();
        }
    }
    asPromise() {
        if (this.interrupted) {
            return {
                destroy: () => { },
                promise: Promise.reject(new MongoshInterruptedError())
            };
        }
        let destroy;
        const promise = new Promise((_, reject) => {
            destroy = () => {
                const index = this.onInterruptListeners.indexOf(reject);
                if (index !== -1) {
                    this.onInterruptListeners.splice(index, 1);
                }
                reject(null);
            };
            this.onInterruptListeners.push(reject);
        });
        return {
            destroy: destroy,
            promise
        };
    }
    set() {
        this.interrupted = true;
        const err = new MongoshInterruptedError();
        for (const listener of [...this.onInterruptListeners]) {
            listener(err);
        }
    }
    reset() {
        this.interrupted = false;
    }
}
exports.InterruptFlag = InterruptFlag;
//# sourceMappingURL=interruptor.js.map