"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const enums_1 = require("./enums");
const help_1 = __importDefault(require("./help"));
const service_provider_core_1 = require("@mongosh/service-provider-core");
const errors_1 = require("@mongosh/errors");
const helpers_1 = require("./helpers");
const crypto_1 = require("crypto");
function constructHelp(className) {
    const classHelpKeyPrefix = `shell-api.classes.${className}.help`;
    const classHelp = {
        help: `${classHelpKeyPrefix}.description`,
        example: `${classHelpKeyPrefix}.example`,
        docs: `${classHelpKeyPrefix}.link`,
        attr: []
    };
    return new help_1.default(classHelp);
}
function constructShellBson(bson, printWarning) {
    const bsonNames = [
        'Binary', 'Code', 'DBRef', 'Decimal128', 'Double', 'Int32', 'Long',
        'MaxKey', 'MinKey', 'ObjectId', 'Timestamp', 'BSONSymbol',
        'BSONRegExp'
    ];
    if (bson === undefined) {
        bson = service_provider_core_1.bson;
    }
    const helps = {};
    bsonNames.forEach((className) => {
        if (!(className in bson)) {
            throw new errors_1.MongoshInternalError(`${className} does not exist in provided BSON package.`);
        }
        const proto = bson[className].prototype;
        proto.serverVersions = enums_1.ALL_SERVER_VERSIONS;
        proto.platforms = enums_1.ALL_PLATFORMS;
        proto.topologies = enums_1.ALL_TOPOLOGIES;
        const help = constructHelp(className);
        helps[className] = help;
        proto.help = () => (help);
        Object.setPrototypeOf(proto.help, help);
    });
    bson.BSONSymbol.prototype.serverVersions = [enums_1.ServerVersions.earliest, '1.6.0'];
    bson.BSONSymbol.prototype.deprecated = true;
    const bsonPkg = {
        DBRef: (0, helpers_1.assignAll)(function DBRef(namespace, oid, db, fields) {
            (0, helpers_1.assertArgsDefinedType)([namespace, oid, db], ['string', true, [undefined, 'string'], [undefined, 'object']], 'DBRef');
            return new bson.DBRef(namespace, oid, db, fields);
        }, bson.DBRef),
        bsonsize: function bsonsize(object) {
            (0, helpers_1.assertArgsDefinedType)([object], ['object'], 'bsonsize');
            return bson.calculateObjectSize(object);
        },
        MaxKey: (0, helpers_1.assignAll)(function MaxKey() {
            return new bson.MaxKey();
        }, bson.MaxKey, { toBSON: () => new bson.MaxKey() }),
        MinKey: (0, helpers_1.assignAll)(function MinKey() {
            return new bson.MinKey();
        }, bson.MinKey, { toBSON: () => new bson.MinKey() }),
        ObjectId: (0, helpers_1.assignAll)(function ObjectId(id) {
            (0, helpers_1.assertArgsDefinedType)([id], [[undefined, 'string', 'number', 'object']], 'ObjectId');
            return new bson.ObjectId(id);
        }, bson.ObjectId, {
            prototype: (0, helpers_1.assignAll)(bson.ObjectId.prototype, {
                get generationTime() {
                    return Math.floor(this.getTimestamp().valueOf() / 1000);
                },
                toString: makeLegacytoStringWrapper(bson.ObjectId.prototype.toString)
            })
        }),
        Timestamp: (0, helpers_1.assignAll)(function Timestamp(t, i) {
            (0, helpers_1.assertArgsDefinedType)([t, i], [['number', 'object', undefined], [undefined, 'number']], 'Timestamp');
            if (typeof t === 'object' && t !== null && 't' in t && 'i' in t) {
                return new bson.Timestamp(t);
            }
            else if (i !== undefined || typeof t === 'number') {
                return new bson.Timestamp({ t: t, i: i !== null && i !== void 0 ? i : 0 });
            }
            return new bson.Timestamp(t);
        }, bson.Timestamp),
        Code: (0, helpers_1.assignAll)(function Code(c = '', s) {
            (0, helpers_1.assertArgsDefinedType)([c, s], [[undefined, 'string', 'function'], [undefined, 'object']], 'Code');
            return new bson.Code(c, s);
        }, bson.Code),
        NumberDecimal: (0, helpers_1.assignAll)(function NumberDecimal(s = '0') {
            (0, helpers_1.assertArgsDefinedType)([s], [['string', 'number', 'bson:Long', 'bson:Int32', 'bson:Decimal128']], 'NumberDecimal');
            if (typeof s === 'number') {
                printWarning('NumberDecimal: specifying a number as argument is deprecated and may lead to loss of precision, pass a string instead');
            }
            return bson.Decimal128.fromString(`${s}`);
        }, { prototype: bson.Decimal128.prototype }),
        NumberInt: (0, helpers_1.assignAll)(function NumberInt(v = '0') {
            v !== null && v !== void 0 ? v : (v = '0');
            (0, helpers_1.assertArgsDefinedType)([v], [['string', 'number', 'bson:Long', 'bson:Int32']], 'NumberInt');
            return new bson.Int32(parseInt(`${v}`, 10));
        }, { prototype: bson.Int32.prototype }),
        NumberLong: (0, helpers_1.assignAll)(function NumberLong(s = '0') {
            s !== null && s !== void 0 ? s : (s = '0');
            (0, helpers_1.assertArgsDefinedType)([s], [['string', 'number', 'bson:Long', 'bson:Int32']], 'NumberLong');
            if (typeof s === 'number') {
                printWarning('NumberLong: specifying a number as argument is deprecated and may lead to loss of precision, pass a string instead');
                return bson.Long.fromNumber(s);
            }
            return bson.Long.fromString(`${s}`);
        }, { prototype: bson.Long.prototype }),
        ISODate: function ISODate(input) {
            if (!input)
                input = new Date().toISOString();
            const isoDateRegex = /^(?<Y>\d{4})-?(?<M>\d{2})-?(?<D>\d{2})([T ](?<h>\d{2})(:?(?<m>\d{2})(:?((?<s>\d{2})(\.(?<ms>\d+))?))?)?(?<tz>Z|([+-])(\d{2}):?(\d{2})?)?)?$/;
            const match = input.match(isoDateRegex);
            if (match !== null && match.groups !== undefined) {
                const { Y, M, D, h, m, s, ms, tz } = match.groups;
                const normalized = `${Y}-${M}-${D}T${h || '00'}:${m || '00'}:${s || '00'}.${ms || '000'}${tz || 'Z'}`;
                const date = new Date(normalized);
                if (date.getTime() >= -62167219200000 && date.getTime() <= 253402300799999) {
                    return date;
                }
            }
            throw new errors_1.MongoshInvalidInputError(`${JSON.stringify(input)} is not a valid ISODate`, errors_1.CommonErrors.InvalidArgument);
        },
        BinData: (0, helpers_1.assignAll)(function BinData(subtype, b64string) {
            (0, helpers_1.assertArgsDefinedType)([subtype, b64string], ['number', 'string'], 'BinData');
            const buffer = Buffer.from(b64string, 'base64');
            return new bson.Binary(buffer, subtype);
        }, { prototype: bson.Binary.prototype }),
        HexData: (0, helpers_1.assignAll)(function HexData(subtype, hexstr) {
            (0, helpers_1.assertArgsDefinedType)([subtype, hexstr], ['number', 'string'], 'HexData');
            const buffer = Buffer.from(hexstr, 'hex');
            return new bson.Binary(buffer, subtype);
        }, { prototype: bson.Binary.prototype }),
        UUID: (0, helpers_1.assignAll)(function UUID(hexstr) {
            if (hexstr === undefined) {
                const uuid = (0, crypto_1.randomBytes)(16);
                uuid[6] = (uuid[6] & 0x0f) | 0x40;
                uuid[8] = (uuid[8] & 0x3f) | 0x80;
                hexstr = uuid.toString('hex');
            }
            (0, helpers_1.assertArgsDefinedType)([hexstr], ['string'], 'UUID');
            const buffer = Buffer.from(hexstr.replace(/-/g, ''), 'hex');
            return new bson.Binary(buffer, bson.Binary.SUBTYPE_UUID);
        }, { prototype: bson.Binary.prototype }),
        MD5: (0, helpers_1.assignAll)(function MD5(hexstr) {
            (0, helpers_1.assertArgsDefinedType)([hexstr], ['string'], 'MD5');
            const buffer = Buffer.from(hexstr, 'hex');
            return new bson.Binary(buffer, bson.Binary.SUBTYPE_MD5);
        }, { prototype: bson.Binary.prototype }),
        Decimal128: (0, helpers_1.functionCtor)(bson.Decimal128),
        BSONSymbol: (0, helpers_1.functionCtor)(bson.BSONSymbol),
        Int32: (0, helpers_1.functionCtor)(bson.Int32),
        Long: (0, helpers_1.functionCtor)(bson.Long),
        Binary: (0, helpers_1.assignAll)(function Binary(...args) {
            return new bson.Binary(...args);
        }, bson.Binary, {
            prototype: (0, helpers_1.assignAll)(bson.Binary.prototype, {
                toString: makeLegacytoStringWrapper(bson.Binary.prototype.toString)
            })
        }),
        Double: (0, helpers_1.functionCtor)(bson.Double),
        BSONRegExp: (0, helpers_1.functionCtor)(bson.BSONRegExp),
        EJSON: Object.create(Object.getPrototypeOf(bson.EJSON), Object.getOwnPropertyDescriptors(bson.EJSON)),
    };
    for (const className of Object.keys(bsonPkg)) {
        const help = helps[className] || constructHelp(className);
        bsonPkg[className].help = () => (help);
        Object.setPrototypeOf(bsonPkg[className].help, help);
    }
    return bsonPkg;
}
exports.default = constructShellBson;
function makeLegacytoStringWrapper(originalToString) {
    return function toString(encoding) {
        if (['hex', 'base64', 'utf8', undefined].includes(encoding)) {
            return originalToString.call(this, encoding);
        }
        return Buffer.from(originalToString.call(this, 'base64'), 'base64').toString(encoding);
    };
}
//# sourceMappingURL=shell-bson.js.map