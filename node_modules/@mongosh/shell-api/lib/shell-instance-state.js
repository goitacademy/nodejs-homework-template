"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("@mongosh/errors");
const service_provider_core_1 = require("@mongosh/service-provider-core");
const events_1 = require("events");
const mongodb_redact_1 = __importDefault(require("mongodb-redact"));
const decorators_1 = require("./decorators");
const enums_1 = require("./enums");
const error_codes_1 = require("./error-codes");
const index_1 = require("./index");
const interruptor_1 = require("./interruptor");
const mongo_errors_1 = require("./mongo-errors");
const no_db_1 = __importDefault(require("./no-db"));
const shell_bson_1 = __importDefault(require("./shell-bson"));
class ShellInstanceState {
    constructor(initialServiceProvider, messageBus = new events_1.EventEmitter(), cliOptions = {}) {
        this.displayBatchSizeFromDBQuery = undefined;
        this.isInteractive = false;
        this.apiCallDepth = 0;
        this.warningsShown = new Set();
        this.interrupted = new interruptor_1.InterruptFlag();
        this.plugins = [new mongo_errors_1.TransformMongoErrorPlugin()];
        this.alreadyTransformedErrors = new WeakMap();
        this.initialServiceProvider = initialServiceProvider;
        this.messageBus = messageBus;
        this.shellApi = new index_1.ShellApi(this);
        this.shellBson = (0, shell_bson_1.default)(initialServiceProvider.bsonLibrary, (msg) => {
            void this.shellApi.print(`Warning: ${msg}`);
        });
        this.mongos = [];
        this.connectionInfo = { buildInfo: {} };
        if (!cliOptions.nodb) {
            const mongo = new index_1.Mongo(this, undefined, undefined, undefined, initialServiceProvider);
            this.mongos.push(mongo);
            this.currentDb = mongo.getDB(initialServiceProvider.initialDb || service_provider_core_1.DEFAULT_DB);
        }
        else {
            this.currentDb = new no_db_1.default();
        }
        this.currentCursor = null;
        this.context = {};
        this.cliOptions = cliOptions;
        this.evaluationListener = {};
    }
    async fetchConnectionInfo() {
        if (!this.cliOptions.nodb) {
            this.connectionInfo = await this.currentServiceProvider.getConnectionInfo();
            const apiVersionInfo = this.apiVersionInfo();
            this.messageBus.emit('mongosh:connect', {
                ...this.connectionInfo.extraInfo,
                api_version: apiVersionInfo === null || apiVersionInfo === void 0 ? void 0 : apiVersionInfo.version,
                api_strict: apiVersionInfo === null || apiVersionInfo === void 0 ? void 0 : apiVersionInfo.strict,
                api_deprecation_errors: apiVersionInfo === null || apiVersionInfo === void 0 ? void 0 : apiVersionInfo.deprecationErrors,
                uri: (0, mongodb_redact_1.default)(this.connectionInfo.extraInfo.uri)
            });
        }
    }
    async close(force) {
        for (const mongo of [...this.mongos]) {
            await mongo.close(force);
        }
    }
    setDbFunc(newDb) {
        this.currentDb = newDb;
        this.context.rs = new index_1.ReplicaSet(this.currentDb);
        this.context.sh = new index_1.Shard(this.currentDb);
        this.fetchConnectionInfo().catch(err => this.messageBus.emit('mongosh:error', err, 'shell-api'));
        this.currentDb._getCollectionNamesForCompletion().catch(err => this.messageBus.emit('mongosh:error', err, 'shell-api'));
        this.currentDb._mongo._getDatabaseNamesForCompletion().catch(err => this.messageBus.emit('mongosh:error', err, 'shell-api'));
        this.currentCursor = null;
        return newDb;
    }
    setCtx(contextObject) {
        this.context = contextObject;
        Object.assign(contextObject, this.shellApi);
        for (const name of Object.getOwnPropertyNames(index_1.ShellApi.prototype)) {
            const { shellApi } = this;
            if (decorators_1.toIgnore.concat(['help']).includes(name) ||
                typeof shellApi[name] !== 'function') {
                continue;
            }
            contextObject[name] = function (...args) {
                return shellApi[name](...args);
            };
            contextObject[name].help = shellApi[name].help;
        }
        contextObject.help = this.shellApi.help;
        Object.assign(contextObject, this.shellBson);
        if (contextObject.console === undefined) {
            contextObject.console = {};
        }
        for (const key of ['log', 'warn', 'info', 'error']) {
            contextObject.console[key] = (...args) => {
                return contextObject.print(...args);
            };
        }
        contextObject.console.clear = contextObject.cls;
        contextObject.rs = new index_1.ReplicaSet(this.currentDb);
        contextObject.sh = new index_1.Shard(this.currentDb);
        const setFunc = (newDb) => {
            if ((0, index_1.getShellApiType)(newDb) !== 'Database') {
                throw new errors_1.MongoshInvalidInputError('Cannot reassign \'db\' to non-Database type', errors_1.CommonErrors.InvalidOperation);
            }
            return this.setDbFunc(newDb);
        };
        if (this.initialServiceProvider.platform === 'JavaShell') {
            contextObject.db = this.setDbFunc(this.currentDb);
        }
        else {
            Object.defineProperty(contextObject, 'db', {
                configurable: true,
                set: setFunc,
                get: () => (this.currentDb)
            });
        }
        this.messageBus.emit('mongosh:setCtx', { method: 'setCtx', arguments: {} });
    }
    get currentServiceProvider() {
        try {
            return this.currentDb._mongo._serviceProvider;
        }
        catch (err) {
            if ((err === null || err === void 0 ? void 0 : err.code) === error_codes_1.ShellApiErrors.NotConnected) {
                return this.initialServiceProvider;
            }
            throw err;
        }
    }
    emitApiCallWithArgs(event) {
        this.messageBus.emit('mongosh:api-call-with-arguments', event);
    }
    emitApiCall(event) {
        this.messageBus.emit('mongosh:api-call', {
            ...event,
            callDepth: this.apiCallDepth
        });
    }
    setEvaluationListener(listener) {
        this.evaluationListener = listener;
    }
    getAutocompleteParameters() {
        return {
            topology: () => {
                var _a;
                let topology;
                const topologyDescription = (_a = this.currentServiceProvider.getTopology()) === null || _a === void 0 ? void 0 : _a.description;
                const topologyType = topologyDescription === null || topologyDescription === void 0 ? void 0 : topologyDescription.type;
                switch (topologyType) {
                    case 'ReplicaSetNoPrimary':
                    case 'ReplicaSetWithPrimary':
                        topology = enums_1.Topologies.ReplSet;
                        break;
                    case 'Sharded':
                        topology = enums_1.Topologies.Sharded;
                        break;
                    case 'LoadBalanced':
                        topology = enums_1.Topologies.LoadBalanced;
                        break;
                    default:
                        topology = enums_1.Topologies.Standalone;
                        if (topologyDescription.servers.size === 1) {
                            const [server] = topologyDescription.servers.values();
                            switch (server.type) {
                                case 'Mongos':
                                    topology = enums_1.Topologies.Sharded;
                                    break;
                                case 'PossiblePrimary':
                                case 'RSPrimary':
                                case 'RSSecondary':
                                case 'RSArbiter':
                                case 'RSOther':
                                case 'RSGhost':
                                    topology = enums_1.Topologies.ReplSet;
                                    break;
                                default:
                                    break;
                            }
                        }
                        break;
                }
                return topology;
            },
            apiVersionInfo: () => {
                return this.apiVersionInfo();
            },
            connectionInfo: () => {
                return this.connectionInfo.extraInfo;
            },
            getCollectionCompletionsForCurrentDb: async (collName) => {
                try {
                    const collectionNames = await this.currentDb._getCollectionNamesForCompletion();
                    return collectionNames.filter((name) => name.toLowerCase().startsWith(collName.toLowerCase()));
                }
                catch (err) {
                    if ((err === null || err === void 0 ? void 0 : err.code) === error_codes_1.ShellApiErrors.NotConnected ||
                        (err === null || err === void 0 ? void 0 : err.codeName) === 'Unauthorized') {
                        return [];
                    }
                    throw err;
                }
            },
            getDatabaseCompletions: async (dbName) => {
                try {
                    const dbNames = await this.currentDb._mongo._getDatabaseNamesForCompletion();
                    return dbNames.filter((name) => name.toLowerCase().startsWith(dbName.toLowerCase()));
                }
                catch (err) {
                    if ((err === null || err === void 0 ? void 0 : err.code) === error_codes_1.ShellApiErrors.NotConnected ||
                        (err === null || err === void 0 ? void 0 : err.codeName) === 'Unauthorized') {
                        return [];
                    }
                    throw err;
                }
            }
        };
    }
    apiVersionInfo() {
        var _a, _b;
        const { serverApi } = (_b = (_a = this.currentServiceProvider.getRawClient()) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : {};
        return (serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? { strict: false, deprecationErrors: false, ...serverApi } : undefined;
    }
    async onInterruptExecution() {
        this.interrupted.set();
        this.currentCursor = null;
        this.resumeMongosAfterInterrupt = await Promise.all(this.mongos.map(async (m) => {
            try {
                return {
                    mongo: m,
                    resume: await m._suspend()
                };
            }
            catch (e) {
                return {
                    mongo: m,
                    resume: null
                };
            }
        }));
        return !this.resumeMongosAfterInterrupt.find(r => r.resume === null);
    }
    async onResumeExecution() {
        var _a, _b;
        const promises = (_b = (_a = this.resumeMongosAfterInterrupt) === null || _a === void 0 ? void 0 : _a.map(async (r) => {
            if (!this.mongos.find(m => m === r.mongo)) {
                return true;
            }
            if (r.resume === null) {
                return false;
            }
            try {
                await r.resume();
                return true;
            }
            catch (e) {
                return false;
            }
        })) !== null && _b !== void 0 ? _b : [];
        this.resumeMongosAfterInterrupt = undefined;
        const result = await Promise.all(promises);
        this.interrupted.reset();
        return !result.find(r => r === false);
    }
    async getDefaultPrompt() {
        const prefix = this.getDefaultPromptPrefix();
        const topologyInfo = this.getTopologySpecificPrompt();
        let dbname = '';
        try {
            dbname = this.currentDb.getName();
        }
        catch (_a) { }
        return `${[prefix, topologyInfo, dbname].filter(Boolean).join(' ')}> `;
    }
    getDefaultPromptPrefix() {
        var _a, _b, _c, _d;
        const extraConnectionInfo = (_a = this.connectionInfo) === null || _a === void 0 ? void 0 : _a.extraInfo;
        if (extraConnectionInfo === null || extraConnectionInfo === void 0 ? void 0 : extraConnectionInfo.is_data_federation) {
            return 'AtlasDataFederation';
        }
        else if (extraConnectionInfo === null || extraConnectionInfo === void 0 ? void 0 : extraConnectionInfo.is_atlas) {
            return 'Atlas';
        }
        else if ((extraConnectionInfo === null || extraConnectionInfo === void 0 ? void 0 : extraConnectionInfo.is_enterprise) || ((_d = (_c = (_b = this.connectionInfo) === null || _b === void 0 ? void 0 : _b.buildInfo) === null || _c === void 0 ? void 0 : _c.modules) === null || _d === void 0 ? void 0 : _d.indexOf('enterprise')) >= 0) {
            return 'Enterprise';
        }
        return '';
    }
    getTopologySpecificPrompt() {
        var _a, _b, _c, _d;
        const description = (_a = this.currentServiceProvider.getTopology()) === null || _a === void 0 ? void 0 : _a.description;
        if (!description) {
            return '';
        }
        let replicaSet = description.setName;
        let serverTypePrompt = '';
        switch (description.type) {
            case 'Single':
                const singleDetails = this.getTopologySinglePrompt(description);
                replicaSet = (_b = singleDetails === null || singleDetails === void 0 ? void 0 : singleDetails.replicaSet) !== null && _b !== void 0 ? _b : replicaSet;
                serverTypePrompt = (singleDetails === null || singleDetails === void 0 ? void 0 : singleDetails.serverType) ? `[direct: ${singleDetails.serverType}]` : '';
                break;
            case 'ReplicaSetNoPrimary':
                serverTypePrompt = '[secondary]';
                break;
            case 'ReplicaSetWithPrimary':
                serverTypePrompt = '[primary]';
                break;
            case 'Sharded':
                serverTypePrompt = ((_d = (_c = this.connectionInfo) === null || _c === void 0 ? void 0 : _c.extraInfo) === null || _d === void 0 ? void 0 : _d.atlas_version) ? '' : '[mongos]';
                break;
            case 'LoadBalanced':
            default:
                return '';
        }
        const setNamePrefix = replicaSet ? `${replicaSet} ` : '';
        return `${setNamePrefix}${serverTypePrompt}`;
    }
    getTopologySinglePrompt(description) {
        var _a;
        if (((_a = description.servers) === null || _a === void 0 ? void 0 : _a.size) !== 1) {
            return undefined;
        }
        const [server] = description.servers.values();
        let serverType;
        switch (server.type) {
            case 'Mongos':
                serverType = 'mongos';
                break;
            case 'RSPrimary':
                serverType = 'primary';
                break;
            case 'RSSecondary':
                serverType = 'secondary';
                break;
            case 'RSArbiter':
                serverType = 'arbiter';
                break;
            case 'RSOther':
                serverType = 'other';
                break;
            default:
                serverType = '';
        }
        return {
            replicaSet: server.setName,
            serverType
        };
    }
    registerPlugin(plugin) {
        this.plugins.push(plugin);
    }
    transformError(err) {
        if (Object.prototype.toString.call(err) === '[object Error]') {
            if (this.alreadyTransformedErrors.has(err)) {
                return this.alreadyTransformedErrors.get(err);
            }
            const before = err;
            for (const plugin of this.plugins) {
                if (plugin.transformError) {
                    err = plugin.transformError(err);
                }
            }
            this.alreadyTransformedErrors.set(before, err);
        }
        return err;
    }
    async printDeprecationWarning(message) {
        if (!this.warningsShown.has(message)) {
            this.warningsShown.add(message);
            if (this.context.print) {
                await this.context.print.call(this.shellApi, `DeprecationWarning: ${message}`);
            }
            else {
                await this.shellApi.print(`DeprecationWarning: ${message}`);
            }
        }
    }
    async printWarning(message) {
        if (!this.warningsShown.has(message)) {
            this.warningsShown.add(message);
            if (this.context.print) {
                await this.context.print.call(this.shellApi, `Warning: ${message}`);
            }
            else {
                await this.shellApi.print(`Warning: ${message}`);
            }
        }
    }
}
exports.default = ShellInstanceState;
//# sourceMappingURL=shell-instance-state.js.map