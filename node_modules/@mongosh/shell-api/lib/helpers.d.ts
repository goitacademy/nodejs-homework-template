import type { DbOptions, Document, ExplainVerbosityLike, FindOneAndDeleteOptions, FindOneAndReplaceOptions, FindOneAndUpdateOptions, DeleteOptions, MapReduceOptions, ExplainOptions } from '@mongosh/service-provider-core';
import type Database from './database';
import type Collection from './collection';
import { CursorIterationResult } from './result';
import { ReplPlatform, bson } from '@mongosh/service-provider-core';
import { ClientSideFieldLevelEncryptionOptions } from './field-level-encryption';
import { AutoEncryptionOptions } from 'mongodb';
import type { AbstractCursor } from './abstract-cursor';
import type ChangeStreamCursor from './change-stream-cursor';
import type { ShellBson } from './shell-bson';
export declare function adaptAggregateOptions(options?: any): {
    aggOptions: Document;
    dbOptions: DbOptions;
    explain?: ExplainVerbosityLike & string;
};
export declare function validateExplainableVerbosity(verbosity: ExplainVerbosityLike): ExplainVerbosityLike & string;
export declare function assertArgsDefinedType(args: any[], expectedTypes: Array<true | string | Array<string | undefined>>, func?: string): void;
export declare function assertKeysDefined(object: any, keys: string[]): void;
export declare function adaptOptions(shellToCommand: any, additions: any, shellDoc: any): any;
export declare function processDigestPassword(username: string, passwordDigestor: 'server' | 'client', command: {
    pwd: string;
}): {
    digestPassword?: boolean;
    pwd?: string;
};
export declare function getPrintableShardStatus(configDB: Database, verbose: boolean): Promise<Document>;
export declare function getConfigDB(db: Database): Promise<Database>;
declare type AnyBsonNumber = number | typeof bson.Long.prototype | typeof bson.Int32.prototype | typeof bson.Double.prototype;
export declare function coerceToJSNumber(n: AnyBsonNumber): number;
export declare function dataFormat(bytes?: number): string;
export declare function scaleIndividualShardStatistics(shardStats: Document, scale: number): Document;
export declare function tsToSeconds(x: typeof bson.Timestamp.prototype | number | {
    valueOf(): number;
}): number;
export declare function addHiddenDataProperty<T = any>(target: T, key: string | symbol, value: any): T;
export declare function iterate(results: CursorIterationResult, cursor: AbstractCursor<any> | ChangeStreamCursor, batchSize: number): Promise<CursorIterationResult>;
export declare type FindAndModifyMethodShellOptions = {
    query: Document;
    sort?: (FindOneAndDeleteOptions | FindOneAndReplaceOptions | FindOneAndUpdateOptions)['sort'];
    update?: Document | Document[];
    remove?: boolean;
    new?: boolean;
    fields?: Document;
    upsert?: boolean;
    bypassDocumentValidation?: boolean;
    writeConcern?: Document;
    collation?: (FindOneAndDeleteOptions | FindOneAndReplaceOptions | FindOneAndUpdateOptions)['collation'];
    arrayFilters?: Document[];
    explain?: ExplainVerbosityLike;
};
export declare type FindAndModifyShellOptions<BaseOptions extends FindOneAndReplaceOptions | FindOneAndUpdateOptions> = BaseOptions & {
    returnOriginal?: boolean;
    returnNewDocument?: boolean;
    new?: boolean;
};
export declare function processFindAndModifyOptions<BaseOptions extends FindOneAndReplaceOptions | FindOneAndUpdateOptions>(options: FindAndModifyShellOptions<BaseOptions>): BaseOptions;
export declare type RemoveShellOptions = DeleteOptions & {
    justOne?: boolean;
};
export declare function processRemoveOptions(options: boolean | RemoveShellOptions): RemoveShellOptions;
export declare type MapReduceShellOptions = Document | string;
export declare function processMapReduceOptions(optionsOrOutString: MapReduceShellOptions): MapReduceOptions;
export declare function setHideIndex(coll: Collection, index: string | Document, hidden: boolean): Promise<Document>;
export declare function assertCLI(platform: ReplPlatform, features: string): void;
export declare function processFLEOptions(fleOptions: ClientSideFieldLevelEncryptionOptions): AutoEncryptionOptions;
declare type NotAPromise = {
    [key: string]: any;
    then?: never;
};
export declare function maybeMarkAsExplainOutput<T extends NotAPromise>(value: T, options: ExplainOptions): T;
export declare function markAsExplainOutput<T extends NotAPromise>(value: T): T;
export declare function isValidDatabaseName(name: string): boolean;
export declare function isValidCollectionName(name: string): boolean;
export declare function shouldRunAggregationImmediately(pipeline: Document[]): boolean;
export declare function adjustRunCommand(cmd: Document, shellBson: ShellBson): Document;
export declare function getBadge(collections: Document[], index: number): string;
export declare function shallowClone<T>(input: T): T;
export declare function functionCtor<T extends Function & {
    new (...args: any): any;
}>(ClassCtor: T): T;
export declare function assignAll<T extends {}, U extends {}>(t: T, u: U): T & U;
export declare function assignAll<T extends {}, U extends {}, V extends {}>(t: T, u: U, v: V): T & U & V;
export declare function assignAll<T extends {}, U extends {}, V extends {}, W extends {}>(t: T, u: U, v: V, w: W): T & U & V & W;
export declare function buildConfigChunksCollectionMatch(configCollectionsInfo: Document): Document;
export {};
