import Mongo from './mongo';
import Collection from './collection';
import { ShellApiWithMongoClass } from './decorators';
import { asPrintable } from './enums';
import type { ChangeStreamOptions, CommandOperationOptions, CreateCollectionOptions, Document, WriteConcern, ListCollectionsOptions } from '@mongosh/service-provider-core';
import { AggregationCursor, RunCommandCursor, CommandResult } from './index';
import Session from './session';
import ChangeStreamCursor from './change-stream-cursor';
import { CreateEncryptedCollectionOptions, CheckMetadataConsistencyOptions } from '@mongosh/service-provider-core';
export declare type CollectionNamesWithTypes = {
    name: string;
    badge: string;
};
declare type AuthDoc = {
    user: string;
    pwd: string;
    authDb?: string;
    mechanism?: string;
};
export default class Database extends ShellApiWithMongoClass {
    _mongo: Mongo;
    _name: string;
    _collections: Record<string, Collection>;
    _session: Session | undefined;
    _cachedCollectionNames: string[];
    _cachedHello: Document | null;
    constructor(mongo: Mongo, name: string, session?: Session);
    _baseOptions(): Promise<CommandOperationOptions>;
    _maybeCachedHello(): Promise<Document>;
    [asPrintable](): string;
    private _emitDatabaseApiCall;
    _runCommand(cmd: Document, options?: CommandOperationOptions): Promise<Document>;
    _runAdminCommand(cmd: Document, options?: CommandOperationOptions): Promise<Document>;
    _runCursorCommand(cmd: Document, options?: CommandOperationOptions): Promise<RunCommandCursor>;
    _runAdminCursorCommand(cmd: Document, options?: CommandOperationOptions): Promise<RunCommandCursor>;
    _listCollections(filter: Document, options: ListCollectionsOptions): Promise<Document[]>;
    _getCollectionNames(options?: ListCollectionsOptions): Promise<string[]>;
    _getCollectionNamesWithTypes(options?: ListCollectionsOptions): Promise<CollectionNamesWithTypes[]>;
    _getCollectionNamesForCompletion(): Promise<string[]>;
    _getLastErrorObj(w?: number | string, wTimeout?: number, j?: boolean): Promise<Document>;
    getMongo(): Mongo;
    getName(): string;
    getCollectionNames(): Promise<string[]>;
    getCollectionInfos(filter?: Document, options?: ListCollectionsOptions): Promise<Document[]>;
    runCommand(cmd: string | Document): Promise<Document>;
    adminCommand(cmd: string | Document): Promise<Document>;
    aggregate(pipeline: Document[], options?: Document): Promise<AggregationCursor>;
    getSiblingDB(db: string): Database;
    getCollection(coll: string): Collection;
    dropDatabase(writeConcern?: WriteConcern): Promise<Document>;
    createUser(user: Document, writeConcern?: WriteConcern): Promise<Document>;
    updateUser(username: string, userDoc: Document, writeConcern?: WriteConcern): Promise<Document>;
    changeUserPassword(username: string, password: string, writeConcern?: WriteConcern): Promise<Document>;
    logout(): Promise<Document>;
    dropUser(username: string, writeConcern?: WriteConcern): Promise<Document>;
    dropAllUsers(writeConcern?: WriteConcern): Promise<Document>;
    auth(...args: [AuthDoc] | [string, string] | [string]): Promise<{
        ok: number;
    }>;
    grantRolesToUser(username: string, roles: any[], writeConcern?: WriteConcern): Promise<Document>;
    revokeRolesFromUser(username: string, roles: any[], writeConcern?: WriteConcern): Promise<Document>;
    getUser(username: string, options?: Document): Promise<Document | null>;
    getUsers(options?: Document): Promise<Document>;
    createCollection(name: string, options?: CreateCollectionOptions): Promise<{
        ok: number;
    }>;
    createEncryptedCollection(name: string, options: CreateEncryptedCollectionOptions): Promise<{
        collection: Collection;
        encryptedFields: Document;
    }>;
    createView(name: string, source: string, pipeline: Document[], options?: CreateCollectionOptions): Promise<{
        ok: number;
    }>;
    createRole(role: Document, writeConcern?: WriteConcern): Promise<Document>;
    updateRole(rolename: string, roleDoc: Document, writeConcern?: WriteConcern): Promise<Document>;
    dropRole(rolename: string, writeConcern?: WriteConcern): Promise<Document>;
    dropAllRoles(writeConcern?: WriteConcern): Promise<Document>;
    grantRolesToRole(rolename: string, roles: any[], writeConcern?: WriteConcern): Promise<Document>;
    revokeRolesFromRole(rolename: string, roles: any[], writeConcern?: WriteConcern): Promise<Document>;
    grantPrivilegesToRole(rolename: string, privileges: any[], writeConcern?: WriteConcern): Promise<Document>;
    revokePrivilegesFromRole(rolename: string, privileges: any[], writeConcern?: WriteConcern): Promise<Document>;
    getRole(rolename: string, options?: Document): Promise<Document | null>;
    getRoles(options?: Document): Promise<Document>;
    _getCurrentOperations(opts: Document | boolean): Promise<Document[]>;
    currentOp(opts?: Document | boolean): Promise<Document>;
    killOp(opId: number): Promise<Document>;
    shutdownServer(opts?: Document): Promise<Document>;
    fsyncLock(): Promise<Document>;
    fsyncUnlock(): Promise<Document>;
    version(): Promise<string>;
    serverBits(): Promise<Document>;
    isMaster(): Promise<Document>;
    hello(): Promise<Document>;
    serverBuildInfo(): Promise<Document>;
    serverStatus(opts?: {}): Promise<Document>;
    stats(scaleOrOptions?: number | Document): Promise<Document>;
    hostInfo(): Promise<Document>;
    serverCmdLineOpts(): Promise<Document>;
    rotateCertificates(message?: string): Promise<Document>;
    printCollectionStats(scale?: number): Promise<Document>;
    getFreeMonitoringStatus(): Promise<Document>;
    disableFreeMonitoring(): Promise<Document>;
    enableFreeMonitoring(): Promise<Document | string>;
    getProfilingStatus(): Promise<Document>;
    setProfilingLevel(level: number, opts?: number | Document): Promise<Document>;
    setLogLevel(logLevel: number, component?: Document | string): Promise<Document>;
    getLogComponents(): Promise<Document>;
    cloneDatabase(): void;
    cloneCollection(): void;
    copyDatabase(): void;
    commandHelp(name: string): Promise<Document>;
    listCommands(): Promise<CommandResult>;
    getLastErrorObj(w?: number | string, wTimeout?: number, j?: boolean): Promise<Document>;
    getLastError(w?: number | string, wTimeout?: number): Promise<Document | null>;
    printShardingStatus(verbose?: boolean): Promise<CommandResult>;
    printSecondaryReplicationInfo(): Promise<CommandResult>;
    getReplicationInfo(): Promise<Document>;
    printReplicationInfo(): Promise<CommandResult>;
    printSlaveReplicationInfo(): never;
    setSecondaryOk(): Promise<void>;
    watch(pipeline?: Document[] | ChangeStreamOptions, options?: ChangeStreamOptions): Promise<ChangeStreamCursor>;
    sql(sqlString: string, options?: Document): Promise<AggregationCursor>;
    checkMetadataConsistency(options?: CheckMetadataConsistencyOptions): Promise<RunCommandCursor>;
}
export {};
