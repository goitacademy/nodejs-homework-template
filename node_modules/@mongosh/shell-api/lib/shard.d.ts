import Database from './database';
import { ShellApiWithMongoClass } from './decorators';
import type { Document, CheckMetadataConsistencyOptions } from '@mongosh/service-provider-core';
import { asPrintable } from './enums';
import { CommandResult, UpdateResult } from './result';
import Mongo from './mongo';
import AggregationCursor from './aggregation-cursor';
import RunCommandCursor from './run-command-cursor';
export default class Shard extends ShellApiWithMongoClass {
    _database: Database;
    constructor(database: Database);
    get _mongo(): Mongo;
    [asPrintable](): string;
    private _emitShardApiCall;
    enableSharding(database: string, primaryShard?: string): Promise<Document>;
    commitReshardCollection(namespace: string): Promise<Document>;
    abortReshardCollection(namespace: string): Promise<Document>;
    shardCollection(namespace: string, key: Document, unique?: boolean | Document, options?: Document): Promise<Document>;
    reshardCollection(namespace: string, key: Document, unique?: boolean | Document, options?: Document): Promise<Document>;
    _runShardCollection(command: 'shardCollection' | 'reshardCollection', namespace: string, key: Document, unique?: boolean | Document, options?: Document): Promise<Document>;
    status(verbose?: boolean, configDB?: Database): Promise<CommandResult<Document>>;
    addShard(url: string): Promise<Document>;
    addShardToZone(shard: string, zone: string): Promise<Document>;
    addShardTag(shard: string, tag: string): Promise<Document>;
    updateZoneKeyRange(namespace: string, min: Document, max: Document, zone: string | null): Promise<Document>;
    addTagRange(namespace: string, min: Document, max: Document, zone: string): Promise<Document>;
    removeRangeFromZone(ns: string, min: Document, max: Document): Promise<Document>;
    removeTagRange(ns: string, min: Document, max: Document): Promise<Document>;
    removeShardFromZone(shard: string, zone: string): Promise<Document>;
    removeShardTag(shard: string, tag: string): Promise<Document>;
    enableAutoSplit(): Promise<UpdateResult>;
    disableAutoSplit(): Promise<UpdateResult>;
    splitAt(ns: string, query: Document): Promise<Document>;
    splitFind(ns: string, query: Document): Promise<Document>;
    moveChunk(ns: string, query: Document, destination: string | undefined): Promise<Document>;
    balancerCollectionStatus(ns: string): Promise<Document>;
    enableBalancing(ns: string): Promise<UpdateResult>;
    disableBalancing(ns: string): Promise<UpdateResult>;
    getBalancerState(): Promise<boolean>;
    isBalancerRunning(): Promise<Document>;
    startBalancer(timeout?: number): Promise<Document>;
    stopBalancer(timeout?: number): Promise<Document>;
    setBalancerState(state: boolean): Promise<Document>;
    getShardedDataDistribution(options?: {}): Promise<AggregationCursor>;
    startAutoMerger(): Promise<UpdateResult>;
    stopAutoMerger(): Promise<UpdateResult>;
    isAutoMergerEnabled(): Promise<boolean>;
    disableAutoMerger(ns: string): Promise<UpdateResult>;
    enableAutoMerger(ns: string): Promise<UpdateResult>;
    checkMetadataConsistency(options?: CheckMetadataConsistencyOptions): Promise<RunCommandCursor>;
}
