"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("./decorators");
const result_1 = require("./result");
const enums_1 = require("./enums");
const errors_1 = require("@mongosh/errors");
const helpers_1 = require("./helpers");
let ChangeStreamCursor = class ChangeStreamCursor extends decorators_1.ShellApiWithMongoClass {
    constructor(cursor, on, mongo) {
        super();
        this._currentIterationResult = null;
        this._cursor = cursor;
        this._on = on;
        this._mongo = mongo;
    }
    async _it() {
        if (this._cursor.closed) {
            throw new errors_1.MongoshRuntimeError('ChangeStreamCursor is closed');
        }
        const result = this._currentIterationResult = new result_1.CursorIterationResult();
        return (0, helpers_1.iterate)(result, this, await this._mongo._displayBatchSize());
    }
    [enums_1.asPrintable]() {
        return `ChangeStreamCursor on ${this._on}`;
    }
    async close() {
        await this._cursor.close();
    }
    async hasNext() {
        await this._instanceState.printWarning('If there are no documents in the batch, hasNext will block. Use tryNext if you want to check if there ' +
            'are any documents without waiting.');
        return this._cursor.hasNext();
    }
    async tryNext() {
        if (this._cursor.closed) {
            throw new errors_1.MongoshRuntimeError('Cannot call tryNext on closed cursor');
        }
        return this._cursor.tryNext();
    }
    async *[Symbol.asyncIterator]() {
        let doc;
        while ((doc = await this.tryNext()) !== null) {
            yield doc;
        }
    }
    isClosed() {
        return this._cursor.closed;
    }
    isExhausted() {
        throw new errors_1.MongoshInvalidInputError('isExhausted is not implemented for ChangeStreams because after closing a cursor, the remaining documents in the batch are no longer accessible. If you want to see if the cursor is closed use isClosed. If you want to see if there are documents left in the batch, use tryNext.');
    }
    async itcount() {
        let count = 0;
        while (await this.tryNext()) {
            count++;
        }
        return count;
    }
    async next() {
        await this._instanceState.printWarning('If there are no documents in the batch, next will block. Use tryNext if you want to check if there are ' +
            'any documents without waiting.');
        return this._cursor.next();
    }
    getResumeToken() {
        return this._cursor.resumeToken;
    }
    map() {
        throw new errors_1.MongoshUnimplementedError('Cannot call map on a change stream cursor');
    }
    forEach() {
        throw new errors_1.MongoshUnimplementedError('Cannot call forEach on a change stream cursor');
    }
    toArray() {
        throw new errors_1.MongoshUnimplementedError('Cannot call toArray on a change stream cursor');
    }
    objsLeftInBatch() {
        throw new errors_1.MongoshUnimplementedError('Cannot call objsLeftInBatch on a change stream cursor');
    }
    pretty() {
        return this;
    }
};
__decorate([
    decorators_1.returnsPromise
], ChangeStreamCursor.prototype, "close", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated
], ChangeStreamCursor.prototype, "hasNext", null);
__decorate([
    decorators_1.returnsPromise
], ChangeStreamCursor.prototype, "tryNext", null);
__decorate([
    decorators_1.returnsPromise
], ChangeStreamCursor.prototype, "itcount", null);
__decorate([
    decorators_1.returnsPromise
], ChangeStreamCursor.prototype, "next", null);
__decorate([
    (0, decorators_1.returnType)('ChangeStreamCursor')
], ChangeStreamCursor.prototype, "pretty", null);
ChangeStreamCursor = __decorate([
    decorators_1.shellApiClassDefault
], ChangeStreamCursor);
exports.default = ChangeStreamCursor;
//# sourceMappingURL=change-stream-cursor.js.map