import { ShellApiClass } from './decorators';
import { ChangeStreamOptions, Document, ListDatabasesOptions, ReadConcernLevel, ReadPreference, ReadPreferenceLike, ReadPreferenceMode, ServiceProvider, AutoEncryptionOptions as SPAutoEncryption, ServerApi, ServerApiVersion, WriteConcern } from '@mongosh/service-provider-core';
import { ConnectionInfo } from '@mongosh/arg-parser';
import type Collection from './collection';
import Database from './database';
import ShellInstanceState from './shell-instance-state';
import { CommandResult } from './result';
import { asPrintable } from './enums';
import Session from './session';
import ChangeStreamCursor from './change-stream-cursor';
import { ClientSideFieldLevelEncryptionOptions, KeyVault, ClientEncryption } from './field-level-encryption';
export default class Mongo extends ShellApiClass {
    private __serviceProvider;
    _databases: Record<string, Database>;
    _instanceState: ShellInstanceState;
    _connectionInfo: ConnectionInfo;
    private _explicitEncryptionOnly;
    private _keyVault;
    private _clientEncryption;
    private _readPreferenceWasExplicitlyRequested;
    private _cachedDatabaseNames;
    constructor(instanceState: ShellInstanceState, uri?: string | Mongo, fleOptions?: ClientSideFieldLevelEncryptionOptions, otherOptions?: {
        api?: ServerApi | ServerApiVersion;
    }, sp?: ServiceProvider);
    get _uri(): string;
    get _fleOptions(): SPAutoEncryption | undefined;
    get _serviceProvider(): ServiceProvider;
    set _serviceProvider(sp: ServiceProvider);
    _displayBatchSize(): Promise<number>;
    [asPrintable](): string;
    private _emitMongoApiCall;
    connect(username?: string, password?: string): Promise<void>;
    _getDb(name: string): Database;
    getDB(db: string): Database;
    getCollection(name: string): Collection;
    getURI(): string;
    use(db: string): string;
    _listDatabases(opts?: ListDatabasesOptions): Promise<{
        databases: {
            name: string;
            sizeOnDisk: number;
            empty: boolean;
        }[];
    }>;
    _getDatabaseNamesForCompletion(): Promise<string[]>;
    getDBs(options?: ListDatabasesOptions): Promise<{
        databases: {
            name: string;
            sizeOnDisk: number;
            empty: boolean;
        }[];
    }>;
    getDBNames(options?: ListDatabasesOptions): Promise<string[]>;
    show(cmd: string, arg?: string): Promise<CommandResult>;
    close(force: boolean): Promise<void>;
    _suspend(): Promise<() => Promise<void>>;
    getReadPrefMode(): ReadPreferenceMode;
    getReadPrefTagSet(): Record<string, string>[] | undefined;
    getReadPref(): ReadPreference;
    _getExplicitlyRequestedReadPref(): {
        readPreference: ReadPreference;
    } | undefined;
    getReadConcern(): string | undefined;
    getWriteConcern(): WriteConcern | undefined;
    setReadPref(mode: ReadPreferenceLike, tagSet?: Record<string, string>[], hedgeOptions?: Document): Promise<void>;
    setReadConcern(level: ReadConcernLevel): Promise<void>;
    setWriteConcern(concern: WriteConcern): Promise<void>;
    setWriteConcern(wValue: string | number, wtimeoutMSValue?: number | undefined, jValue?: boolean | undefined): Promise<void>;
    startSession(options?: Document): Session;
    setCausalConsistency(): void;
    isCausalConsistency(): void;
    setSlaveOk(): void;
    setSecondaryOk(): Promise<void>;
    watch(pipeline?: Document[] | ChangeStreamOptions, options?: ChangeStreamOptions): Promise<ChangeStreamCursor>;
    getClientEncryption(): ClientEncryption;
    getKeyVault(): Promise<KeyVault>;
    convertShardKeyToHashed(value: any): Promise<unknown>;
}
