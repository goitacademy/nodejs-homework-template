/// <reference types="node" />
import { ShellApiWithMongoClass } from './decorators';
import { ClientEncryption as MongoCryptClientEncryption, ClientEncryptionDataKeyProvider, ClientEncryptionEncryptOptions, ClientEncryptionTlsOptions, KMSProviders, AWSEncryptionKeyOptions, AzureEncryptionKeyOptions, GCPEncryptionKeyOptions } from '@mongosh/service-provider-core';
import type { Document, BinaryType } from '@mongosh/service-provider-core';
import Collection from './collection';
import Cursor from './cursor';
import { DeleteResult } from './result';
import { asPrintable } from './enums';
import type Mongo from './mongo';
import type { CreateEncryptedCollectionOptions } from '@mongosh/service-provider-core';
export declare type ClientSideFieldLevelEncryptionKmsProvider = Omit<KMSProviders, 'local'> & {
    local?: {
        key: Buffer | string | BinaryType;
    };
};
export interface ClientSideFieldLevelEncryptionOptions {
    keyVaultClient?: Mongo;
    keyVaultNamespace: string;
    kmsProviders: ClientSideFieldLevelEncryptionKmsProvider;
    schemaMap?: Document;
    bypassAutoEncryption?: boolean;
    explicitEncryptionOnly?: boolean;
    tlsOptions?: {
        [k in keyof ClientSideFieldLevelEncryptionKmsProvider]?: ClientEncryptionTlsOptions;
    };
    encryptedFieldsMap?: Document;
    bypassQueryAnalysis?: boolean;
}
declare type MasterKey = AWSEncryptionKeyOptions | AzureEncryptionKeyOptions | GCPEncryptionKeyOptions;
declare type AltNames = string[];
declare type DataKeyEncryptionKeyOptions = {
    masterKey?: MasterKey;
    keyAltNames?: AltNames;
    keyMaterial?: Buffer | BinaryType;
};
export declare class ClientEncryption extends ShellApiWithMongoClass {
    _mongo: Mongo;
    _libmongocrypt: MongoCryptClientEncryption;
    constructor(mongo: Mongo);
    [asPrintable](): string;
    encrypt(keyId: BinaryType, value: any, algorithmOrEncryptionOptions: ClientEncryptionEncryptOptions['algorithm'] | ClientEncryptionEncryptOptions): Promise<BinaryType>;
    decrypt(encryptedValue: BinaryType): Promise<any>;
    encryptExpression(keyId: BinaryType, value: Document, options: ClientEncryptionEncryptOptions): Promise<Document>;
    createEncryptedCollection(dbName: string, collName: string, options: CreateEncryptedCollectionOptions): Promise<{
        collection: Collection;
        encryptedFields: Document;
    }>;
}
export declare class KeyVault extends ShellApiWithMongoClass {
    _mongo: Mongo;
    _clientEncryption: ClientEncryption;
    private _keyColl;
    constructor(clientEncryption: ClientEncryption);
    _init(): Promise<void>;
    [asPrintable](): string;
    createKey(kms: 'local', keyAltNames?: string[]): Promise<BinaryType>;
    createKey(kms: ClientEncryptionDataKeyProvider, legacyMasterKey: string, keyAltNames?: string[]): Promise<BinaryType>;
    createKey(kms: ClientEncryptionDataKeyProvider, options: MasterKey | DataKeyEncryptionKeyOptions | undefined): Promise<BinaryType>;
    createKey(kms: ClientEncryptionDataKeyProvider, options: MasterKey | DataKeyEncryptionKeyOptions | undefined, keyAltNames: string[]): Promise<BinaryType>;
    getKey(keyId: BinaryType): Promise<Document>;
    getKeyByAltName(keyAltName: string): Promise<Document>;
    getKeys(): Promise<Cursor>;
    deleteKey(keyId: BinaryType): Promise<DeleteResult | Document>;
    addKeyAlternateName(keyId: BinaryType, keyAltName: string): Promise<Document | null>;
    removeKeyAlternateName(keyId: BinaryType, keyAltName: string): Promise<Document | null>;
    rewrapManyDataKey(filter: Document, options?: Document): Promise<Document>;
    createDataKey(...args: Parameters<KeyVault['createKey']>): ReturnType<KeyVault['createKey']>;
    removeKeyAltName(...args: Parameters<KeyVault['removeKeyAlternateName']>): ReturnType<KeyVault['removeKeyAlternateName']>;
    addKeyAltName(...args: Parameters<KeyVault['addKeyAlternateName']>): ReturnType<KeyVault['addKeyAlternateName']>;
}
export {};
