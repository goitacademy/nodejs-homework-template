"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addSourceToResults = exports.classPlatforms = exports.platforms = exports.classDeprecated = exports.returnType = exports.shellCommandCompleter = exports.directShellCommand = exports.returnsPromise = exports.nonAsyncFunctionsReturningPromises = exports.topologies = exports.deprecated = exports.apiVersions = exports.serverVersions = exports.shellApiClassNoHelp = exports.shellApiClassDefault = exports.toIgnore = exports.signatures = exports.toShellResult = exports.getShellApiType = exports.ShellApiValueClass = exports.ShellApiWithMongoClass = exports.ShellApiClass = void 0;
const errors_1 = require("@mongosh/errors");
const enums_1 = require("./enums");
const help_1 = __importDefault(require("./help"));
const helpers_1 = require("./helpers");
const addSourceToResultsSymbol = Symbol.for('@@mongosh.addSourceToResults');
const resultSource = Symbol.for('@@mongosh.resultSource');
class ShellApiClass {
    get [enums_1.shellApiType]() {
        throw new errors_1.MongoshInternalError('Shell API Type did not use decorators');
    }
    set [enums_1.shellApiType](value) {
        (0, helpers_1.addHiddenDataProperty)(this, enums_1.shellApiType, value);
    }
    [enums_1.asPrintable]() {
        if (Array.isArray(this)) {
            return [...this];
        }
        return { ...this };
    }
}
exports.ShellApiClass = ShellApiClass;
class ShellApiWithMongoClass extends ShellApiClass {
    get _instanceState() {
        var _a;
        return (_a = this._mongo) === null || _a === void 0 ? void 0 : _a._instanceState;
    }
}
exports.ShellApiWithMongoClass = ShellApiWithMongoClass;
class ShellApiValueClass extends ShellApiClass {
    get _mongo() {
        throw new errors_1.MongoshInternalError('Not supported on this value class');
    }
    get _instanceState() {
        throw new errors_1.MongoshInternalError('Not supported on this value class');
    }
}
exports.ShellApiValueClass = ShellApiValueClass;
function getShellApiType(rawValue) {
    var _a;
    return (_a = rawValue === null || rawValue === void 0 ? void 0 : rawValue[enums_1.shellApiType]) !== null && _a !== void 0 ? _a : null;
}
exports.getShellApiType = getShellApiType;
async function toShellResult(rawValue) {
    var _a;
    if ((typeof rawValue !== 'object' && typeof rawValue !== 'function') || rawValue === null) {
        return {
            type: null,
            rawValue: rawValue,
            printable: rawValue
        };
    }
    if ('then' in rawValue && typeof rawValue.then === 'function') {
        return toShellResult(await rawValue);
    }
    const printable = typeof rawValue[enums_1.asPrintable] === 'function' ? await rawValue[enums_1.asPrintable]() : rawValue;
    const source = (_a = rawValue[resultSource]) !== null && _a !== void 0 ? _a : undefined;
    return {
        type: getShellApiType(rawValue),
        rawValue: rawValue,
        printable: printable,
        source: source
    };
}
exports.toShellResult = toShellResult;
function wrapWithAddSourceToResult(fn) {
    function addSource(result, obj) {
        if (typeof result === 'object' && result !== null) {
            const resultSourceInformation = {
                namespace: obj[enums_1.namespaceInfo](),
            };
            (0, helpers_1.addHiddenDataProperty)(result, resultSource, resultSourceInformation);
            if (result[enums_1.shellApiType] === undefined && fn.returnType) {
                (0, helpers_1.addHiddenDataProperty)(result, enums_1.shellApiType, fn.returnType);
            }
        }
        return result;
    }
    const wrapper = fn.returnsPromise ?
        markImplicitlyAwaited(async function (...args) {
            return addSource(await fn.call(this, ...args), this);
        }) : function (...args) {
        return addSource(fn.call(this, ...args), this);
    };
    Object.setPrototypeOf(wrapper, Object.getPrototypeOf(fn));
    Object.defineProperties(wrapper, Object.getOwnPropertyDescriptors(fn));
    return wrapper;
}
function wrapWithApiChecks(fn, className) {
    const wrapper = fn.returnsPromise ?
        markImplicitlyAwaited(async function (...args) {
            var _a, _b;
            const instanceState = getShellInstanceState(this);
            emitApiCallTelemetry(instanceState, className, fn, true);
            const interruptFlag = instanceState === null || instanceState === void 0 ? void 0 : instanceState.interrupted;
            interruptFlag === null || interruptFlag === void 0 ? void 0 : interruptFlag.checkpoint();
            const interrupt = interruptFlag === null || interruptFlag === void 0 ? void 0 : interruptFlag.asPromise();
            let result;
            try {
                if (instanceState) {
                    instanceState.apiCallDepth++;
                }
                result = await Promise.race([
                    (_a = interrupt === null || interrupt === void 0 ? void 0 : interrupt.promise) !== null && _a !== void 0 ? _a : new Promise(() => { }),
                    fn.call(this, ...args)
                ]);
            }
            catch (e) {
                throw (_b = instanceState === null || instanceState === void 0 ? void 0 : instanceState.transformError(e)) !== null && _b !== void 0 ? _b : e;
            }
            finally {
                if (instanceState) {
                    instanceState.apiCallDepth--;
                }
                if (interrupt) {
                    interrupt.destroy();
                }
            }
            interruptFlag === null || interruptFlag === void 0 ? void 0 : interruptFlag.checkpoint();
            return result;
        }) : function (...args) {
        var _a;
        const instanceState = getShellInstanceState(this);
        emitApiCallTelemetry(instanceState, className, fn, false);
        const interruptFlag = instanceState === null || instanceState === void 0 ? void 0 : instanceState.interrupted;
        interruptFlag === null || interruptFlag === void 0 ? void 0 : interruptFlag.checkpoint();
        let result;
        try {
            if (instanceState) {
                instanceState.apiCallDepth++;
            }
            result = fn.call(this, ...args);
        }
        catch (e) {
            throw (_a = instanceState === null || instanceState === void 0 ? void 0 : instanceState.transformError(e)) !== null && _a !== void 0 ? _a : e;
        }
        finally {
            if (instanceState) {
                instanceState.apiCallDepth--;
            }
        }
        interruptFlag === null || interruptFlag === void 0 ? void 0 : interruptFlag.checkpoint();
        return result;
    };
    Object.setPrototypeOf(wrapper, Object.getPrototypeOf(fn));
    Object.defineProperties(wrapper, Object.getOwnPropertyDescriptors(fn));
    return wrapper;
}
function emitApiCallTelemetry(instanceState, className, fn, isAsync) {
    var _a;
    (_a = instanceState === null || instanceState === void 0 ? void 0 : instanceState.emitApiCall) === null || _a === void 0 ? void 0 : _a.call(instanceState, {
        method: fn.name,
        class: className,
        deprecated: !!fn.deprecated,
        isAsync
    });
}
function getShellInstanceState(apiObject) {
    if (!apiObject[enums_1.shellApiType]) {
        throw new errors_1.MongoshInternalError('getShellInstanceState can only be called for functions from shell API classes');
    }
    return apiObject._instanceState;
}
const signaturesGlobalIdentifier = '@@@mdb.signatures@@@';
if (!global[signaturesGlobalIdentifier]) {
    global[signaturesGlobalIdentifier] = {};
}
const signatures = global[signaturesGlobalIdentifier];
exports.signatures = signatures;
signatures.Document = { type: 'Document', attributes: {} };
exports.toIgnore = ['constructor', 'help', 'toJSON'];
function shellApiClassGeneric(constructor, hasHelp) {
    const className = constructor.name;
    const classHelpKeyPrefix = `shell-api.classes.${className}.help`;
    const classHelp = {
        help: `${classHelpKeyPrefix}.description`,
        docs: `${classHelpKeyPrefix}.link`,
        attr: []
    };
    const classSignature = {
        type: className,
        returnsPromise: constructor.prototype.returnsPromise || false,
        deprecated: constructor.prototype.deprecated || false,
        attributes: {}
    };
    const classAttributes = Object.getOwnPropertyNames(constructor.prototype);
    for (const propertyName of classAttributes) {
        const descriptor = Object.getOwnPropertyDescriptor(constructor.prototype, propertyName);
        const isMethod = (descriptor === null || descriptor === void 0 ? void 0 : descriptor.value) && typeof descriptor.value === 'function';
        if (!isMethod ||
            exports.toIgnore.includes(propertyName) ||
            propertyName.startsWith('_'))
            continue;
        let method = descriptor.value;
        if (constructor[addSourceToResultsSymbol]) {
            method = wrapWithAddSourceToResult(method);
        }
        method = wrapWithApiChecks(method, className);
        method.serverVersions = method.serverVersions || enums_1.ALL_SERVER_VERSIONS;
        method.apiVersions = method.apiVersions || enums_1.ALL_API_VERSIONS;
        method.topologies = method.topologies || enums_1.ALL_TOPOLOGIES;
        method.returnType = method.returnType || { type: 'unknown', attributes: {} };
        method.returnsPromise = method.returnsPromise || false;
        method.deprecated = method.deprecated || false;
        method.platforms = method.platforms || enums_1.ALL_PLATFORMS;
        method.isDirectShellCommand = method.isDirectShellCommand || false;
        method.acceptsRawInput = method.acceptsRawInput || false;
        method.shellCommandCompleter = method.shellCommandCompleter || undefined;
        classSignature.attributes[propertyName] = {
            type: 'function',
            serverVersions: method.serverVersions,
            apiVersions: method.apiVersions,
            topologies: method.topologies,
            returnType: method.returnType === 'this' ? className : method.returnType,
            returnsPromise: method.returnsPromise,
            deprecated: method.deprecated,
            platforms: method.platforms,
            isDirectShellCommand: method.isDirectShellCommand,
            acceptsRawInput: method.acceptsRawInput,
            shellCommandCompleter: method.shellCommandCompleter
        };
        const attributeHelpKeyPrefix = `${classHelpKeyPrefix}.attributes.${propertyName}`;
        const attrHelp = {
            help: `${attributeHelpKeyPrefix}.example`,
            docs: `${attributeHelpKeyPrefix}.link`,
            attr: [
                { description: `${attributeHelpKeyPrefix}.description` }
            ]
        };
        const aHelp = new help_1.default(attrHelp);
        method.help = () => (aHelp);
        Object.setPrototypeOf(method.help, aHelp);
        classHelp.attr.push({
            name: propertyName,
            description: `${attributeHelpKeyPrefix}.description`
        });
        Object.defineProperty(constructor.prototype, propertyName, {
            ...descriptor,
            value: method
        });
    }
    let superClass = constructor.prototype;
    while ((superClass = Object.getPrototypeOf(superClass)) !== null) {
        if (superClass.constructor.name === 'ShellApiClass' || superClass.constructor === Array) {
            break;
        }
        const superClassHelpKeyPrefix = `shell-api.classes.${superClass.constructor.name}.help`;
        for (const propertyName of Object.getOwnPropertyNames(superClass)) {
            const descriptor = Object.getOwnPropertyDescriptor(superClass, propertyName);
            const isMethod = (descriptor === null || descriptor === void 0 ? void 0 : descriptor.value) && typeof descriptor.value === 'function';
            if (classAttributes.includes(propertyName) ||
                !isMethod ||
                exports.toIgnore.includes(propertyName) ||
                propertyName.startsWith('_'))
                continue;
            const method = descriptor.value;
            classSignature.attributes[propertyName] = {
                type: 'function',
                serverVersions: method.serverVersions,
                apiVersions: method.apiVersions,
                topologies: method.topologies,
                returnType: method.returnType === 'this' ? className : method.returnType,
                returnsPromise: method.returnsPromise,
                deprecated: method.deprecated,
                platforms: method.platforms,
                isDirectShellCommand: method.isDirectShellCommand,
                acceptsRawInput: method.acceptsRawInput,
                shellCommandCompleter: method.shellCommandCompleter
            };
            const attributeHelpKeyPrefix = `${superClassHelpKeyPrefix}.attributes.${propertyName}`;
            classHelp.attr.push({
                name: propertyName,
                description: `${attributeHelpKeyPrefix}.description`
            });
        }
    }
    const help = new help_1.default(classHelp);
    constructor.prototype.help = () => (help);
    Object.setPrototypeOf(constructor.prototype.help, help);
    constructor.prototype[enums_1.asPrintable] =
        constructor.prototype[enums_1.asPrintable] ||
            ShellApiClass.prototype[enums_1.asPrintable];
    (0, helpers_1.addHiddenDataProperty)(constructor.prototype, enums_1.shellApiType, className);
    if (hasHelp) {
        signatures[className] = classSignature;
    }
}
function shellApiClassDefault(constructor) {
    shellApiClassGeneric(constructor, true);
}
exports.shellApiClassDefault = shellApiClassDefault;
function shellApiClassNoHelp(constructor) {
    shellApiClassGeneric(constructor, false);
}
exports.shellApiClassNoHelp = shellApiClassNoHelp;
function markImplicitlyAwaited(orig) {
    function wrapper(...args) {
        const origResult = orig.call(this, ...args);
        return (0, helpers_1.addHiddenDataProperty)(origResult, Symbol.for('@@mongosh.syntheticPromise'), true);
    }
    Object.setPrototypeOf(wrapper, Object.getPrototypeOf(orig));
    Object.defineProperties(wrapper, Object.getOwnPropertyDescriptors(orig));
    return wrapper;
}
function serverVersions(versionArray) {
    return function (_target, _propertyKey, descriptor) {
        descriptor.value.serverVersions = versionArray;
    };
}
exports.serverVersions = serverVersions;
function apiVersions(versionArray) {
    return function (_target, _propertyKey, descriptor) {
        if (versionArray.length === 0) {
            versionArray = [0, 0];
        }
        else if (versionArray.length === 1) {
            versionArray = [versionArray[0], Infinity];
        }
        descriptor.value.apiVersions = versionArray;
    };
}
exports.apiVersions = apiVersions;
function deprecated(_target, _propertyKey, descriptor) {
    descriptor.value.deprecated = true;
}
exports.deprecated = deprecated;
function topologies(topologiesArray) {
    return function (_target, _propertyKey, descriptor) {
        descriptor.value.topologies = topologiesArray;
    };
}
exports.topologies = topologies;
exports.nonAsyncFunctionsReturningPromises = [];
function returnsPromise(_target, _propertyKey, descriptor) {
    const originalFunction = descriptor.value;
    originalFunction.returnsPromise = true;
    async function wrapper(...args) {
        try {
            return await originalFunction.call(this, ...args);
        }
        finally {
            if (typeof setTimeout === 'function' && typeof setImmediate === 'function') {
                await new Promise(setImmediate);
            }
        }
    }
    Object.setPrototypeOf(wrapper, Object.getPrototypeOf(originalFunction));
    Object.defineProperties(wrapper, Object.getOwnPropertyDescriptors(originalFunction));
    descriptor.value = markImplicitlyAwaited(wrapper);
    if (originalFunction.constructor.name !== 'AsyncFunction') {
        exports.nonAsyncFunctionsReturningPromises.push(originalFunction.name);
    }
}
exports.returnsPromise = returnsPromise;
function directShellCommand(_target, _propertyKey, descriptor) {
    descriptor.value.isDirectShellCommand = true;
}
exports.directShellCommand = directShellCommand;
function shellCommandCompleter(completer) {
    return function (_target, _propertyKey, descriptor) {
        descriptor.value.shellCommandCompleter = completer;
    };
}
exports.shellCommandCompleter = shellCommandCompleter;
function returnType(type) {
    return function (_target, _propertyKey, descriptor) {
        descriptor.value.returnType = type;
    };
}
exports.returnType = returnType;
function classDeprecated(constructor) {
    constructor.prototype.deprecated = true;
}
exports.classDeprecated = classDeprecated;
function platforms(platformsArray) {
    return function (_target, _propertyKey, descriptor) {
        descriptor.value.platforms = platformsArray;
    };
}
exports.platforms = platforms;
function classPlatforms(platformsArray) {
    return function (constructor) {
        constructor.prototype.platforms = platformsArray;
    };
}
exports.classPlatforms = classPlatforms;
function addSourceToResults(constructor) {
    constructor[addSourceToResultsSymbol] = true;
}
exports.addSourceToResults = addSourceToResults;
//# sourceMappingURL=decorators.js.map