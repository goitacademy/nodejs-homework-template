"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("./decorators");
const helpers_1 = require("./helpers");
const enums_1 = require("./enums");
const result_1 = require("./result");
const history_1 = require("@mongosh/history");
const semver_1 = __importDefault(require("semver"));
let Shard = class Shard extends decorators_1.ShellApiWithMongoClass {
    constructor(database) {
        super();
        this._database = database;
    }
    get _mongo() {
        return this._database._mongo;
    }
    [enums_1.asPrintable]() {
        return `Shard class connected to ${(0, history_1.redactURICredentials)(this._database._mongo._uri)} via db ${this._database._name}`;
    }
    _emitShardApiCall(methodName, methodArguments = {}) {
        this._database._mongo._instanceState.emitApiCallWithArgs({
            method: methodName,
            class: 'Shard',
            arguments: methodArguments
        });
    }
    async enableSharding(database, primaryShard) {
        (0, helpers_1.assertArgsDefinedType)([database, primaryShard], ['string', [undefined, 'string']], 'Shard.enableSharding');
        this._emitShardApiCall('enableSharding', { database, primaryShard });
        const cmd = {
            enableSharding: database
        };
        if (primaryShard !== undefined) {
            cmd.primaryShard = primaryShard;
        }
        try {
            return await this._database._runAdminCommand(cmd);
        }
        catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.codeName) === 'CommandNotFound') {
                error.message = `${error.message}. Are you connected to mongos?`;
            }
            throw error;
        }
    }
    async commitReshardCollection(namespace) {
        (0, helpers_1.assertArgsDefinedType)([namespace], ['string'], 'Shard.commitReshardCollection');
        this._emitShardApiCall('commitReshardCollection', { namespace });
        return await this._database._runAdminCommand({
            commitReshardCollection: namespace
        });
    }
    async abortReshardCollection(namespace) {
        (0, helpers_1.assertArgsDefinedType)([namespace], ['string'], 'Shard.abortReshardCollection');
        this._emitShardApiCall('abortReshardCollection', { namespace });
        return await this._database._runAdminCommand({
            abortReshardCollection: namespace
        });
    }
    async shardCollection(namespace, key, unique, options) {
        return await this._runShardCollection('shardCollection', namespace, key, unique, options);
    }
    async reshardCollection(namespace, key, unique, options) {
        return await this._runShardCollection('reshardCollection', namespace, key, unique, options);
    }
    async _runShardCollection(command, namespace, key, unique, options) {
        (0, helpers_1.assertArgsDefinedType)([namespace, key, unique, options], ['string', 'object', [undefined, 'boolean', 'object'], [undefined, 'object']], `Shard.${command}`);
        this._emitShardApiCall(command, { namespace, key, unique, options });
        if (typeof unique === 'object' && unique !== null) {
            options = unique;
            unique = undefined;
        }
        const cmd = {
            [command]: namespace,
            key: key
        };
        if (unique !== undefined) {
            cmd.unique = unique;
        }
        try {
            return await this._database._runAdminCommand({ ...cmd, ...options });
        }
        catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.codeName) === 'CommandNotFound') {
                error.message = `${error.message}. Are you connected to mongos?`;
            }
            throw error;
        }
    }
    async status(verbose = false, configDB) {
        const result = await (0, helpers_1.getPrintableShardStatus)(configDB !== null && configDB !== void 0 ? configDB : await (0, helpers_1.getConfigDB)(this._database), verbose);
        return new result_1.CommandResult('StatsResult', result);
    }
    async addShard(url) {
        (0, helpers_1.assertArgsDefinedType)([url], ['string'], 'Shard.addShard');
        await (0, helpers_1.getConfigDB)(this._database);
        this._emitShardApiCall('addShard', { url });
        return this._database._runAdminCommand({
            addShard: url
        });
    }
    async addShardToZone(shard, zone) {
        (0, helpers_1.assertArgsDefinedType)([shard, zone], ['string', 'string'], 'Shard.addShardToZone');
        this._emitShardApiCall('addShardToZone', { shard, zone });
        await (0, helpers_1.getConfigDB)(this._database);
        return this._database._runAdminCommand({
            addShardToZone: shard,
            zone: zone
        });
    }
    async addShardTag(shard, tag) {
        (0, helpers_1.assertArgsDefinedType)([shard, tag], ['string', 'string'], 'Shard.addShardTag');
        this._emitShardApiCall('addShardTag', { shard, tag });
        try {
            return await this.addShardToZone(shard, tag);
        }
        catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.codeName) === 'CommandNotFound') {
                error.message = `${error.message}. This method aliases to addShardToZone which exists only for server versions > 3.4.`;
            }
            throw error;
        }
    }
    async updateZoneKeyRange(namespace, min, max, zone) {
        (0, helpers_1.assertArgsDefinedType)([namespace, min, max, zone], ['string', 'object', 'object', true], 'Shard.updateZoneKeyRange');
        this._emitShardApiCall('updateZoneKeyRange', { namespace, min, max, zone });
        await (0, helpers_1.getConfigDB)(this._database);
        return await this._database._runAdminCommand({
            updateZoneKeyRange: namespace,
            min,
            max,
            zone
        });
    }
    async addTagRange(namespace, min, max, zone) {
        (0, helpers_1.assertArgsDefinedType)([namespace, min, max, zone], ['string', 'object', 'object', true], 'Shard.addTagRange');
        this._emitShardApiCall('addTagRange', { namespace, min, max, zone });
        try {
            return await this.updateZoneKeyRange(namespace, min, max, zone);
        }
        catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.codeName) === 'CommandNotFound') {
                error.message = `${error.message}. This method aliases to updateZoneKeyRange which exists only for server versions > 3.4.`;
            }
            throw error;
        }
    }
    async removeRangeFromZone(ns, min, max) {
        (0, helpers_1.assertArgsDefinedType)([ns, min, max], ['string', 'object', 'object'], 'Shard.removeRangeFromZone');
        this._emitShardApiCall('removeRangeFromZone', { ns, min, max });
        return this.updateZoneKeyRange(ns, min, max, null);
    }
    async removeTagRange(ns, min, max) {
        (0, helpers_1.assertArgsDefinedType)([ns, min, max], ['string', 'object', 'object'], 'Shard.removeTagRange');
        this._emitShardApiCall('removeTagRange', { ns, min, max });
        try {
            return await this.updateZoneKeyRange(ns, min, max, null);
        }
        catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.codeName) === 'CommandNotFound') {
                error.message = `${error.message}. This method aliases to updateZoneKeyRange which exists only for server versions > 3.4.`;
            }
            throw error;
        }
    }
    async removeShardFromZone(shard, zone) {
        (0, helpers_1.assertArgsDefinedType)([shard, zone], ['string', 'string'], 'Shard.removeShardFromZone');
        this._emitShardApiCall('removeShardFromZone', { shard, zone });
        await (0, helpers_1.getConfigDB)(this._database);
        return await this._database._runAdminCommand({
            removeShardFromZone: shard,
            zone: zone
        });
    }
    async removeShardTag(shard, tag) {
        (0, helpers_1.assertArgsDefinedType)([shard, tag], ['string', 'string'], 'Shard.removeShardTag');
        this._emitShardApiCall('removeTagRange', { shard, tag });
        try {
            return await this.removeShardFromZone(shard, tag);
        }
        catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.codeName) === 'CommandNotFound') {
                error.message = `${error.message}. This method aliases to removeShardFromZone which exists only for server versions > 3.4.`;
            }
            throw error;
        }
    }
    async enableAutoSplit() {
        if (this._instanceState.connectionInfo.buildInfo.version &&
            semver_1.default.gte(this._instanceState.connectionInfo.buildInfo.version, '6.0.3')) {
            await this._instanceState.printDeprecationWarning('Starting in MongoDB 6.0.3, automatic chunk splitting is not performed. This is because of balancing policy improvements. Auto-splitting commands still exist, but do not perform an operation. For details, see Balancing Policy Changes: https://www.mongodb.com/docs/manual/release-notes/6.0/#balancing-policy-changes\n');
        }
        this._emitShardApiCall('enableAutoSplit', {});
        const config = await (0, helpers_1.getConfigDB)(this._database);
        return await config.getCollection('settings').updateOne({ _id: 'autosplit' }, { $set: { enabled: true } }, { upsert: true, writeConcern: { w: 'majority', wtimeout: 30000 } });
    }
    async disableAutoSplit() {
        if (this._instanceState.connectionInfo.buildInfo.version &&
            semver_1.default.gte(this._instanceState.connectionInfo.buildInfo.version, '6.0.3')) {
            await this._instanceState.printDeprecationWarning('Starting in MongoDB 6.0.3, automatic chunk splitting is not performed. This is because of balancing policy improvements. Auto-splitting commands still exist, but do not perform an operation. For details, see Balancing Policy Changes: https://www.mongodb.com/docs/manual/release-notes/6.0/#balancing-policy-changes\n');
        }
        this._emitShardApiCall('disableAutoSplit', {});
        const config = await (0, helpers_1.getConfigDB)(this._database);
        return await config.getCollection('settings').updateOne({ _id: 'autosplit' }, { $set: { enabled: false } }, { upsert: true, writeConcern: { w: 'majority', wtimeout: 30000 } });
    }
    async splitAt(ns, query) {
        (0, helpers_1.assertArgsDefinedType)([ns, query], ['string', 'object'], 'Shard.splitAt');
        this._emitShardApiCall('splitAt', { ns, query });
        return this._database._runAdminCommand({
            split: ns,
            middle: query
        });
    }
    async splitFind(ns, query) {
        (0, helpers_1.assertArgsDefinedType)([ns, query], ['string', 'object'], 'Shard.splitFind');
        this._emitShardApiCall('splitFind', { ns, query });
        return this._database._runAdminCommand({
            split: ns,
            find: query
        });
    }
    async moveChunk(ns, query, destination) {
        (0, helpers_1.assertArgsDefinedType)([ns, query, destination], ['string', 'object', 'string'], 'Shard.moveChunk');
        this._emitShardApiCall('moveChunk', { ns, query, destination });
        return this._database._runAdminCommand({
            moveChunk: ns,
            find: query,
            to: destination
        });
    }
    async balancerCollectionStatus(ns) {
        (0, helpers_1.assertArgsDefinedType)([ns], ['string'], 'Shard.balancerCollectionStatus');
        this._emitShardApiCall('balancerCollectionStatus', { ns });
        return this._database._runAdminCommand({
            balancerCollectionStatus: ns
        });
    }
    async enableBalancing(ns) {
        (0, helpers_1.assertArgsDefinedType)([ns], ['string'], 'Shard.enableBalancing');
        this._emitShardApiCall('enableBalancing', { ns });
        const config = await (0, helpers_1.getConfigDB)(this._database);
        return await config.getCollection('collections').updateOne({ _id: ns }, { $set: { 'noBalance': false } }, { writeConcern: { w: 'majority', wtimeout: 60000 } });
    }
    async disableBalancing(ns) {
        (0, helpers_1.assertArgsDefinedType)([ns], ['string'], 'Shard.disableBalancing');
        this._emitShardApiCall('disableBalancing', { ns });
        const config = await (0, helpers_1.getConfigDB)(this._database);
        return await config.getCollection('collections').updateOne({ _id: ns }, { $set: { 'noBalance': true } }, { writeConcern: { w: 'majority', wtimeout: 60000 } });
    }
    async getBalancerState() {
        this._emitShardApiCall('getBalancerState', {});
        const config = await (0, helpers_1.getConfigDB)(this._database);
        const doc = await config.getCollection('settings').findOne({ _id: 'balancer' });
        if (doc === null || doc === undefined) {
            return true;
        }
        return !doc.stopped;
    }
    async isBalancerRunning() {
        this._emitShardApiCall('isBalancerRunning', {});
        await (0, helpers_1.getConfigDB)(this._database);
        return this._database._runAdminCommand({
            balancerStatus: 1
        });
    }
    async startBalancer(timeout = 60000) {
        (0, helpers_1.assertArgsDefinedType)([timeout], ['number'], 'Shard.startBalancer');
        this._emitShardApiCall('startBalancer', { timeout });
        return this._database._runAdminCommand({
            balancerStart: 1, maxTimeMS: timeout
        });
    }
    async stopBalancer(timeout = 60000) {
        (0, helpers_1.assertArgsDefinedType)([timeout], ['number'], 'Shard.stopBalancer');
        this._emitShardApiCall('stopBalancer', { timeout });
        return this._database._runAdminCommand({
            balancerStop: 1, maxTimeMS: timeout
        });
    }
    async setBalancerState(state) {
        (0, helpers_1.assertArgsDefinedType)([state], ['boolean'], 'Shard.setBalancerState');
        this._emitShardApiCall('setBalancerState', { state });
        if (state) {
            return this.startBalancer();
        }
        return this.stopBalancer();
    }
    async getShardedDataDistribution(options = {}) {
        var _a;
        this._emitShardApiCall('getShardedDataDistribution', {});
        const cursor = await this._database.getSiblingDB('admin').aggregate([{ $shardedDataDistribution: options }]);
        try {
            await cursor.hasNext();
        }
        catch (err) {
            if (((_a = err.code) === null || _a === void 0 ? void 0 : _a.valueOf()) === 40324) {
                err.message = `sh.getShardedDataDistribution only works on mongos and MongoDB server versions greater than 6.0.3 [Original Error: ${err.message}]`;
            }
            throw err;
        }
        return cursor;
    }
    async startAutoMerger() {
        this._emitShardApiCall('startAutoMerger', {});
        const config = await (0, helpers_1.getConfigDB)(this._database);
        return await config.getCollection('settings').updateOne({ _id: 'automerge' }, { $set: { enabled: true } }, { upsert: true, writeConcern: { w: 'majority', wtimeout: 30000 } });
    }
    async stopAutoMerger() {
        this._emitShardApiCall('stopAutoMerger', {});
        const config = await (0, helpers_1.getConfigDB)(this._database);
        return await config.getCollection('settings').updateOne({ _id: 'automerge' }, { $set: { enabled: false } }, { upsert: true, writeConcern: { w: 'majority', wtimeout: 30000 } });
    }
    async isAutoMergerEnabled() {
        this._emitShardApiCall('isAutoMergerEnabled', {});
        const config = await (0, helpers_1.getConfigDB)(this._database);
        const doc = await config.getCollection('settings').findOne({ _id: 'automerge' });
        if (doc === null || doc === undefined) {
            return true;
        }
        return doc.enabled;
    }
    async disableAutoMerger(ns) {
        (0, helpers_1.assertArgsDefinedType)([ns], ['string'], 'Shard.disableAutoMerger');
        this._emitShardApiCall('disableAutoMerger', { ns });
        const config = await (0, helpers_1.getConfigDB)(this._database);
        return await config.getCollection('collections').updateOne({ _id: ns }, { $set: { enableAutoMerge: false } }, { writeConcern: { w: 'majority', wtimeout: 60000 } });
    }
    async enableAutoMerger(ns) {
        (0, helpers_1.assertArgsDefinedType)([ns], ['string'], 'Shard.enableAutoMerger');
        this._emitShardApiCall('enableAutoMerger', { ns });
        const config = await (0, helpers_1.getConfigDB)(this._database);
        return await config.getCollection('collections').updateOne({ _id: ns }, { $unset: { enableAutoMerge: 1 } }, { writeConcern: { w: 'majority', wtimeout: 60000 } });
    }
    async checkMetadataConsistency(options = {}) {
        this._emitShardApiCall('checkMetadataConsistency', { options });
        return this._database._runAdminCursorCommand({
            checkMetadataConsistency: 1
        });
    }
};
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "enableSharding", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['5.0.0', enums_1.ServerVersions.latest])
], Shard.prototype, "commitReshardCollection", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['5.0.0', enums_1.ServerVersions.latest])
], Shard.prototype, "abortReshardCollection", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "shardCollection", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['5.0.0', enums_1.ServerVersions.latest])
], Shard.prototype, "reshardCollection", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Shard.prototype, "status", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "addShard", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "addShardToZone", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "addShardTag", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "updateZoneKeyRange", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "addTagRange", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "removeRangeFromZone", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "removeTagRange", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "removeShardFromZone", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "removeShardTag", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1]),
    (0, decorators_1.serverVersions)(['3.4.0', '6.0.2'])
], Shard.prototype, "enableAutoSplit", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1]),
    (0, decorators_1.serverVersions)(['3.4.0', '6.0.2'])
], Shard.prototype, "disableAutoSplit", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "splitAt", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "splitFind", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "moveChunk", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['4.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "balancerCollectionStatus", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "enableBalancing", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "disableBalancing", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "getBalancerState", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "isBalancerRunning", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "startBalancer", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "stopBalancer", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Shard.prototype, "setBalancerState", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['6.0.3', enums_1.ServerVersions.latest]),
    (0, decorators_1.returnType)('AggregationCursor')
], Shard.prototype, "getShardedDataDistribution", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest])
], Shard.prototype, "startAutoMerger", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest])
], Shard.prototype, "stopAutoMerger", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest])
], Shard.prototype, "isAutoMergerEnabled", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest])
], Shard.prototype, "disableAutoMerger", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest])
], Shard.prototype, "enableAutoMerger", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest])
], Shard.prototype, "checkMetadataConsistency", null);
Shard = __decorate([
    decorators_1.shellApiClassDefault
], Shard);
exports.default = Shard;
//# sourceMappingURL=shard.js.map