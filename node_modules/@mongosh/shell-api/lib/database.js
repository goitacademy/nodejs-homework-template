"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const collection_1 = __importDefault(require("./collection"));
const decorators_1 = require("./decorators");
const enums_1 = require("./enums");
const helpers_1 = require("./helpers");
const index_1 = require("./index");
const errors_1 = require("@mongosh/errors");
const history_1 = require("@mongosh/history");
const change_stream_cursor_1 = __importDefault(require("./change-stream-cursor"));
const error_codes_1 = require("./error-codes");
let Database = class Database extends decorators_1.ShellApiWithMongoClass {
    constructor(mongo, name, session) {
        super();
        this._cachedCollectionNames = [];
        this._cachedHello = null;
        this._mongo = mongo;
        this._name = name;
        const collections = Object.create(null);
        this._collections = collections;
        this._session = session;
        const proxy = new Proxy(this, {
            get: (target, prop) => {
                if (prop in target) {
                    return target[prop];
                }
                if (typeof prop !== 'string' ||
                    prop.startsWith('_') ||
                    !(0, helpers_1.isValidCollectionName)(prop)) {
                    return;
                }
                if (!collections[prop]) {
                    collections[prop] = new collection_1.default(mongo, proxy, prop);
                }
                return collections[prop];
            }
        });
        return proxy;
    }
    async _baseOptions() {
        const options = {};
        if (this._session) {
            options.session = this._session._session;
        }
        const maxTimeMS = await this._instanceState.shellApi.config.get('maxTimeMS');
        if (typeof maxTimeMS === 'number') {
            options.maxTimeMS = maxTimeMS;
        }
        return options;
    }
    async _maybeCachedHello() {
        var _a;
        return (_a = this._cachedHello) !== null && _a !== void 0 ? _a : await this.hello();
    }
    [enums_1.asPrintable]() {
        return this._name;
    }
    _emitDatabaseApiCall(methodName, methodArguments = {}) {
        this._mongo._instanceState.emitApiCallWithArgs({
            method: methodName,
            class: 'Database',
            db: this._name,
            arguments: methodArguments
        });
    }
    async _runCommand(cmd, options = {}) {
        return this._mongo._serviceProvider.runCommandWithCheck(this._name, (0, helpers_1.adjustRunCommand)(cmd, this._instanceState.shellBson), { ...this._mongo._getExplicitlyRequestedReadPref(), ...await this._baseOptions(), ...options });
    }
    async _runAdminCommand(cmd, options = {}) {
        return this.getSiblingDB('admin')._runCommand(cmd, { ...await this._baseOptions(), ...options });
    }
    async _runCursorCommand(cmd, options = {}) {
        const providerCursor = this._mongo._serviceProvider.runCursorCommand(this._name, (0, helpers_1.adjustRunCommand)(cmd, this._instanceState.shellBson), { ...this._mongo._getExplicitlyRequestedReadPref(), ...await this._baseOptions(), ...options });
        const cursor = new index_1.RunCommandCursor(this._mongo, providerCursor);
        this._mongo._instanceState.currentCursor = cursor;
        return cursor;
    }
    async _runAdminCursorCommand(cmd, options = {}) {
        return this.getSiblingDB('admin')._runCursorCommand(cmd, options);
    }
    async _listCollections(filter, options) {
        return await this._mongo._serviceProvider.listCollections(this._name, filter, { ...this._mongo._getExplicitlyRequestedReadPref(), ...await this._baseOptions(), ...options }) || [];
    }
    async _getCollectionNames(options) {
        const infos = await this._listCollections({}, { ...options, nameOnly: true });
        this._cachedCollectionNames = infos.map((collection) => collection.name);
        return this._cachedCollectionNames;
    }
    async _getCollectionNamesWithTypes(options) {
        let collections = await this._listCollections({}, { ...options, nameOnly: true });
        collections = collections.sort((c1, c2) => (c1.name).localeCompare(c2.name));
        this._cachedCollectionNames = collections.map((collection) => collection.name);
        return collections.map((collection, index) => ({
            name: collection.name,
            badge: (0, helpers_1.getBadge)(collections, index)
        }));
    }
    async _getCollectionNamesForCompletion() {
        return await Promise.race([
            (async () => {
                return await this._getCollectionNames({ readPreference: 'primaryPreferred' });
            })(),
            (async () => {
                await new Promise(resolve => setTimeout(resolve, 200).unref());
                return this._cachedCollectionNames;
            })()
        ]);
    }
    async _getLastErrorObj(w, wTimeout, j) {
        const cmd = { getlasterror: 1 };
        if (w) {
            cmd.w = w;
        }
        if (wTimeout) {
            cmd.wtimeout = wTimeout;
        }
        if (j !== undefined) {
            cmd.j = j;
        }
        try {
            return await this._mongo._serviceProvider.runCommand(this._name, cmd, await this._baseOptions());
        }
        catch (e) {
            return e;
        }
    }
    getMongo() {
        return this._mongo;
    }
    getName() {
        return this._name;
    }
    async getCollectionNames() {
        this._emitDatabaseApiCall('getCollectionNames');
        return this._getCollectionNames();
    }
    async getCollectionInfos(filter = {}, options = {}) {
        this._emitDatabaseApiCall('getCollectionInfos', { filter, options });
        return await this._listCollections(filter, options);
    }
    async runCommand(cmd) {
        (0, helpers_1.assertArgsDefinedType)([cmd], [['string', 'object']], 'Database.runCommand');
        if (typeof cmd === 'string') {
            cmd = { [cmd]: 1 };
        }
        const hiddenCommands = new RegExp(history_1.HIDDEN_COMMANDS);
        if (!Object.keys(cmd).some(k => hiddenCommands.test(k))) {
            this._emitDatabaseApiCall('runCommand', { cmd });
        }
        return this._runCommand(cmd);
    }
    async adminCommand(cmd) {
        (0, helpers_1.assertArgsDefinedType)([cmd], [['string', 'object']], 'Database.adminCommand');
        if (typeof cmd === 'string') {
            cmd = { [cmd]: 1 };
        }
        const hiddenCommands = new RegExp(history_1.HIDDEN_COMMANDS);
        if (!Object.keys(cmd).some(k => hiddenCommands.test(k))) {
            this._emitDatabaseApiCall('adminCommand', { cmd });
        }
        return await this._runAdminCommand(cmd, {});
    }
    async aggregate(pipeline, options) {
        (0, helpers_1.assertArgsDefinedType)([pipeline], [true], 'Database.aggregate');
        this._emitDatabaseApiCall('aggregate', { options, pipeline });
        const { aggOptions, dbOptions, explain } = (0, helpers_1.adaptAggregateOptions)(options);
        const providerCursor = this._mongo._serviceProvider.aggregateDb(this._name, pipeline, { ...await this._baseOptions(), ...aggOptions }, dbOptions);
        const cursor = new index_1.AggregationCursor(this._mongo, providerCursor);
        if (explain) {
            return await cursor.explain(explain);
        }
        else if ((0, helpers_1.shouldRunAggregationImmediately)(pipeline)) {
            await cursor.hasNext();
        }
        this._mongo._instanceState.currentCursor = cursor;
        return cursor;
    }
    getSiblingDB(db) {
        (0, helpers_1.assertArgsDefinedType)([db], ['string'], 'Database.getSiblingDB');
        this._emitDatabaseApiCall('getSiblingDB', { db });
        if (this._session) {
            return this._session.getDatabase(db);
        }
        return this._mongo._getDb(db);
    }
    getCollection(coll) {
        (0, helpers_1.assertArgsDefinedType)([coll], ['string'], 'Database.getColl');
        this._emitDatabaseApiCall('getCollection', { coll });
        if (!(0, helpers_1.isValidCollectionName)(coll)) {
            throw new errors_1.MongoshInvalidInputError(`Invalid collection name: ${coll}`, errors_1.CommonErrors.InvalidArgument);
        }
        const collections = this._collections;
        if (!collections[coll]) {
            collections[coll] = new collection_1.default(this._mongo, this, coll);
        }
        return collections[coll];
    }
    async dropDatabase(writeConcern) {
        return await this._mongo._serviceProvider.dropDatabase(this._name, { ...await this._baseOptions(), writeConcern });
    }
    async createUser(user, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([user], ['object'], 'Database.createUser');
        (0, helpers_1.assertKeysDefined)(user, ['user', 'roles']);
        if (this._name === '$external') {
            if ('pwd' in user) {
                throw new errors_1.MongoshInvalidInputError('Cannot set password for users on the $external database', errors_1.CommonErrors.InvalidArgument);
            }
        }
        else {
            (0, helpers_1.assertKeysDefined)(user, ['pwd']);
        }
        this._emitDatabaseApiCall('createUser', {});
        if (user.createUser) {
            throw new errors_1.MongoshInvalidInputError('Cannot set createUser field in helper method', errors_1.CommonErrors.InvalidArgument);
        }
        const command = (0, helpers_1.adaptOptions)({ user: 'createUser', passwordDigestor: null }, {}, user);
        if (writeConcern) {
            command.writeConcern = writeConcern;
        }
        const digestPwd = (0, helpers_1.processDigestPassword)(user.user, user.passwordDigestor, command);
        const orderedCmd = { createUser: command.createUser, ...command, ...digestPwd };
        return await this._runCommand(orderedCmd);
    }
    async updateUser(username, userDoc, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([username, userDoc], ['string', 'object'], 'Database.updateUser');
        this._emitDatabaseApiCall('updateUser', {});
        if (userDoc.passwordDigestor && userDoc.passwordDigestor !== 'server' && userDoc.passwordDigestor !== 'client') {
            throw new errors_1.MongoshInvalidInputError(`Invalid field: passwordDigestor must be 'client' or 'server', got ${userDoc.passwordDigestor}`, errors_1.CommonErrors.InvalidArgument);
        }
        const command = (0, helpers_1.adaptOptions)({ passwordDigestor: null }, {
            updateUser: username
        }, userDoc);
        if (writeConcern) {
            command.writeConcern = writeConcern;
        }
        const digestPwd = (0, helpers_1.processDigestPassword)(username, userDoc.passwordDigestor, command);
        const orderedCmd = { updateUser: command.updateUser, ...command, ...digestPwd };
        return await this._runCommand(orderedCmd);
    }
    async changeUserPassword(username, password, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([username, password], ['string', 'string'], 'Database.changeUserPassword');
        this._emitDatabaseApiCall('changeUserPassword', {});
        const command = (0, helpers_1.adaptOptions)({}, {
            updateUser: username,
            pwd: password
        }, {});
        if (writeConcern) {
            command.writeConcern = writeConcern;
        }
        const orderedCmd = { updateUser: command.updateUser, ...command };
        return await this._runCommand(orderedCmd);
    }
    async logout() {
        this._emitDatabaseApiCall('logout', {});
        this._mongo._instanceState.currentCursor = null;
        return await this._runCommand({ logout: 1 });
    }
    async dropUser(username, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([username], ['string'], 'Database.dropUser');
        this._emitDatabaseApiCall('dropUser', {});
        const cmd = { dropUser: username };
        if (writeConcern) {
            cmd.writeConcern = writeConcern;
        }
        return await this._runCommand(cmd);
    }
    async dropAllUsers(writeConcern) {
        this._emitDatabaseApiCall('dropAllUsers', {});
        const cmd = { dropAllUsersFromDatabase: 1 };
        if (writeConcern) {
            cmd.writeConcern = writeConcern;
        }
        return await this._runCommand(cmd);
    }
    async auth(...args) {
        this._emitDatabaseApiCall('auth', {});
        let authDoc;
        if (args.length === 1) {
            const { evaluationListener } = this._mongo._instanceState;
            if (typeof args[0] === 'string' && evaluationListener.onPrompt) {
                authDoc = {
                    user: args[0],
                    pwd: await evaluationListener.onPrompt('Enter password', 'password')
                };
            }
            else {
                authDoc = args[0];
            }
        }
        else if (args.length === 2) {
            authDoc = {
                user: args[0],
                pwd: args[1]
            };
        }
        else {
            throw new errors_1.MongoshInvalidInputError('auth expects (username), (username, password), or ({ user: username, pwd: password })', errors_1.CommonErrors.InvalidArgument);
        }
        if ((!authDoc.user || !authDoc.pwd) && !authDoc.mechanism) {
            throw new errors_1.MongoshInvalidInputError('auth expects user document with at least \'user\' and \'pwd\' or \'mechanism\' fields', errors_1.CommonErrors.InvalidArgument);
        }
        if ('digestPassword' in authDoc) {
            throw new errors_1.MongoshUnimplementedError('digestPassword is not supported for authentication.', errors_1.CommonErrors.NotImplemented);
        }
        authDoc.authDb = this._name;
        this._mongo._instanceState.currentCursor = null;
        return await this._mongo._serviceProvider.authenticate(authDoc);
    }
    async grantRolesToUser(username, roles, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([username, roles], ['string', true], 'Database.grantRolesToUser');
        this._emitDatabaseApiCall('grantRolesToUser', {});
        const cmd = { grantRolesToUser: username, roles: roles };
        if (writeConcern) {
            cmd.writeConcern = writeConcern;
        }
        return await this._runCommand(cmd);
    }
    async revokeRolesFromUser(username, roles, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([username, roles], ['string', true], 'Database.revokeRolesFromUser');
        this._emitDatabaseApiCall('revokeRolesFromUser', {});
        const cmd = { revokeRolesFromUser: username, roles: roles };
        if (writeConcern) {
            cmd.writeConcern = writeConcern;
        }
        return await this._runCommand(cmd);
    }
    async getUser(username, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([username], ['string'], 'Database.getUser');
        this._emitDatabaseApiCall('getUser', { username: username });
        const command = (0, helpers_1.adaptOptions)({}, { usersInfo: { user: username, db: this._name } }, options);
        const result = await this._runCommand(command);
        if (result.users === undefined) {
            throw new errors_1.MongoshInternalError('No users were returned from the userInfo command');
        }
        for (let i = 0; i < result.users.length; i++) {
            if (result.users[i].user === username) {
                return result.users[i];
            }
        }
        return null;
    }
    async getUsers(options = {}) {
        this._emitDatabaseApiCall('getUsers', { options: options });
        const command = (0, helpers_1.adaptOptions)({}, { usersInfo: 1 }, options);
        return await this._runCommand(command);
    }
    async createCollection(name, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([name], ['string'], 'Database.createCollection');
        this._emitDatabaseApiCall('createCollection', { name: name, options: options });
        return await this._mongo._serviceProvider.createCollection(this._name, name, { ...await this._baseOptions(), ...options });
    }
    async createEncryptedCollection(name, options) {
        this._emitDatabaseApiCall('createEncryptedCollection', { name: name, options: options });
        return this._mongo.getClientEncryption().createEncryptedCollection(this._name, name, options);
    }
    async createView(name, source, pipeline, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([name, source, pipeline], ['string', 'string', true], 'Database.createView');
        this._emitDatabaseApiCall('createView', { name, source, pipeline, options });
        const ccOpts = {
            ...await this._baseOptions(),
            viewOn: source,
            pipeline: pipeline
        };
        if (options.collation) {
            ccOpts.collation = options.collation;
        }
        return await this._mongo._serviceProvider.createCollection(this._name, name, ccOpts);
    }
    async createRole(role, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([role], ['object'], 'Database.createRole');
        (0, helpers_1.assertKeysDefined)(role, ['role', 'privileges', 'roles']);
        this._emitDatabaseApiCall('createRole', {});
        if (role.createRole) {
            throw new errors_1.MongoshInvalidInputError('Cannot set createRole field in helper method', errors_1.CommonErrors.InvalidArgument);
        }
        const command = (0, helpers_1.adaptOptions)({ role: 'createRole' }, {}, role);
        if (writeConcern) {
            command.writeConcern = writeConcern;
        }
        const orderedCmd = { createRole: command.createRole, ...command };
        return await this._runCommand(orderedCmd);
    }
    async updateRole(rolename, roleDoc, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([rolename, roleDoc], ['string', 'object'], 'Database.updateRole');
        this._emitDatabaseApiCall('updateRole', {});
        const command = (0, helpers_1.adaptOptions)({}, {
            updateRole: rolename
        }, roleDoc);
        if (writeConcern) {
            command.writeConcern = writeConcern;
        }
        const orderedCmd = { updateRole: command.updateRole, ...command };
        return await this._runCommand(orderedCmd);
    }
    async dropRole(rolename, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([rolename], ['string'], 'Database.dropRole');
        this._emitDatabaseApiCall('dropRole', {});
        const cmd = { dropRole: rolename };
        if (writeConcern) {
            cmd.writeConcern = writeConcern;
        }
        return await this._runCommand(cmd);
    }
    async dropAllRoles(writeConcern) {
        this._emitDatabaseApiCall('dropAllRoles', {});
        const cmd = { dropAllRolesFromDatabase: 1 };
        if (writeConcern) {
            cmd.writeConcern = writeConcern;
        }
        return await this._runCommand(cmd);
    }
    async grantRolesToRole(rolename, roles, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([rolename, roles], ['string', true], 'Database.grantRolesToRole');
        this._emitDatabaseApiCall('grantRolesToRole', {});
        const cmd = { grantRolesToRole: rolename, roles: roles };
        if (writeConcern) {
            cmd.writeConcern = writeConcern;
        }
        return await this._runCommand(cmd);
    }
    async revokeRolesFromRole(rolename, roles, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([rolename, roles], ['string', true], 'Database.revokeRolesFromRole');
        this._emitDatabaseApiCall('revokeRolesFromRole', {});
        const cmd = { revokeRolesFromRole: rolename, roles: roles };
        if (writeConcern) {
            cmd.writeConcern = writeConcern;
        }
        return await this._runCommand(cmd);
    }
    async grantPrivilegesToRole(rolename, privileges, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([rolename, privileges], ['string', true], 'Database.grantPrivilegesToRole');
        this._emitDatabaseApiCall('grantPrivilegesToRole', {});
        const cmd = { grantPrivilegesToRole: rolename, privileges: privileges };
        if (writeConcern) {
            cmd.writeConcern = writeConcern;
        }
        return await this._runCommand(cmd);
    }
    async revokePrivilegesFromRole(rolename, privileges, writeConcern) {
        (0, helpers_1.assertArgsDefinedType)([rolename, privileges], ['string', true], 'Database.revokePrivilegesFromRole');
        this._emitDatabaseApiCall('revokePrivilegesFromRole', {});
        const cmd = { revokePrivilegesFromRole: rolename, privileges: privileges };
        if (writeConcern) {
            cmd.writeConcern = writeConcern;
        }
        return await this._runCommand(cmd);
    }
    async getRole(rolename, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([rolename], ['string'], 'Database.getRole');
        this._emitDatabaseApiCall('getRole', { rolename: rolename });
        const command = (0, helpers_1.adaptOptions)({}, { rolesInfo: { role: rolename, db: this._name } }, options);
        const result = await this._runCommand(command);
        if (result.roles === undefined) {
            throw new errors_1.MongoshInternalError('No roles returned from rolesInfo command');
        }
        for (let i = 0; i < result.roles.length; i++) {
            if (result.roles[i].role === rolename) {
                return result.roles[i];
            }
        }
        return null;
    }
    async getRoles(options = {}) {
        this._emitDatabaseApiCall('getRoles', { options: options });
        const command = (0, helpers_1.adaptOptions)({}, { rolesInfo: 1 }, options);
        return await this._runCommand(command);
    }
    async _getCurrentOperations(opts) {
        const legacyCurrentOpOptions = typeof opts === 'boolean'
            ? ({ '$all': opts, '$ownOps': false })
            : ({ '$all': !!opts.$all, '$ownOps': !!opts.$ownOps });
        const pipeline = [{
                $currentOp: {
                    allUsers: !legacyCurrentOpOptions.$ownOps,
                    idleConnections: legacyCurrentOpOptions.$all,
                    truncateOps: false,
                }
            }];
        if (typeof opts === 'object') {
            const matchingFilters = {};
            for (const filtername of Object.keys(opts)) {
                if (filtername !== '$ownOps' && filtername !== '$all' && filtername !== '$truncateOps') {
                    matchingFilters[filtername] = opts[filtername];
                }
            }
            pipeline.push({ $match: matchingFilters });
        }
        const adminDb = this.getSiblingDB('admin');
        const aggregateOptions = { $readPreference: { mode: 'primaryPreferred' } };
        try {
            const cursor = await adminDb.aggregate(pipeline, aggregateOptions);
            return await cursor.toArray();
        }
        catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.codeName) === 'FailedToParse') {
                delete pipeline[0].$currentOp.truncateOps;
                const cursor = await adminDb.aggregate(pipeline, aggregateOptions);
                return await cursor.toArray();
            }
            throw error;
        }
    }
    async currentOp(opts = {}) {
        this._emitDatabaseApiCall('currentOp', { opts: opts });
        const currentOps = await this._getCurrentOperations(opts);
        return {
            inprog: currentOps,
            ok: 1
        };
    }
    async killOp(opId) {
        (0, helpers_1.assertArgsDefinedType)([opId], ['number'], 'Database.killOp');
        this._emitDatabaseApiCall('killOp', { opId });
        return await this._runAdminCommand({
            killOp: 1,
            op: opId
        });
    }
    async shutdownServer(opts = {}) {
        this._emitDatabaseApiCall('shutdownServer', { opts: opts });
        return await this._runAdminCommand({
            shutdown: 1,
            ...opts
        });
    }
    async fsyncLock() {
        this._emitDatabaseApiCall('fsyncLock', {});
        return await this._runAdminCommand({
            fsync: 1,
            lock: true
        });
    }
    async fsyncUnlock() {
        this._emitDatabaseApiCall('fsyncUnlock', {});
        return await this._runAdminCommand({
            fsyncUnlock: 1
        });
    }
    async version() {
        this._emitDatabaseApiCall('version', {});
        const info = await this._runAdminCommand({
            buildInfo: 1,
        });
        if (!info || info.version === undefined) {
            throw new errors_1.MongoshRuntimeError(`Error running command serverBuildInfo ${info ? info.errmsg || '' : ''}`, errors_1.CommonErrors.CommandFailed);
        }
        return info.version;
    }
    async serverBits() {
        this._emitDatabaseApiCall('serverBits', {});
        const info = await this._runAdminCommand({
            buildInfo: 1,
        });
        if (!info || info.bits === undefined) {
            throw new errors_1.MongoshRuntimeError(`Error running command serverBuildInfo ${info ? info.errmsg || '' : ''}`, errors_1.CommonErrors.CommandFailed);
        }
        return info.bits;
    }
    async isMaster() {
        this._emitDatabaseApiCall('isMaster', {});
        const result = await this._runCommand({
            isMaster: 1,
        });
        result.isWritablePrimary = result.ismaster;
        return result;
    }
    async hello() {
        this._emitDatabaseApiCall('hello', {});
        try {
            this._cachedHello = await this._runCommand({
                hello: 1,
            });
            return this._cachedHello;
        }
        catch (err) {
            if ((err === null || err === void 0 ? void 0 : err.codeName) === 'CommandNotFound') {
                const result = await this.isMaster();
                delete result.ismaster;
                this._cachedHello = result;
                return this._cachedHello;
            }
            throw err;
        }
    }
    async serverBuildInfo() {
        this._emitDatabaseApiCall('serverBuildInfo', {});
        return await this._runAdminCommand({
            buildInfo: 1,
        });
    }
    async serverStatus(opts = {}) {
        this._emitDatabaseApiCall('serverStatus', { options: opts });
        return await this._runAdminCommand({
            serverStatus: 1, ...opts
        });
    }
    async stats(scaleOrOptions = 1) {
        (0, helpers_1.assertArgsDefinedType)([scaleOrOptions], [['number', 'object']], 'Database.stats');
        if (typeof scaleOrOptions === 'number') {
            scaleOrOptions = { scale: scaleOrOptions };
        }
        this._emitDatabaseApiCall('stats', { scale: scaleOrOptions.scale });
        return await this._runCommand({
            dbStats: 1,
            scale: 1,
            ...scaleOrOptions
        });
    }
    async hostInfo() {
        this._emitDatabaseApiCall('hostInfo', {});
        return await this._runAdminCommand({
            hostInfo: 1,
        });
    }
    async serverCmdLineOpts() {
        this._emitDatabaseApiCall('serverCmdLineOpts', {});
        return await this._runAdminCommand({
            getCmdLineOpts: 1,
        });
    }
    async rotateCertificates(message) {
        this._emitDatabaseApiCall('rotateCertificates', { message });
        return await this._runAdminCommand({
            rotateCertificates: 1, message
        });
    }
    async printCollectionStats(scale = 1) {
        if (typeof scale !== 'number' || scale < 1) {
            throw new errors_1.MongoshInvalidInputError(`scale has to be a number >=1, got ${scale}`, errors_1.CommonErrors.InvalidArgument);
        }
        this._emitDatabaseApiCall('printCollectionStats', { scale: scale });
        const colls = await this.getCollectionNames();
        const result = {};
        for (const c of colls) {
            try {
                result[c] = await this.getCollection(c).stats({ scale });
            }
            catch (error) {
                result[c] = { ok: 0, errmsg: error === null || error === void 0 ? void 0 : error.message };
            }
        }
        return new index_1.CommandResult('StatsResult', result);
    }
    async getFreeMonitoringStatus() {
        this._emitDatabaseApiCall('getFreeMonitoringStatus', {});
        return await this._runAdminCommand({
            getFreeMonitoringStatus: 1,
        });
    }
    async disableFreeMonitoring() {
        this._emitDatabaseApiCall('disableFreeMonitoring', {});
        return await this._runAdminCommand({
            setFreeMonitoring: 1,
            action: 'disable'
        });
    }
    async enableFreeMonitoring() {
        this._emitDatabaseApiCall('enableFreeMonitoring', {});
        const helloResult = await this.hello();
        if (!helloResult.isWritablePrimary) {
            throw new errors_1.MongoshInvalidInputError('db.enableFreeMonitoring() may only be run on a primary', errors_1.CommonErrors.InvalidOperation);
        }
        await this._runAdminCommand({
            setFreeMonitoring: 1,
            action: 'enable'
        });
        let result;
        let error;
        try {
            result = await this._runAdminCommand({ getFreeMonitoringStatus: 1 });
        }
        catch (err) {
            error = err;
        }
        if (error && error.codeName === 'Unauthorized' || (result && !result.ok && result.codeName === 'Unauthorized')) {
            return 'Unable to determine status as you lack the \'checkFreeMonitoringStatus\' privilege.';
        }
        else if (error || !result || !result.ok) {
            throw new errors_1.MongoshRuntimeError(`Error running command setFreeMonitoring ${result ? result.errmsg : error.errmsg}`, errors_1.CommonErrors.CommandFailed);
        }
        if (result.state !== 'enabled') {
            const urlResult = await this._runAdminCommand({
                getParameter: 1,
                cloudFreeMonitoringEndpointURL: 1
            });
            return `Unable to get immediate response from the Cloud Monitoring service. Please check your firewall settings to ensure that mongod can communicate with '${urlResult.cloudFreeMonitoringEndpointURL || '<unknown>'}'`;
        }
        return result;
    }
    async getProfilingStatus() {
        this._emitDatabaseApiCall('getProfilingStatus', {});
        return await this._runCommand({
            profile: -1,
        });
    }
    async setProfilingLevel(level, opts = {}) {
        (0, helpers_1.assertArgsDefinedType)([level], ['number'], 'Database.setProfilingLevel');
        if (level < 0 || level > 2) {
            throw new errors_1.MongoshInvalidInputError(`Input level ${level} is out of range [0..2]`, errors_1.CommonErrors.InvalidArgument);
        }
        if (typeof opts === 'number') {
            opts = { slowms: opts };
        }
        this._emitDatabaseApiCall('setProfilingLevel', { opts: opts });
        return await this._runCommand({
            profile: level,
            ...opts
        });
    }
    async setLogLevel(logLevel, component) {
        (0, helpers_1.assertArgsDefinedType)([logLevel], ['number'], 'Database.setLogLevel');
        this._emitDatabaseApiCall('setLogLevel', { logLevel: logLevel, component: component });
        let componentNames = [];
        if (typeof component === 'string') {
            componentNames = component.split('.');
        }
        else if (component !== undefined) {
            throw new errors_1.MongoshInvalidInputError(`setLogLevel component must be a string: got ${typeof component}`, errors_1.CommonErrors.InvalidArgument);
        }
        let vDoc = { verbosity: logLevel };
        while (componentNames.length > 0) {
            const key = componentNames.pop();
            vDoc = { [key]: vDoc };
        }
        const cmdObj = { setParameter: 1, logComponentVerbosity: vDoc };
        return await this._runAdminCommand(cmdObj);
    }
    async getLogComponents() {
        this._emitDatabaseApiCall('getLogComponents', {});
        const cmdObj = { getParameter: 1, logComponentVerbosity: 1 };
        const result = await this._runAdminCommand(cmdObj);
        if (!result || result.logComponentVerbosity === undefined) {
            throw new errors_1.MongoshRuntimeError(`Error running command  ${result ? result.errmsg || '' : ''}`, errors_1.CommonErrors.CommandFailed);
        }
        return result.logComponentVerbosity;
    }
    cloneDatabase() {
        throw new errors_1.MongoshDeprecatedError('`cloneDatabase()` was removed because it was deprecated in MongoDB 4.0');
    }
    cloneCollection() {
        throw new errors_1.MongoshDeprecatedError('`cloneCollection()` was removed because it was deprecated in MongoDB 4.0');
    }
    copyDatabase() {
        throw new errors_1.MongoshDeprecatedError('`copyDatabase()` was removed because it was deprecated in MongoDB 4.0');
    }
    async commandHelp(name) {
        (0, helpers_1.assertArgsDefinedType)([name], ['string'], 'Database.commandHelp');
        this._emitDatabaseApiCall('commandHelp', { name: name });
        const command = {};
        command[name] = 1;
        command.help = true;
        const result = await this._runCommand(command);
        if (!result || result.help === undefined) {
            throw new errors_1.MongoshRuntimeError(`Error running command commandHelp ${result ? result.errmsg || '' : ''}`, errors_1.CommonErrors.CommandFailed);
        }
        return result.help;
    }
    async listCommands() {
        this._emitDatabaseApiCall('listCommands', {});
        const result = await this._runCommand({
            listCommands: 1,
        });
        if (!result || result.commands === undefined) {
            throw new errors_1.MongoshRuntimeError(`Error running command listCommands ${result ? result.errmsg || '' : ''}`, errors_1.CommonErrors.CommandFailed);
        }
        for (const cmdDescription of Object.values(result.commands)) {
            if ('slaveOk' in cmdDescription) {
                cmdDescription.secondaryOk = cmdDescription.slaveOk;
                delete cmdDescription.slaveOk;
            }
            if ('slaveOverrideOk' in cmdDescription) {
                cmdDescription.secondaryOverrideOk = cmdDescription.slaveOverrideOk;
                delete cmdDescription.slaveOverrideOk;
            }
        }
        return new index_1.CommandResult('ListCommandsResult', result.commands);
    }
    async getLastErrorObj(w, wTimeout, j) {
        await this._instanceState.printDeprecationWarning('Database.getLastErrorObj() is deprecated and will be removed in the future.');
        this._emitDatabaseApiCall('getLastErrorObj', { w: w, wTimeout: wTimeout, j: j });
        return await this._getLastErrorObj(w, wTimeout, j);
    }
    async getLastError(w, wTimeout) {
        await this._instanceState.printDeprecationWarning('Database.getLastError() is deprecated and will be removed in the future.');
        this._emitDatabaseApiCall('getLastError', { w: w, wTimeout: wTimeout });
        const result = await this._getLastErrorObj(w, wTimeout);
        return result.err || null;
    }
    async printShardingStatus(verbose = false) {
        this._emitDatabaseApiCall('printShardingStatus', { verbose });
        const result = await (0, helpers_1.getPrintableShardStatus)(await (0, helpers_1.getConfigDB)(this), verbose);
        return new index_1.CommandResult('StatsResult', result);
    }
    async printSecondaryReplicationInfo() {
        let startOptimeDate = null;
        const local = this.getSiblingDB('local');
        if (await local.getCollection('system.replset').countDocuments({}) !== 0) {
            const status = await this._runAdminCommand({ 'replSetGetStatus': 1 });
            let primary = null;
            for (const member of status.members) {
                if (member.state === 1) {
                    primary = member;
                    break;
                }
            }
            if (primary) {
                startOptimeDate = primary.optimeDate;
            }
            else {
                startOptimeDate = new Date(0, 0);
                for (const member of status.members) {
                    if (member.optimeDate > startOptimeDate) {
                        startOptimeDate = member.optimeDate;
                    }
                }
            }
            const result = {};
            for (const node of status.members) {
                const nodeResult = {};
                if (node === null || node === undefined) {
                    throw new errors_1.MongoshRuntimeError('Member returned from command replSetGetStatus is null', errors_1.CommonErrors.CommandFailed);
                }
                if (node.state === 1 || node.state === 7) {
                    continue;
                }
                if (node.optime && node.health !== 0) {
                    if (startOptimeDate === null || startOptimeDate === undefined) {
                        throw new errors_1.MongoshRuntimeError('getReplLag startOptimeDate is null', errors_1.CommonErrors.CommandFailed);
                    }
                    if (startOptimeDate) {
                        nodeResult.syncedTo = node.optimeDate.toString();
                    }
                    const ago = (node.optimeDate - startOptimeDate) / 1000;
                    const hrs = Math.round(ago / 36) / 100;
                    let suffix = '';
                    if (primary) {
                        suffix = 'primary ';
                    }
                    else {
                        suffix = 'freshest member (no primary available at the moment)';
                    }
                    nodeResult.replLag = `${Math.round(ago)} secs (${hrs} hrs) behind the ${suffix}`;
                }
                else {
                    nodeResult['no replication info, yet.  State'] = node.stateStr;
                }
                result[`source: ${node.name}`] = nodeResult;
            }
            return new index_1.CommandResult('StatsResult', result);
        }
        throw new errors_1.MongoshInvalidInputError('local.system.replset is empty. Are you connected to a replica set?', error_codes_1.ShellApiErrors.NotConnectedToReplicaSet);
    }
    async getReplicationInfo() {
        const localdb = this.getSiblingDB('local');
        const result = {};
        const oplog = 'oplog.rs';
        const localCollections = await localdb.getCollectionNames();
        if (!localCollections.includes(oplog)) {
            throw new errors_1.MongoshInvalidInputError('Replication not detected. Are you connected to a replset?', error_codes_1.ShellApiErrors.NotConnectedToReplicaSet);
        }
        const ol = localdb.getCollection(oplog);
        const [olStats, first, last] = await Promise.all([
            ol.stats(),
            (async () => (await ol.find()).sort({ $natural: 1 }).limit(1).tryNext())(),
            (async () => (await ol.find()).sort({ $natural: -1 }).limit(1).tryNext())()
        ]);
        if (!(olStats === null || olStats === void 0 ? void 0 : olStats.maxSize)) {
            throw new errors_1.MongoshRuntimeError(`Could not get stats for local.${oplog} collection. collstats returned ${JSON.stringify(olStats)}`, errors_1.CommonErrors.CommandFailed);
        }
        result.configuredLogSizeMB = olStats.maxSize / (1024 * 1024);
        result.logSizeMB = Math.max(olStats.maxSize, olStats.size) / (1024 * 1024);
        result.usedMB = olStats.size / (1024 * 1024);
        result.usedMB = Math.ceil(result.usedMB * 100) / 100;
        if (first === null || last === null) {
            throw new errors_1.MongoshRuntimeError('objects not found in local.oplog.$main -- is this a new and empty db instance?', errors_1.CommonErrors.CommandFailed);
        }
        let tfirst = first.ts;
        let tlast = last.ts;
        if (tfirst && tlast) {
            tfirst = (0, helpers_1.tsToSeconds)(tfirst);
            tlast = (0, helpers_1.tsToSeconds)(tlast);
            result.timeDiff = tlast - tfirst;
            result.timeDiffHours = Math.round(result.timeDiff / 36) / 100;
            result.tFirst = (new Date(tfirst * 1000)).toString();
            result.tLast = (new Date(tlast * 1000)).toString();
            result.now = Date();
        }
        else {
            result.errmsg = 'ts element not found in oplog objects';
        }
        return result;
    }
    async printReplicationInfo() {
        const result = {};
        let replInfo;
        try {
            replInfo = await this.getReplicationInfo();
        }
        catch (error) {
            const helloResult = await this.hello();
            if (helloResult.arbiterOnly) {
                return new index_1.CommandResult('StatsResult', { message: 'cannot provide replication status from an arbiter' });
            }
            else if (!helloResult.isWritablePrimary) {
                const secondaryInfo = await this.printSecondaryReplicationInfo();
                return new index_1.CommandResult('StatsResult', {
                    message: 'this is a secondary, printing secondary replication info.',
                    ...secondaryInfo.value
                });
            }
            throw error;
        }
        result['actual oplog size'] = `${replInfo.logSizeMB} MB`;
        result['configured oplog size'] = `${replInfo.configuredLogSizeMB} MB`;
        result['log length start to end'] = `${replInfo.timeDiff} secs (${replInfo.timeDiffHours} hrs)`;
        result['oplog first event time'] = replInfo.tFirst;
        result['oplog last event time'] = replInfo.tLast;
        result.now = replInfo.now;
        return new index_1.CommandResult('StatsResult', result);
    }
    printSlaveReplicationInfo() {
        throw new errors_1.MongoshDeprecatedError('Method deprecated, use db.printSecondaryReplicationInfo instead');
    }
    async setSecondaryOk() {
        await this._mongo.setSecondaryOk();
    }
    async watch(pipeline = [], options = {}) {
        if (!Array.isArray(pipeline)) {
            options = pipeline;
            pipeline = [];
        }
        this._emitDatabaseApiCall('watch', { pipeline, options });
        const cursor = new change_stream_cursor_1.default(this._mongo._serviceProvider.watch(pipeline, {
            ...await this._baseOptions(),
            ...options
        }, {}, this._name), this._name, this._mongo);
        if (!options.resumeAfter && !options.startAfter && !options.startAtOperationTime) {
            await cursor.tryNext();
        }
        this._mongo._instanceState.currentCursor = cursor;
        return cursor;
    }
    async sql(sqlString, options) {
        var _a;
        this._emitDatabaseApiCall('sql', { sqlString: sqlString, options });
        await this._instanceState.shellApi.print('Note: this is an experimental feature that may be subject to change in future releases.');
        const cursor = await this.aggregate([{
                $sql: {
                    statement: sqlString,
                    format: 'jdbc',
                    dialect: 'mongosql',
                    formatVersion: 1
                }
            }], options);
        try {
            await cursor.hasNext();
        }
        catch (err) {
            if (((_a = err.code) === null || _a === void 0 ? void 0 : _a.valueOf()) === 40324) {
                throw new errors_1.MongoshRuntimeError('db.sql currently only works when connected to a Data Lake', errors_1.CommonErrors.CommandFailed);
            }
            throw err;
        }
        return cursor;
    }
    async checkMetadataConsistency(options = {}) {
        this._emitDatabaseApiCall('checkMetadataConsistency', { options });
        return this._runCursorCommand({
            checkMetadataConsistency: 1
        });
    }
};
__decorate([
    (0, decorators_1.returnType)('Mongo')
], Database.prototype, "getMongo", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Database.prototype, "getCollectionNames", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['3.0.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Database.prototype, "getCollectionInfos", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Database.prototype, "runCommand", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Database.prototype, "adminCommand", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.returnType)('AggregationCursor'),
    (0, decorators_1.apiVersions)([1])
], Database.prototype, "aggregate", null);
__decorate([
    (0, decorators_1.returnType)('Database')
], Database.prototype, "getSiblingDB", null);
__decorate([
    (0, decorators_1.returnType)('Collection')
], Database.prototype, "getCollection", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Database.prototype, "dropDatabase", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "createUser", null);
__decorate([
    decorators_1.returnsPromise
], Database.prototype, "updateUser", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "changeUserPassword", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "logout", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "dropUser", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "dropAllUsers", null);
__decorate([
    decorators_1.returnsPromise
], Database.prototype, "auth", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "grantRolesToUser", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "revokeRolesFromUser", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "getUser", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "getUsers", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Database.prototype, "createCollection", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Database.prototype, "createEncryptedCollection", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Database.prototype, "createView", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "createRole", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "updateRole", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "dropRole", null);
__decorate([
    decorators_1.returnsPromise
], Database.prototype, "dropAllRoles", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "grantRolesToRole", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "revokeRolesFromRole", null);
__decorate([
    decorators_1.returnsPromise
], Database.prototype, "grantPrivilegesToRole", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "revokePrivilegesFromRole", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "getRole", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "getRoles", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "currentOp", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "killOp", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "shutdownServer", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "fsyncLock", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "fsyncUnlock", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "version", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "serverBits", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "isMaster", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1]),
    (0, decorators_1.serverVersions)(['5.0.0', enums_1.ServerVersions.latest])
], Database.prototype, "hello", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "serverBuildInfo", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "serverStatus", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "stats", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "hostInfo", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "serverCmdLineOpts", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['5.0.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([])
], Database.prototype, "rotateCertificates", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "printCollectionStats", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    decorators_1.deprecated
], Database.prototype, "getFreeMonitoringStatus", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    decorators_1.deprecated
], Database.prototype, "disableFreeMonitoring", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    decorators_1.deprecated
], Database.prototype, "enableFreeMonitoring", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "getProfilingStatus", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "setProfilingLevel", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "setLogLevel", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "getLogComponents", null);
__decorate([
    decorators_1.deprecated
], Database.prototype, "cloneDatabase", null);
__decorate([
    decorators_1.deprecated
], Database.prototype, "cloneCollection", null);
__decorate([
    decorators_1.deprecated
], Database.prototype, "copyDatabase", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Database.prototype, "commandHelp", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "listCommands", null);
__decorate([
    decorators_1.deprecated,
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "getLastErrorObj", null);
__decorate([
    decorators_1.deprecated,
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Database.prototype, "getLastError", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.topologies)([enums_1.Topologies.Sharded]),
    (0, decorators_1.apiVersions)([1])
], Database.prototype, "printShardingStatus", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.topologies)([enums_1.Topologies.ReplSet]),
    (0, decorators_1.apiVersions)([])
], Database.prototype, "printSecondaryReplicationInfo", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.topologies)([enums_1.Topologies.ReplSet]),
    (0, decorators_1.apiVersions)([])
], Database.prototype, "getReplicationInfo", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([]),
    (0, decorators_1.topologies)([enums_1.Topologies.ReplSet])
], Database.prototype, "printReplicationInfo", null);
__decorate([
    decorators_1.deprecated
], Database.prototype, "printSlaveReplicationInfo", null);
__decorate([
    decorators_1.deprecated,
    decorators_1.returnsPromise
], Database.prototype, "setSecondaryOk", null);
__decorate([
    (0, decorators_1.serverVersions)(['3.1.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.topologies)([enums_1.Topologies.ReplSet, enums_1.Topologies.Sharded]),
    (0, decorators_1.apiVersions)([1]),
    decorators_1.returnsPromise
], Database.prototype, "watch", null);
__decorate([
    (0, decorators_1.serverVersions)(['4.4.0', enums_1.ServerVersions.latest]),
    decorators_1.returnsPromise,
    (0, decorators_1.returnType)('AggregationCursor')
], Database.prototype, "sql", null);
__decorate([
    (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.topologies)([enums_1.Topologies.Sharded]),
    decorators_1.returnsPromise
], Database.prototype, "checkMetadataConsistency", null);
Database = __decorate([
    decorators_1.shellApiClassDefault
], Database);
exports.default = Database;
//# sourceMappingURL=database.js.map