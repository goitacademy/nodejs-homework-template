"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("@mongosh/errors");
const decorators_1 = require("./decorators");
const enums_1 = require("./enums");
const aggregate_or_find_cursor_1 = require("./aggregate-or-find-cursor");
let Cursor = class Cursor extends aggregate_or_find_cursor_1.AggregateOrFindCursor {
    constructor(mongo, cursor) {
        super(mongo, cursor);
        this._tailable = false;
    }
    _addFlag(flag) {
        this._cursor.addCursorFlag(flag, true);
    }
    addOption(optionFlagNumber) {
        if (optionFlagNumber === 4) {
            throw new errors_1.MongoshUnimplementedError('the slaveOk option is not supported.', errors_1.CommonErrors.NotImplemented);
        }
        const optionFlag = enums_1.CURSOR_FLAGS[optionFlagNumber];
        if (!optionFlag) {
            throw new errors_1.MongoshInvalidInputError(`Unknown option flag number: ${optionFlagNumber}.`, errors_1.CommonErrors.InvalidArgument);
        }
        this._cursor.addCursorFlag(optionFlag, true);
        return this;
    }
    allowDiskUse(allow) {
        this._cursor.allowDiskUse(allow);
        return this;
    }
    allowPartialResults() {
        this._addFlag('partial');
        return this;
    }
    collation(spec) {
        this._cursor.collation(spec);
        return this;
    }
    comment(cmt) {
        this._cursor.comment(cmt);
        return this;
    }
    async count() {
        return this._cursor.count();
    }
    async hasNext() {
        if (this._tailable) {
            await this._instanceState.printWarning('If this is a tailable cursor with awaitData, and there are no documents in the batch, this method ' +
                'will will block. Use tryNext if you want to check if there are any documents without waiting.');
        }
        return super.hasNext();
    }
    hint(index) {
        this._cursor.hint(index);
        return this;
    }
    limit(value) {
        this._cursor.limit(value);
        return this;
    }
    max(indexBounds) {
        this._cursor.max(indexBounds);
        return this;
    }
    maxAwaitTimeMS(value) {
        this._cursor.maxAwaitTimeMS(value);
        return this;
    }
    min(indexBounds) {
        this._cursor.min(indexBounds);
        return this;
    }
    async next() {
        if (this._tailable) {
            await this._instanceState.printWarning('If this is a tailable cursor with awaitData, and there are no documents in the batch, this' +
                ' method will will block. Use tryNext if you want to check if there are any documents without waiting.');
        }
        return super.next();
    }
    noCursorTimeout() {
        this._addFlag('noCursorTimeout');
        return this;
    }
    oplogReplay() {
        this._addFlag('oplogReplay');
        return this;
    }
    readPref(mode, tagSet, hedgeOptions) {
        let pref;
        if (tagSet || hedgeOptions) {
            pref = this._mongo._serviceProvider.readPreferenceFromOptions({
                readPreference: mode,
                readPreferenceTags: tagSet,
                hedge: hedgeOptions
            });
        }
        else {
            pref = mode;
        }
        this._cursor = this._cursor.withReadPreference(pref);
        return this;
    }
    returnKey(enabled) {
        this._cursor.returnKey(enabled);
        return this;
    }
    async size() {
        return this._cursor.count();
    }
    tailable(opts = { awaitData: false }) {
        this._tailable = true;
        this._addFlag('tailable');
        if (opts.awaitData) {
            this._addFlag('awaitData');
        }
        return this;
    }
    maxScan() {
        throw new errors_1.MongoshDeprecatedError('`maxScan()` was removed because it was deprecated in MongoDB 4.0');
    }
    showRecordId() {
        this._cursor.showRecordId(true);
        return this;
    }
    readConcern(level) {
        this._cursor = this._cursor.withReadConcern({ level });
        return this;
    }
};
__decorate([
    (0, decorators_1.returnType)('Cursor'),
    (0, decorators_1.serverVersions)([enums_1.ServerVersions.earliest, '3.2.0'])
], Cursor.prototype, "addOption", null);
__decorate([
    (0, decorators_1.returnType)('Cursor'),
    (0, decorators_1.serverVersions)(['4.4.0', enums_1.ServerVersions.latest])
], Cursor.prototype, "allowDiskUse", null);
__decorate([
    (0, decorators_1.returnType)('Cursor')
], Cursor.prototype, "allowPartialResults", null);
__decorate([
    (0, decorators_1.returnType)('Cursor'),
    (0, decorators_1.serverVersions)(['3.4.0', enums_1.ServerVersions.latest])
], Cursor.prototype, "collation", null);
__decorate([
    (0, decorators_1.returnType)('Cursor'),
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest])
], Cursor.prototype, "comment", null);
__decorate([
    (0, decorators_1.serverVersions)([enums_1.ServerVersions.earliest, '4.0.0']),
    decorators_1.returnsPromise,
    decorators_1.deprecated
], Cursor.prototype, "count", null);
__decorate([
    decorators_1.returnsPromise
], Cursor.prototype, "hasNext", null);
__decorate([
    (0, decorators_1.returnType)('Cursor')
], Cursor.prototype, "hint", null);
__decorate([
    (0, decorators_1.returnType)('Cursor')
], Cursor.prototype, "limit", null);
__decorate([
    (0, decorators_1.returnType)('Cursor')
], Cursor.prototype, "max", null);
__decorate([
    (0, decorators_1.returnType)('Cursor'),
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest])
], Cursor.prototype, "maxAwaitTimeMS", null);
__decorate([
    (0, decorators_1.returnType)('Cursor')
], Cursor.prototype, "min", null);
__decorate([
    decorators_1.returnsPromise
], Cursor.prototype, "next", null);
__decorate([
    (0, decorators_1.returnType)('Cursor')
], Cursor.prototype, "noCursorTimeout", null);
__decorate([
    (0, decorators_1.returnType)('Cursor')
], Cursor.prototype, "oplogReplay", null);
__decorate([
    (0, decorators_1.returnType)('Cursor')
], Cursor.prototype, "readPref", null);
__decorate([
    (0, decorators_1.returnType)('Cursor'),
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest])
], Cursor.prototype, "returnKey", null);
__decorate([
    decorators_1.returnsPromise
], Cursor.prototype, "size", null);
__decorate([
    (0, decorators_1.returnType)('Cursor'),
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([])
], Cursor.prototype, "tailable", null);
__decorate([
    decorators_1.deprecated,
    (0, decorators_1.serverVersions)([enums_1.ServerVersions.earliest, '4.0.0'])
], Cursor.prototype, "maxScan", null);
__decorate([
    (0, decorators_1.returnType)('Cursor'),
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest])
], Cursor.prototype, "showRecordId", null);
__decorate([
    (0, decorators_1.returnType)('Cursor')
], Cursor.prototype, "readConcern", null);
Cursor = __decorate([
    decorators_1.shellApiClassDefault
], Cursor);
exports.default = Cursor;
//# sourceMappingURL=cursor.js.map