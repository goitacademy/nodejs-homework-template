"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("./decorators");
const enums_1 = require("./enums");
const helpers_1 = require("./helpers");
const index_1 = require("./index");
const errors_1 = require("@mongosh/errors");
const bulk_1 = __importDefault(require("./bulk"));
const history_1 = require("@mongosh/history");
const plan_cache_1 = __importDefault(require("./plan-cache"));
const change_stream_cursor_1 = __importDefault(require("./change-stream-cursor"));
const error_codes_1 = require("./error-codes");
let Collection = class Collection extends decorators_1.ShellApiWithMongoClass {
    constructor(mongo, database, name) {
        super();
        this._mongo = mongo;
        this._database = database;
        this._name = name;
        const proxy = new Proxy(this, {
            get: (target, prop) => {
                if (prop in target) {
                    return target[prop];
                }
                if (typeof prop !== 'string' ||
                    prop.startsWith('_') ||
                    !(0, helpers_1.isValidCollectionName)(prop)) {
                    return;
                }
                return database.getCollection(`${name}.${prop}`);
            }
        });
        return proxy;
    }
    [enums_1.namespaceInfo]() {
        return { db: this._database.getName(), collection: this._name };
    }
    [enums_1.asPrintable]() {
        return `${this._database.getName()}.${this._name}`;
    }
    _emitCollectionApiCall(methodName, methodArguments = {}) {
        this._mongo._instanceState.emitApiCallWithArgs({
            method: methodName,
            class: 'Collection',
            db: this._database._name,
            coll: this._name,
            arguments: methodArguments
        });
    }
    async aggregate(...args) {
        let options;
        let pipeline;
        if (args.length === 0 || Array.isArray(args[0])) {
            options = args[1] || {};
            pipeline = args[0] || [];
        }
        else {
            options = {};
            pipeline = args || [];
        }
        this._emitCollectionApiCall('aggregate', { options, pipeline });
        const { aggOptions, dbOptions, explain } = (0, helpers_1.adaptAggregateOptions)(options);
        const providerCursor = this._mongo._serviceProvider.aggregate(this._database._name, this._name, pipeline, { ...await this._database._baseOptions(), ...aggOptions }, dbOptions);
        const cursor = new index_1.AggregationCursor(this._mongo, providerCursor);
        if (explain) {
            return await cursor.explain(explain);
        }
        else if ((0, helpers_1.shouldRunAggregationImmediately)(pipeline)) {
            await cursor.hasNext();
        }
        this._mongo._instanceState.currentCursor = cursor;
        return cursor;
    }
    async bulkWrite(operations, options = {}) {
        this._emitCollectionApiCall('bulkWrite', { options });
        const result = await this._mongo._serviceProvider.bulkWrite(this._database._name, this._name, operations, { ...await this._database._baseOptions(), ...options });
        return new index_1.BulkWriteResult(!!result.ok, result.insertedCount, result.insertedIds, result.matchedCount, result.modifiedCount, result.deletedCount, result.upsertedCount, result.upsertedIds);
    }
    async count(query = {}, options = {}) {
        await this._instanceState.printDeprecationWarning('Collection.count() is deprecated. Use countDocuments or estimatedDocumentCount.');
        this._emitCollectionApiCall('count', { query, options });
        return this._mongo._serviceProvider.count(this._database._name, this._name, query, { ...await this._database._baseOptions(), ...options });
    }
    async countDocuments(query, options = {}) {
        this._emitCollectionApiCall('countDocuments', { query, options });
        return this._mongo._serviceProvider.countDocuments(this._database._name, this._name, query, { ...await this._database._baseOptions(), ...options });
    }
    async deleteMany(filter, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([filter], [true], 'Collection.deleteMany');
        this._emitCollectionApiCall('deleteMany', { filter, options });
        const result = await this._mongo._serviceProvider.deleteMany(this._database._name, this._name, filter, { ...await this._database._baseOptions(), ...options });
        if (options.explain) {
            return (0, helpers_1.markAsExplainOutput)(result);
        }
        return new index_1.DeleteResult(!!result.acknowledged, result.deletedCount);
    }
    async deleteOne(filter, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([filter], [true], 'Collection.deleteOne');
        this._emitCollectionApiCall('deleteOne', { filter, options });
        const result = await this._mongo._serviceProvider.deleteOne(this._database._name, this._name, filter, { ...await this._database._baseOptions(), ...options });
        if (options.explain) {
            return (0, helpers_1.markAsExplainOutput)(result);
        }
        return new index_1.DeleteResult(!!result.acknowledged, result.deletedCount);
    }
    async distinct(field, query, options = {}) {
        this._emitCollectionApiCall('distinct', { field, query, options });
        return (0, helpers_1.maybeMarkAsExplainOutput)(await this._mongo._serviceProvider.distinct(this._database._name, this._name, field, query, { ...await this._database._baseOptions(), ...options }), options);
    }
    async estimatedDocumentCount(options = {}) {
        this._emitCollectionApiCall('estimatedDocumentCount', { options });
        return this._mongo._serviceProvider.estimatedDocumentCount(this._database._name, this._name, { ...await this._database._baseOptions(), ...options });
    }
    async find(query, projection, options = {}) {
        if (projection) {
            options.projection = projection;
        }
        this._emitCollectionApiCall('find', { query, options });
        const cursor = new index_1.Cursor(this._mongo, this._mongo._serviceProvider.find(this._database._name, this._name, query, { ...await this._database._baseOptions(), ...options }));
        this._mongo._instanceState.currentCursor = cursor;
        return cursor;
    }
    async findAndModify(options) {
        (0, helpers_1.assertArgsDefinedType)([options], [true], 'Collection.findAndModify');
        (0, helpers_1.assertKeysDefined)(options, ['query']);
        this._emitCollectionApiCall('findAndModify', { options: { ...options, update: !!options.update } });
        const reducedOptions = { ...options };
        delete reducedOptions.query;
        delete reducedOptions.update;
        if (options.remove) {
            return this.findOneAndDelete(options.query, reducedOptions);
        }
        const { update } = options;
        if (!update) {
            throw new errors_1.MongoshInvalidInputError('Must specify options.update or options.remove', errors_1.CommonErrors.InvalidArgument);
        }
        if (Array.isArray(update) || Object.keys(update).some(key => key.startsWith('$'))) {
            return this.findOneAndUpdate(options.query, update, reducedOptions);
        }
        return this.findOneAndReplace(options.query, update, reducedOptions);
    }
    async findOne(query = {}, projection, options = {}) {
        if (projection) {
            options.projection = projection;
        }
        this._emitCollectionApiCall('findOne', { query, options });
        return new index_1.Cursor(this._mongo, this._mongo._serviceProvider.find(this._database._name, this._name, query, { ...await this._database._baseOptions(), ...options })).limit(1).tryNext();
    }
    async renameCollection(newName, dropTarget) {
        (0, helpers_1.assertArgsDefinedType)([newName], ['string'], 'Collection.renameCollection');
        this._emitCollectionApiCall('renameCollection', { newName, dropTarget });
        try {
            await this._mongo._serviceProvider.renameCollection(this._database._name, this._name, newName, { ...await this._database._baseOptions(), dropTarget: !!dropTarget });
            return {
                ok: 1
            };
        }
        catch (e) {
            if ((e === null || e === void 0 ? void 0 : e.name) === 'MongoError') {
                return {
                    ok: 0,
                    errmsg: e.errmsg,
                    code: e.code,
                    codeName: e.codeName
                };
            }
            throw e;
        }
    }
    async findOneAndDelete(filter, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([filter], [true], 'Collection.findOneAndDelete');
        this._emitCollectionApiCall('findOneAndDelete', { filter, options });
        const result = await this._mongo._serviceProvider.findOneAndDelete(this._database._name, this._name, filter, { ...await this._database._baseOptions(), ...options });
        if (options.explain) {
            return (0, helpers_1.markAsExplainOutput)(result);
        }
        return result.value;
    }
    async findOneAndReplace(filter, replacement, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([filter], [true], 'Collection.findOneAndReplace');
        const findOneAndReplaceOptions = (0, helpers_1.processFindAndModifyOptions)({
            ...await this._database._baseOptions(),
            ...options
        });
        this._emitCollectionApiCall('findOneAndReplace', { filter, findOneAndReplaceOptions });
        const result = await this._mongo._serviceProvider.findOneAndReplace(this._database._name, this._name, filter, replacement, findOneAndReplaceOptions);
        if (options.explain) {
            return (0, helpers_1.markAsExplainOutput)(result);
        }
        return result.value;
    }
    async findOneAndUpdate(filter, update, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([filter], [true], 'Collection.findOneAndUpdate');
        const findOneAndUpdateOptions = (0, helpers_1.processFindAndModifyOptions)({
            ...await this._database._baseOptions(),
            ...options
        });
        this._emitCollectionApiCall('findOneAndUpdate', { filter, findOneAndUpdateOptions });
        const result = await this._mongo._serviceProvider.findOneAndUpdate(this._database._name, this._name, filter, update, findOneAndUpdateOptions);
        if (options.explain) {
            return (0, helpers_1.markAsExplainOutput)(result);
        }
        return result.value;
    }
    async insert(docs, options = {}) {
        await this._instanceState.printDeprecationWarning('Collection.insert() is deprecated. Use insertOne, insertMany, or bulkWrite.');
        (0, helpers_1.assertArgsDefinedType)([docs], [true], 'Collection.insert');
        const docsToInsert = Array.isArray(docs) ? docs.map((doc) => ({ ...doc })) : [{ ...docs }];
        this._emitCollectionApiCall('insert', { options });
        const result = await this._mongo._serviceProvider.insertMany(this._database._name, this._name, docsToInsert, { ...await this._database._baseOptions(), ...options });
        return new index_1.InsertManyResult(!!result.acknowledged, result.insertedIds);
    }
    async insertMany(docs, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([docs], [true], 'Collection.insertMany');
        const docsToInsert = Array.isArray(docs) ? docs.map((doc) => ({ ...doc })) : docs;
        this._emitCollectionApiCall('insertMany', { options });
        const result = await this._mongo._serviceProvider.insertMany(this._database._name, this._name, docsToInsert, { ...await this._database._baseOptions(), ...options });
        return new index_1.InsertManyResult(!!result.acknowledged, result.insertedIds);
    }
    async insertOne(doc, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([doc], [true], 'Collection.insertOne');
        this._emitCollectionApiCall('insertOne', { options });
        const result = await this._mongo._serviceProvider.insertOne(this._database._name, this._name, { ...doc }, { ...await this._database._baseOptions(), ...options });
        return new index_1.InsertOneResult(!!result.acknowledged, result.insertedId);
    }
    async isCapped() {
        var _a, _b;
        this._emitCollectionApiCall('isCapped');
        const colls = await this._database._listCollections({ name: this._name }, { nameOnly: false });
        if (colls.length === 0) {
            throw new errors_1.MongoshRuntimeError(`collection ${this.getFullName()} not found`);
        }
        return !!((_b = (_a = colls[0]) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.capped);
    }
    async remove(query, options = {}) {
        await this._instanceState.printDeprecationWarning('Collection.remove() is deprecated. Use deleteOne, deleteMany, findOneAndDelete, or bulkWrite.');
        (0, helpers_1.assertArgsDefinedType)([query], [true], 'Collection.remove');
        const removeOptions = (0, helpers_1.processRemoveOptions)(options);
        const method = removeOptions.justOne ? 'deleteOne' : 'deleteMany';
        delete removeOptions.justOne;
        this._emitCollectionApiCall('remove', { query, removeOptions });
        const result = await this._mongo._serviceProvider[method](this._database._name, this._name, query, { ...await this._database._baseOptions(), ...removeOptions });
        if (removeOptions.explain) {
            return (0, helpers_1.markAsExplainOutput)(result);
        }
        return new index_1.DeleteResult(!!result.acknowledged, result.deletedCount);
    }
    async replaceOne(filter, replacement, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([filter], [true], 'Collection.replaceOne');
        this._emitCollectionApiCall('replaceOne', { filter, options });
        const result = await this._mongo._serviceProvider.replaceOne(this._database._name, this._name, filter, replacement, { ...await this._database._baseOptions(), ...options });
        return new index_1.UpdateResult(!!result.acknowledged, result.matchedCount, result.modifiedCount, result.upsertedCount, result.upsertedId);
    }
    async update(filter, update, options = {}) {
        await this._instanceState.printDeprecationWarning('Collection.update() is deprecated. Use updateOne, updateMany, or bulkWrite.');
        (0, helpers_1.assertArgsDefinedType)([filter, update], [true, true], 'Collection.update');
        this._emitCollectionApiCall('update', { filter, options });
        let result;
        if (options.multi) {
            result = await this._mongo._serviceProvider.updateMany(this._database._name, this._name, filter, update, { ...await this._database._baseOptions(), ...options });
        }
        else {
            result = await this._mongo._serviceProvider.updateOne(this._database._name, this._name, filter, update, { ...await this._database._baseOptions(), ...options });
        }
        if (options.explain) {
            return (0, helpers_1.markAsExplainOutput)(result);
        }
        return new index_1.UpdateResult(!!result.acknowledged, result.matchedCount, result.modifiedCount, result.upsertedCount, result.upsertedId);
    }
    async updateMany(filter, update, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([filter], [true], 'Collection.updateMany');
        this._emitCollectionApiCall('updateMany', { filter, options });
        const result = await this._mongo._serviceProvider.updateMany(this._database._name, this._name, filter, update, { ...await this._database._baseOptions(), ...options });
        if (options.explain) {
            return (0, helpers_1.markAsExplainOutput)(result);
        }
        return new index_1.UpdateResult(!!result.acknowledged, result.matchedCount, result.modifiedCount, result.upsertedCount, result.upsertedId);
    }
    async updateOne(filter, update, options = {}) {
        (0, helpers_1.assertArgsDefinedType)([filter], [true], 'Collection.updateOne');
        this._emitCollectionApiCall('updateOne', { filter, options });
        const result = await this._mongo._serviceProvider.updateOne(this._database._name, this._name, filter, update, { ...await this._database._baseOptions(), ...options });
        if (options.explain) {
            return (0, helpers_1.markAsExplainOutput)(result);
        }
        return new index_1.UpdateResult(!!result.acknowledged, result.matchedCount, result.modifiedCount, result.upsertedCount, result.upsertedId);
    }
    async compactStructuredEncryptionData() {
        if (!this._mongo._fleOptions) {
            throw new errors_1.MongoshInvalidInputError('The "compactStructuredEncryptionData" command requires Mongo instance configured with auto encryption.', errors_1.CommonErrors.InvalidArgument);
        }
        this._emitCollectionApiCall('compactStructuredEncryptionData');
        return await this._database._runCommand({ compactStructuredEncryptionData: this._name });
    }
    async convertToCapped(size) {
        this._emitCollectionApiCall('convertToCapped', { size });
        return await this._database._runCommand({
            convertToCapped: this._name,
            size
        });
    }
    async _createIndexes(keyPatterns, options = {}, commitQuorum) {
        (0, helpers_1.assertArgsDefinedType)([keyPatterns], [true], 'Collection.createIndexes');
        if (typeof options !== 'object' || Array.isArray(options)) {
            throw new errors_1.MongoshInvalidInputError('The "options" argument must be an object.', errors_1.CommonErrors.InvalidArgument);
        }
        const specs = keyPatterns.map((pattern) => ({
            ...options, key: pattern
        }));
        const createIndexesOptions = { ...await this._database._baseOptions(), ...options };
        if (undefined !== commitQuorum) {
            createIndexesOptions.commitQuorum = commitQuorum;
        }
        return await this._mongo._serviceProvider.createIndexes(this._database._name, this._name, specs, createIndexesOptions);
    }
    async createIndexes(keyPatterns, options = {}, commitQuorum) {
        const specs = keyPatterns.map((pattern) => ({
            ...options, key: pattern
        }));
        this._emitCollectionApiCall('createIndexes', { specs });
        return this._createIndexes(keyPatterns, options, commitQuorum);
    }
    async createIndex(keys, options = {}, commitQuorum) {
        (0, helpers_1.assertArgsDefinedType)([keys], [true], 'Collection.createIndex');
        if (typeof options !== 'object' || Array.isArray(options)) {
            throw new errors_1.MongoshInvalidInputError('The "options" argument must be an object.', errors_1.CommonErrors.InvalidArgument);
        }
        this._emitCollectionApiCall('createIndex', { keys, options });
        const names = await this._createIndexes([keys], options, commitQuorum);
        if (!Array.isArray(names) || names.length !== 1) {
            throw new errors_1.MongoshInternalError(`Expected createIndexes() to return array of length 1, saw ${names}`);
        }
        return names[0];
    }
    async ensureIndex(keys, options = {}, commitQuorum) {
        this._emitCollectionApiCall('ensureIndex', { keys, options });
        return await this._createIndexes([keys], options, commitQuorum);
    }
    async getIndexes() {
        this._emitCollectionApiCall('getIndexes');
        return await this._mongo._serviceProvider.getIndexes(this._database._name, this._name, await this._database._baseOptions());
    }
    async getIndexSpecs() {
        this._emitCollectionApiCall('getIndexSpecs');
        return await this._mongo._serviceProvider.getIndexes(this._database._name, this._name, await this._database._baseOptions());
    }
    async getIndices() {
        this._emitCollectionApiCall('getIndices');
        return await this._mongo._serviceProvider.getIndexes(this._database._name, this._name, await this._database._baseOptions());
    }
    async getIndexKeys() {
        this._emitCollectionApiCall('getIndexKeys');
        const indexes = await this._mongo._serviceProvider.getIndexes(this._database._name, this._name, await this._database._baseOptions());
        return indexes.map(i => i.key);
    }
    async dropIndexes(indexes = '*') {
        this._emitCollectionApiCall('dropIndexes', { indexes });
        try {
            return await this._database._runCommand({
                dropIndexes: this._name,
                index: indexes,
            });
        }
        catch (error) {
            if (((error === null || error === void 0 ? void 0 : error.codeName) === 'IndexNotFound' || (error === null || error === void 0 ? void 0 : error.codeName) === undefined) &&
                ((error === null || error === void 0 ? void 0 : error.errmsg) === 'invalid index name spec' || (error === null || error === void 0 ? void 0 : error.errmsg) === undefined) &&
                Array.isArray(indexes) &&
                indexes.length > 0 &&
                (await this._database.version()).match(/^4\.0\./)) {
                const all = await Promise.all(indexes.map(async (index) => await this.dropIndexes(index)));
                const errored = all.find(result => !result.ok);
                if (errored)
                    return errored;
                return all.sort((a, b) => b.nIndexesWas - a.nIndexesWas)[0];
            }
            if ((error === null || error === void 0 ? void 0 : error.codeName) === 'IndexNotFound') {
                return {
                    ok: error.ok,
                    errmsg: error.errmsg,
                    code: error.code,
                    codeName: error.codeName
                };
            }
            throw error;
        }
    }
    async dropIndex(index) {
        (0, helpers_1.assertArgsDefinedType)([index], [true], 'Collection.dropIndex');
        this._emitCollectionApiCall('dropIndex', { index });
        if (index === '*') {
            throw new errors_1.MongoshInvalidInputError('To drop indexes in the collection using \'*\', use db.collection.dropIndexes().', errors_1.CommonErrors.InvalidArgument);
        }
        if (Array.isArray(index)) {
            throw new errors_1.MongoshInvalidInputError('The index to drop must be either the index name or the index specification document.', errors_1.CommonErrors.InvalidArgument);
        }
        return this.dropIndexes(index);
    }
    async _getSingleStorageStatValue(key) {
        const cursor = await this.aggregate([
            { $collStats: { storageStats: {} } },
            { $group: { _id: null, value: { $sum: `$storageStats.${key}` } } }
        ]);
        const [{ value }] = await cursor.toArray();
        return value;
    }
    async totalIndexSize(...args) {
        this._emitCollectionApiCall('totalIndexSize');
        if (args.length) {
            throw new errors_1.MongoshInvalidInputError('"totalIndexSize" takes no argument. Use db.collection.stats to get detailed information.', errors_1.CommonErrors.InvalidArgument);
        }
        return this._getSingleStorageStatValue('totalIndexSize');
    }
    async reIndex() {
        this._emitCollectionApiCall('reIndex');
        return await this._database._runCommand({
            reIndex: this._name
        });
    }
    getDB() {
        this._emitCollectionApiCall('getDB');
        return this._database;
    }
    getMongo() {
        this._emitCollectionApiCall('getMongo');
        return this._mongo;
    }
    async dataSize() {
        this._emitCollectionApiCall('dataSize');
        return this._getSingleStorageStatValue('size');
    }
    async storageSize() {
        this._emitCollectionApiCall('storageSize');
        return this._getSingleStorageStatValue('storageSize');
    }
    async totalSize() {
        this._emitCollectionApiCall('totalSize');
        return this._getSingleStorageStatValue('totalSize');
    }
    async drop(options = {}) {
        var _a, _b, _c;
        this._emitCollectionApiCall('drop');
        let encryptedFieldsOptions = {};
        const encryptedFieldsMap = (_a = this._mongo._fleOptions) === null || _a === void 0 ? void 0 : _a.encryptedFieldsMap;
        const encryptedFields = encryptedFieldsMap === null || encryptedFieldsMap === void 0 ? void 0 : encryptedFieldsMap[`${this._database._name}.${this._name}`];
        if (!encryptedFields && !options.encryptedFields) {
            try {
                const collectionInfos = await this._mongo._serviceProvider.listCollections(this._database._name, {
                    name: this._name
                }, await this._database._baseOptions());
                const encryptedFields = (_c = (_b = collectionInfos === null || collectionInfos === void 0 ? void 0 : collectionInfos[0]) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.encryptedFields;
                if (encryptedFields) {
                    encryptedFieldsOptions = { encryptedFields };
                }
            }
            catch (error) {
            }
        }
        try {
            return await this._mongo._serviceProvider.dropCollection(this._database._name, this._name, { ...await this._database._baseOptions(), ...options, ...encryptedFieldsOptions });
        }
        catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.codeName) === 'NamespaceNotFound') {
                this._mongo._instanceState.messageBus.emit('mongosh:warn', {
                    method: 'drop',
                    class: 'Collection',
                    message: `Namespace not found: ${this._name}`
                });
                return false;
            }
            throw error;
        }
    }
    async exists() {
        this._emitCollectionApiCall('exists');
        const collectionInfos = await this._mongo._serviceProvider.listCollections(this._database._name, {
            name: this._name
        }, await this._database._baseOptions());
        return collectionInfos[0] || null;
    }
    getFullName() {
        this._emitCollectionApiCall('getFullName');
        return `${this._database._name}.${this._name}`;
    }
    getName() {
        this._emitCollectionApiCall('getName');
        return `${this._name}`;
    }
    async runCommand(commandName, options) {
        (0, helpers_1.assertArgsDefinedType)([commandName], [['string', 'object']], 'Collection.runCommand');
        if (options) {
            if (typeof commandName !== 'string') {
                throw new errors_1.MongoshInvalidInputError('Collection.runCommand takes a command string as its first arugment', errors_1.CommonErrors.InvalidArgument);
            }
            else if (commandName in options) {
                throw new errors_1.MongoshInvalidInputError('The "commandName" argument cannot be passed as an option to "runCommand".', errors_1.CommonErrors.InvalidArgument);
            }
        }
        const hiddenCommands = new RegExp(history_1.HIDDEN_COMMANDS);
        if (typeof commandName === 'string' && !hiddenCommands.test(commandName)) {
            this._emitCollectionApiCall('runCommand', { commandName });
        }
        const cmd = typeof commandName === 'string' ? {
            [commandName]: this._name,
            ...options
        } : commandName;
        return await this._database._runCommand(cmd);
    }
    explain(verbosity = 'queryPlanner') {
        verbosity = (0, helpers_1.validateExplainableVerbosity)(verbosity);
        this._emitCollectionApiCall('explain', { verbosity });
        return new index_1.Explainable(this._mongo, this, verbosity);
    }
    async _getLegacyCollStats(scale) {
        const result = await this._database._runCommand({
            collStats: this._name,
            scale: scale || 1
        });
        if (!result) {
            throw new errors_1.MongoshRuntimeError(`Error running collStats command on ${this.getFullName()}`, errors_1.CommonErrors.CommandFailed);
        }
        return result;
    }
    async _aggregateAndScaleCollStats(collStats, scale) {
        var _a;
        const result = {
            ok: 1,
        };
        const shardStats = {};
        const counts = {};
        const indexSizes = {};
        const clusterTimeseriesStats = {};
        let maxSize = 0;
        let unscaledCollSize = 0;
        let nindexes = 0;
        let timeseriesBucketsNs;
        let timeseriesTotalBucketSize = 0;
        for (const shardResult of collStats) {
            const shardStorageStats = shardResult.storageStats;
            const countField = shardStorageStats.count;
            const shardObjCount = (typeof countField !== 'undefined') ? countField : 0;
            for (const fieldName of Object.keys(shardStorageStats)) {
                if (['ns', 'ok', 'lastExtentSize', 'paddingFactor'].includes(fieldName)) {
                    continue;
                }
                if ([
                    'userFlags', 'capped', 'max', 'paddingFactorNote', 'indexDetails', 'wiredTiger'
                ].includes(fieldName)) {
                    (_a = result[fieldName]) !== null && _a !== void 0 ? _a : (result[fieldName] = shardStorageStats[fieldName]);
                }
                else if (fieldName === 'timeseries') {
                    const shardTimeseriesStats = shardStorageStats[fieldName];
                    for (const [timeseriesStatName, timeseriesStat] of Object.entries(shardTimeseriesStats)) {
                        if (typeof timeseriesStat === 'string') {
                            if (!timeseriesBucketsNs) {
                                timeseriesBucketsNs = timeseriesStat;
                            }
                        }
                        else if (timeseriesStatName === 'avgBucketSize') {
                            timeseriesTotalBucketSize += (0, helpers_1.coerceToJSNumber)(shardTimeseriesStats.bucketCount) * (0, helpers_1.coerceToJSNumber)(timeseriesStat);
                        }
                        else {
                            if (clusterTimeseriesStats[timeseriesStatName] === undefined) {
                                clusterTimeseriesStats[timeseriesStatName] = 0;
                            }
                            clusterTimeseriesStats[timeseriesStatName] += (0, helpers_1.coerceToJSNumber)(timeseriesStat);
                        }
                    }
                }
                else if (['count', 'size', 'storageSize', 'totalIndexSize', 'totalSize', 'numOrphanDocs'].includes(fieldName)) {
                    if (counts[fieldName] === undefined) {
                        counts[fieldName] = 0;
                    }
                    counts[fieldName] += (0, helpers_1.coerceToJSNumber)(shardStorageStats[fieldName]);
                }
                else if (fieldName === 'avgObjSize') {
                    const shardAvgObjSize = (0, helpers_1.coerceToJSNumber)(shardStorageStats[fieldName]);
                    unscaledCollSize += shardAvgObjSize * shardObjCount;
                }
                else if (fieldName === 'maxSize') {
                    const shardMaxSize = (0, helpers_1.coerceToJSNumber)(shardStorageStats[fieldName]);
                    maxSize = Math.max(maxSize, shardMaxSize);
                }
                else if (fieldName === 'indexSizes') {
                    for (const indexName of Object.keys(shardStorageStats[fieldName])) {
                        if (indexSizes[indexName] === undefined) {
                            indexSizes[indexName] = 0;
                        }
                        indexSizes[indexName] += (0, helpers_1.coerceToJSNumber)(shardStorageStats[fieldName][indexName]);
                    }
                }
                else if (fieldName === 'nindexes') {
                    const shardIndexes = shardStorageStats[fieldName];
                    if (nindexes === 0) {
                        nindexes = shardIndexes;
                    }
                    else if (shardIndexes > nindexes) {
                        nindexes = shardIndexes;
                    }
                }
            }
            if (shardResult.shard) {
                shardStats[shardResult.shard] = (0, helpers_1.scaleIndividualShardStatistics)(shardStorageStats, scale);
            }
        }
        const ns = `${this._database._name}.${this._name}`;
        const config = this._mongo.getDB('config');
        if (collStats[0].shard) {
            result.shards = shardStats;
        }
        try {
            result.sharded = !!(await config.getCollection('collections').findOne({
                _id: timeseriesBucketsNs !== null && timeseriesBucketsNs !== void 0 ? timeseriesBucketsNs : ns,
                dropped: { $ne: true }
            }));
        }
        catch (e) {
            result.sharded = collStats.length > 1;
        }
        for (const [countField, count] of Object.entries(counts)) {
            if (['size', 'storageSize', 'totalIndexSize', 'totalSize'].includes(countField)) {
                result[countField] = count / scale;
            }
            else {
                result[countField] = count;
            }
        }
        if (timeseriesBucketsNs && Object.keys(clusterTimeseriesStats).length > 0) {
            result.timeseries = {
                ...clusterTimeseriesStats,
                avgBucketSize: clusterTimeseriesStats.bucketCount
                    ? timeseriesTotalBucketSize / clusterTimeseriesStats.bucketCount
                    : 0,
                bucketsNs: timeseriesBucketsNs
            };
        }
        result.indexSizes = {};
        for (const [indexName, indexSize] of Object.entries(indexSizes)) {
            result.indexSizes[indexName] = indexSize / scale;
        }
        if (counts.count > 0) {
            result.avgObjSize = unscaledCollSize / counts.count;
        }
        else {
            result.avgObjSize = 0;
        }
        if (result.capped) {
            result.maxSize = maxSize / scale;
        }
        result.ns = ns;
        result.nindexes = nindexes;
        if (collStats[0].storageStats.scaleFactor !== undefined) {
            result.scaleFactor = scale;
        }
        result.ok = 1;
        return result;
    }
    async _getAggregatedCollStats(scale) {
        try {
            const collStats = await (await this.aggregate([{
                    $collStats: {
                        storageStats: {
                            scale: 1,
                        }
                    }
                }])).toArray();
            if (!collStats || collStats[0] === undefined) {
                throw new errors_1.MongoshRuntimeError(`Error running $collStats aggregation stage on ${this.getFullName()}`, errors_1.CommonErrors.CommandFailed);
            }
            return await this._aggregateAndScaleCollStats(collStats, scale);
        }
        catch (e) {
            if ((e === null || e === void 0 ? void 0 : e.code) === 13388) {
                try {
                    return await this._getLegacyCollStats(scale);
                }
                catch (legacyCollStatsError) {
                    throw e;
                }
            }
            throw e;
        }
    }
    async stats(originalOptions = {}) {
        var _a;
        const options = typeof originalOptions === 'number' ? { scale: originalOptions } : originalOptions;
        if (options.indexDetailsKey && options.indexDetailsName) {
            throw new errors_1.MongoshInvalidInputError('Cannot filter indexDetails on both indexDetailsKey and indexDetailsName', errors_1.CommonErrors.InvalidArgument);
        }
        if (options.indexDetailsKey && typeof options.indexDetailsKey !== 'object') {
            throw new errors_1.MongoshInvalidInputError(`Expected options.indexDetailsKey to be a document, got ${typeof options.indexDetailsKey}`, errors_1.CommonErrors.InvalidArgument);
        }
        if (options.indexDetailsName && typeof options.indexDetailsName !== 'string') {
            throw new errors_1.MongoshInvalidInputError(`Expected options.indexDetailsName to be a string, got ${typeof options.indexDetailsName}`, errors_1.CommonErrors.InvalidArgument);
        }
        options.scale = options.scale || 1;
        options.indexDetails = options.indexDetails || false;
        this._emitCollectionApiCall('stats', { options });
        const result = await this._getAggregatedCollStats(options.scale);
        let filterIndexName = options.indexDetailsName;
        if (!filterIndexName && options.indexDetailsKey) {
            const indexes = await this._mongo._serviceProvider.getIndexes(this._database._name, this._name, await this._database._baseOptions());
            indexes.forEach((spec) => {
                if (JSON.stringify(spec.key) === JSON.stringify(options.indexDetailsKey)) {
                    filterIndexName = spec.name;
                }
            });
        }
        const updateStats = (stats) => {
            if (!stats.indexDetails) {
                return;
            }
            if (!options.indexDetails) {
                delete stats.indexDetails;
                return;
            }
            if (!filterIndexName) {
                return;
            }
            for (const key of Object.keys(stats.indexDetails)) {
                if (key === filterIndexName) {
                    continue;
                }
                delete stats.indexDetails[key];
            }
        };
        updateStats(result);
        for (const shardName of Object.keys((_a = result.shards) !== null && _a !== void 0 ? _a : {})) {
            updateStats(result.shards[shardName]);
        }
        return result;
    }
    async latencyStats(options = {}) {
        this._emitCollectionApiCall('latencyStats', { options });
        return await (await this.aggregate([{ $collStats: { latencyStats: options } }])).toArray();
    }
    async initializeOrderedBulkOp() {
        this._emitCollectionApiCall('initializeOrderedBulkOp');
        const innerBulk = await this._mongo._serviceProvider.initializeBulkOp(this._database._name, this._name, true, await this._database._baseOptions());
        return new bulk_1.default(this, innerBulk, true);
    }
    async initializeUnorderedBulkOp() {
        this._emitCollectionApiCall('initializeUnorderedBulkOp');
        const innerBulk = await this._mongo._serviceProvider.initializeBulkOp(this._database._name, this._name, false, await this._database._baseOptions());
        return new bulk_1.default(this, innerBulk);
    }
    getPlanCache() {
        this._emitCollectionApiCall('getPlanCache');
        return new plan_cache_1.default(this);
    }
    async mapReduce(map, reduce, optionsOrOutString) {
        await this._instanceState.printDeprecationWarning('Collection.mapReduce() is deprecated. Use an aggregation instead.\nSee https://docs.mongodb.com/manual/core/map-reduce for details.');
        (0, helpers_1.assertArgsDefinedType)([map, reduce, optionsOrOutString], [true, true, true], 'Collection.mapReduce');
        this._emitCollectionApiCall('mapReduce', { map, reduce, out: optionsOrOutString });
        let cmd = {
            mapReduce: this._name,
            map: map,
            reduce: reduce,
            ...(0, helpers_1.processMapReduceOptions)(optionsOrOutString)
        };
        if (cmd.explain) {
            const verbosity = cmd.explain;
            delete cmd.explain;
            cmd = {
                explain: cmd,
                verbosity
            };
        }
        return await this._database._runCommand(cmd);
    }
    async validate(options = false) {
        this._emitCollectionApiCall('validate', { options });
        if (typeof options === 'boolean') {
            options = { full: options };
        }
        return await this._database._runCommand({
            validate: this._name,
            ...options
        });
    }
    async getShardVersion() {
        this._emitCollectionApiCall('getShardVersion', {});
        return await this._database._runAdminCommand({
            getShardVersion: `${this._database._name}.${this._name}`
        });
    }
    async getShardDistribution() {
        this._emitCollectionApiCall('getShardDistribution', {});
        const result = {};
        const config = this._mongo.getDB('config');
        const ns = `${this._database._name}.${this._name}`;
        const configCollectionsInfo = await config.getCollection('collections').findOne({
            _id: ns,
            dropped: { $ne: true }
        });
        if (!configCollectionsInfo) {
            throw new errors_1.MongoshInvalidInputError(`Collection ${this._name} is not sharded`, error_codes_1.ShellApiErrors.NotConnectedToShardedCluster);
        }
        const collStats = await (await this.aggregate({ '$collStats': { storageStats: {} } })).toArray();
        const totals = { numChunks: 0, size: 0, count: 0 };
        const conciseShardsStats = [];
        await Promise.all(collStats.map((extShardStats) => ((async () => {
            const { shard } = extShardStats;
            const countChunksQuery = { ...(0, helpers_1.buildConfigChunksCollectionMatch)(configCollectionsInfo), shard };
            const [host, numChunks] = await Promise.all([
                config.getCollection('shards').findOne({ _id: extShardStats.shard }),
                config.getCollection('chunks').countDocuments(countChunksQuery)
            ]);
            const shardStats = {
                shardId: shard,
                host: host !== null ? host.host : null,
                size: extShardStats.storageStats.size,
                count: extShardStats.storageStats.count,
                numChunks: numChunks,
                avgObjSize: extShardStats.storageStats.avgObjSize
            };
            const key = `Shard ${shardStats.shardId} at ${shardStats.host}`;
            const estChunkData = (shardStats.numChunks === 0) ? 0 : (shardStats.size / shardStats.numChunks);
            const estChunkCount = (shardStats.numChunks === 0) ? 0 : Math.floor(shardStats.count / shardStats.numChunks);
            result[key] = {
                data: (0, helpers_1.dataFormat)((0, helpers_1.coerceToJSNumber)(shardStats.size)),
                docs: shardStats.count,
                chunks: shardStats.numChunks,
                'estimated data per chunk': (0, helpers_1.dataFormat)(estChunkData),
                'estimated docs per chunk': estChunkCount
            };
            totals.size += (0, helpers_1.coerceToJSNumber)(shardStats.size);
            totals.count += (0, helpers_1.coerceToJSNumber)(shardStats.count);
            totals.numChunks += (0, helpers_1.coerceToJSNumber)(shardStats.numChunks);
            conciseShardsStats.push(shardStats);
        })())));
        const totalValue = {
            data: (0, helpers_1.dataFormat)(totals.size),
            docs: totals.count,
            chunks: totals.numChunks
        };
        for (const shardStats of conciseShardsStats) {
            const estDataPercent = (totals.size === 0) ? 0 : (Math.floor(shardStats.size / totals.size * 10000) / 100);
            const estDocPercent = (totals.count === 0) ? 0 : (Math.floor(shardStats.count / totals.count * 10000) / 100);
            totalValue[`Shard ${shardStats.shardId}`] = [
                `${estDataPercent} % data`,
                `${estDocPercent} % docs in cluster`,
                `${(0, helpers_1.dataFormat)(shardStats.avgObjSize)} avg obj size on shard`
            ];
        }
        result.Totals = totalValue;
        return new index_1.CommandResult('StatsResult', result);
    }
    async watch(pipeline = [], options = {}) {
        if (!Array.isArray(pipeline)) {
            options = pipeline;
            pipeline = [];
        }
        this._emitCollectionApiCall('watch', { pipeline, options });
        const cursor = new change_stream_cursor_1.default(this._mongo._serviceProvider.watch(pipeline, {
            ...await this._database._baseOptions(),
            ...options
        }, {}, this._database._name, this._name), this._name, this._mongo);
        if (!options.resumeAfter && !options.startAfter && !options.startAtOperationTime) {
            await cursor.tryNext();
        }
        this._mongo._instanceState.currentCursor = cursor;
        return cursor;
    }
    async hideIndex(index) {
        this._emitCollectionApiCall('hideIndex');
        return (0, helpers_1.setHideIndex)(this, index, true);
    }
    async unhideIndex(index) {
        this._emitCollectionApiCall('unhideIndex');
        return (0, helpers_1.setHideIndex)(this, index, false);
    }
    async analyzeShardKey(key) {
        (0, helpers_1.assertArgsDefinedType)([key], [true], 'Collection.analyzeShardKey');
        this._emitCollectionApiCall('analyzeShardKey', { key });
        return await this._database._runAdminCommand({
            analyzeShardKey: this.getFullName(),
            key
        });
    }
    async configureQueryAnalyzer(options) {
        this._emitCollectionApiCall('configureQueryAnalyzer', options);
        return await this._database._runAdminCommand({
            configureQueryAnalyzer: this.getFullName(),
            ...options
        });
    }
    async checkMetadataConsistency(options = {}) {
        this._emitCollectionApiCall('checkMetadataConsistency', { options });
        return this._database._runCursorCommand({
            checkMetadataConsistency: this._name
        });
    }
    async getSearchIndexes(indexName, options) {
        if (typeof indexName === 'object' && indexName !== null) {
            options = indexName;
            indexName = undefined;
        }
        this._emitCollectionApiCall('getSearchIndexes', { options });
        return await this._mongo._serviceProvider.getSearchIndexes(this._database._name, this._name, indexName, { ...await this._database._baseOptions(), ...options });
    }
    async createSearchIndex(indexName, definition) {
        var _a;
        if (typeof indexName === 'object' && indexName !== null) {
            definition = indexName;
            indexName = undefined;
        }
        this._emitCollectionApiCall('createSearchIndex', { indexName, definition });
        const results = await this._mongo._serviceProvider.createSearchIndexes(this._database._name, this._name, [{ name: (_a = indexName) !== null && _a !== void 0 ? _a : 'default', definition: { ...definition } }]);
        return results[0];
    }
    async createSearchIndexes(specs) {
        this._emitCollectionApiCall('createSearchIndexes', { specs });
        return await this._mongo._serviceProvider.createSearchIndexes(this._database._name, this._name, specs);
    }
    async dropSearchIndex(indexName) {
        this._emitCollectionApiCall('dropSearchIndex', { indexName });
        return await this._mongo._serviceProvider.dropSearchIndex(this._database._name, this._name, indexName);
    }
    async updateSearchIndex(indexName, definition) {
        this._emitCollectionApiCall('updateSearchIndex', { indexName, definition });
        return await this._mongo._serviceProvider.updateSearchIndex(this._database._name, this._name, indexName, definition);
    }
};
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.returnType)('AggregationCursor'),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "aggregate", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "bulkWrite", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    (0, decorators_1.serverVersions)([enums_1.ServerVersions.earliest, '4.0.0']),
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "count", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['4.0.3', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "countDocuments", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "deleteMany", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "deleteOne", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "distinct", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['4.0.3', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "estimatedDocumentCount", null);
__decorate([
    (0, decorators_1.returnType)('Cursor'),
    (0, decorators_1.apiVersions)([1]),
    decorators_1.returnsPromise
], Collection.prototype, "find", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "findAndModify", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.returnType)('Document'),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "findOne", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "renameCollection", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.returnType)('Document'),
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "findOneAndDelete", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.returnType)('Document'),
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "findOneAndReplace", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.returnType)('Document'),
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "findOneAndUpdate", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    (0, decorators_1.serverVersions)([enums_1.ServerVersions.earliest, '3.6.0']),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "insert", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "insertMany", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "insertOne", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "isCapped", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    (0, decorators_1.serverVersions)([enums_1.ServerVersions.earliest, '3.2.0']),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "remove", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "replaceOne", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    (0, decorators_1.serverVersions)([enums_1.ServerVersions.earliest, '3.2.0']),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "update", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "updateMany", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "updateOne", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "compactStructuredEncryptionData", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "convertToCapped", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "createIndexes", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "createIndex", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "ensureIndex", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "getIndexes", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "getIndexSpecs", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "getIndices", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.serverVersions)(['3.2.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "getIndexKeys", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "dropIndexes", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "dropIndex", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "totalIndexSize", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    (0, decorators_1.topologies)([enums_1.Topologies.Standalone]),
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "reIndex", null);
__decorate([
    (0, decorators_1.returnType)('Database')
], Collection.prototype, "getDB", null);
__decorate([
    (0, decorators_1.returnType)('Mongo')
], Collection.prototype, "getMongo", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "dataSize", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "storageSize", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "totalSize", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "drop", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "exists", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "runCommand", null);
__decorate([
    (0, decorators_1.returnType)('Explainable'),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "explain", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "stats", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "latencyStats", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.returnType)('Bulk'),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "initializeOrderedBulkOp", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.returnType)('Bulk'),
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "initializeUnorderedBulkOp", null);
__decorate([
    (0, decorators_1.returnType)('PlanCache'),
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "getPlanCache", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    (0, decorators_1.serverVersions)([enums_1.ServerVersions.earliest, '4.9.0']),
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "mapReduce", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "validate", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.topologies)([enums_1.Topologies.Sharded]),
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "getShardVersion", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.topologies)([enums_1.Topologies.Sharded]),
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "getShardDistribution", null);
__decorate([
    (0, decorators_1.serverVersions)(['3.1.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.topologies)([enums_1.Topologies.ReplSet, enums_1.Topologies.Sharded]),
    (0, decorators_1.apiVersions)([1]),
    decorators_1.returnsPromise
], Collection.prototype, "watch", null);
__decorate([
    (0, decorators_1.serverVersions)(['4.4.0', enums_1.ServerVersions.latest]),
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "hideIndex", null);
__decorate([
    (0, decorators_1.serverVersions)(['4.4.0', enums_1.ServerVersions.latest]),
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], Collection.prototype, "unhideIndex", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.topologies)([enums_1.Topologies.ReplSet, enums_1.Topologies.Sharded]),
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "analyzeShardKey", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.topologies)([enums_1.Topologies.ReplSet, enums_1.Topologies.Sharded]),
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "configureQueryAnalyzer", null);
__decorate([
    (0, decorators_1.serverVersions)(['7.0.0', enums_1.ServerVersions.latest]),
    (0, decorators_1.topologies)([enums_1.Topologies.Sharded]),
    decorators_1.returnsPromise
], Collection.prototype, "checkMetadataConsistency", null);
__decorate([
    (0, decorators_1.serverVersions)(['6.0.0', enums_1.ServerVersions.latest]),
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "getSearchIndexes", null);
__decorate([
    (0, decorators_1.serverVersions)(['6.0.0', enums_1.ServerVersions.latest]),
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "createSearchIndex", null);
__decorate([
    (0, decorators_1.serverVersions)(['6.0.0', enums_1.ServerVersions.latest]),
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "createSearchIndexes", null);
__decorate([
    (0, decorators_1.serverVersions)(['6.0.0', enums_1.ServerVersions.latest]),
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "dropSearchIndex", null);
__decorate([
    (0, decorators_1.serverVersions)(['6.0.0', enums_1.ServerVersions.latest]),
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([])
], Collection.prototype, "updateSearchIndex", null);
Collection = __decorate([
    decorators_1.shellApiClassDefault,
    decorators_1.addSourceToResults
], Collection);
exports.default = Collection;
//# sourceMappingURL=collection.js.map