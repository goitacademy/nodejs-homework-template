"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyVault = exports.ClientEncryption = void 0;
const decorators_1 = require("./decorators");
const cursor_1 = __importDefault(require("./cursor"));
const helpers_1 = require("./helpers");
const enums_1 = require("./enums");
const history_1 = require("@mongosh/history");
const errors_1 = require("@mongosh/errors");
const isDataKeyEncryptionKeyOptions = (options) => {
    return (!Array.isArray(options) &&
        typeof options === 'object' &&
        ('masterKey' in options || 'keyAltNames' in options || 'keyMaterial' in options));
};
const isMasterKey = (options) => {
    return (!Array.isArray(options) &&
        typeof options === 'object' &&
        !isDataKeyEncryptionKeyOptions(options));
};
const NO_RESULT_PLACEHOLDER_DOC = Object.freeze({
    [Symbol('no result -- will return `null` in future mongosh versions')]: true
});
async function makeSingleDocReturnValue(makeCursor, method, instanceState) {
    let cursor = await makeCursor();
    let doc = null;
    try {
        doc = await cursor.limit(1).next();
    }
    catch (_a) { }
    finally {
        if (typeof cursor._cursor.rewind === 'function') {
            cursor._cursor.rewind();
        }
        else {
            cursor = await makeCursor();
        }
    }
    const warn = () => {
        void instanceState.printDeprecationWarning(`${method} returns a single document and will stop providing cursor methods in future versions of mongosh.`);
    };
    return new Proxy(doc !== null && doc !== void 0 ? doc : NO_RESULT_PLACEHOLDER_DOC, {
        get(target, property, receiver) {
            if (property === enums_1.shellApiType) {
                return 'Document';
            }
            if (property === enums_1.asPrintable) {
                return;
            }
            if (property in target) {
                return Reflect.get(target, property, receiver);
            }
            if (typeof property !== 'symbol' && property in cursor) {
                warn();
            }
            return Reflect.get(cursor, property);
        },
        getOwnPropertyDescriptor(target, property) {
            if (property in target) {
                return Reflect.getOwnPropertyDescriptor(target, property);
            }
            if (typeof property !== 'symbol' && property in cursor) {
                warn();
            }
            return Reflect.getOwnPropertyDescriptor(cursor, property);
        },
        has(target, property) {
            return property in target || property in cursor;
        }
    });
}
let ClientEncryption = class ClientEncryption extends decorators_1.ShellApiWithMongoClass {
    constructor(mongo) {
        super();
        this._mongo = mongo;
        const fle = mongo._serviceProvider.fle;
        if (!fle) {
            throw new errors_1.MongoshRuntimeError('FLE API is not available');
        }
        const fleOptions = { ...this._mongo._fleOptions };
        delete fleOptions.schemaMap;
        delete fleOptions.encryptedFieldsMap;
        this._libmongocrypt = new fle.ClientEncryption(mongo._serviceProvider.getRawClient(), fleOptions);
    }
    [enums_1.asPrintable]() {
        return `ClientEncryption class for ${(0, history_1.redactURICredentials)(this._mongo._uri)}`;
    }
    async encrypt(keyId, value, algorithmOrEncryptionOptions) {
        let encryptionOptions;
        if (typeof algorithmOrEncryptionOptions === 'object') {
            encryptionOptions = {
                keyId,
                ...algorithmOrEncryptionOptions
            };
        }
        else {
            encryptionOptions = {
                keyId,
                algorithm: algorithmOrEncryptionOptions
            };
        }
        (0, helpers_1.assertArgsDefinedType)([keyId, value, encryptionOptions], [true, true, true], 'ClientEncryption.encrypt');
        return await this._libmongocrypt.encrypt(value, encryptionOptions);
    }
    async decrypt(encryptedValue) {
        (0, helpers_1.assertArgsDefinedType)([encryptedValue], [true], 'ClientEncryption.decrypt');
        return await this._libmongocrypt.decrypt(encryptedValue);
    }
    async encryptExpression(keyId, value, options) {
        (0, helpers_1.assertArgsDefinedType)([keyId, value, options], [true, true, true], 'ClientEncryption.encryptExpression');
        return await this._libmongocrypt.encryptExpression(value, { keyId, ...options });
    }
    async createEncryptedCollection(dbName, collName, options) {
        (0, helpers_1.assertArgsDefinedType)([dbName], ['string'], 'ClientEncryption.createEncryptedCollection');
        (0, helpers_1.assertArgsDefinedType)([collName], ['string'], 'ClientEncryption.createEncryptedCollection');
        (0, helpers_1.assertArgsDefinedType)([options], ['object'], 'ClientEncryption.createEncryptedCollection');
        (0, helpers_1.assertKeysDefined)(options, ['provider', 'createCollectionOptions']);
        if (!this._mongo._serviceProvider.createEncryptedCollection) {
            throw new errors_1.MongoshRuntimeError('Runtime does not support createEncryptedCollection yet');
        }
        const { encryptedFields } = await this._mongo._serviceProvider.createEncryptedCollection(dbName, collName, options, this._libmongocrypt);
        return {
            collection: this._mongo.getDB(dbName).getCollection(collName),
            encryptedFields
        };
    }
};
__decorate([
    decorators_1.returnsPromise
], ClientEncryption.prototype, "encrypt", null);
__decorate([
    decorators_1.returnsPromise
], ClientEncryption.prototype, "decrypt", null);
__decorate([
    decorators_1.returnsPromise
], ClientEncryption.prototype, "encryptExpression", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], ClientEncryption.prototype, "createEncryptedCollection", null);
ClientEncryption = __decorate([
    decorators_1.shellApiClassDefault,
    (0, decorators_1.classPlatforms)(['CLI'])
], ClientEncryption);
exports.ClientEncryption = ClientEncryption;
let KeyVault = class KeyVault extends decorators_1.ShellApiWithMongoClass {
    constructor(clientEncryption) {
        var _a, _b, _c;
        super();
        this._mongo = clientEncryption._mongo;
        this._clientEncryption = clientEncryption;
        const keyVaultNamespace = (_b = (_a = this._mongo) === null || _a === void 0 ? void 0 : _a._fleOptions) === null || _b === void 0 ? void 0 : _b.keyVaultNamespace;
        if (!keyVaultNamespace) {
            throw new errors_1.MongoshInvalidInputError('FLE options must be passed to the Mongo object');
        }
        const parsedNamespace = (_c = keyVaultNamespace.match(/^(?<db>[^.]+)\.(?<coll>.+)$/)) === null || _c === void 0 ? void 0 : _c.groups;
        if (!parsedNamespace) {
            throw new errors_1.MongoshInvalidInputError(`Invalid keyVaultNamespace '${keyVaultNamespace}'`);
        }
        const { db, coll } = parsedNamespace;
        this._keyColl = this._mongo.getDB(db).getCollection(coll);
    }
    async _init() {
        try {
            const existingIndexKeys = await this._keyColl.getIndexKeys();
            if (existingIndexKeys.some(key => key.keyAltNames)) {
                return;
            }
        }
        catch (_a) {
        }
        try {
            await this._keyColl.updateMany({ 'keyAltNames': { $size: 0 } }, { $unset: { 'keyAltNames': '' }, $currentDate: { 'updateDate': true } });
            await this._keyColl.createIndex({ keyAltNames: 1 }, { unique: true, partialFilterExpression: { keyAltNames: { $exists: true } } });
        }
        catch (err) {
            await this._instanceState.printWarning(`Creating 'keyAltNames' index on '${this._keyColl.getFullName()}' failed: ${err.message}`);
        }
    }
    [enums_1.asPrintable]() {
        return `KeyVault class for ${(0, history_1.redactURICredentials)(this._mongo._uri)}`;
    }
    async createKey(kms, masterKeyOrAltNamesOrDataKeyOptions, legacyKeyAltNames) {
        let masterKey;
        let keyAltNames;
        let keyMaterial;
        if (isDataKeyEncryptionKeyOptions(masterKeyOrAltNamesOrDataKeyOptions)) {
            masterKey = masterKeyOrAltNamesOrDataKeyOptions === null || masterKeyOrAltNamesOrDataKeyOptions === void 0 ? void 0 : masterKeyOrAltNamesOrDataKeyOptions.masterKey;
            keyAltNames = masterKeyOrAltNamesOrDataKeyOptions === null || masterKeyOrAltNamesOrDataKeyOptions === void 0 ? void 0 : masterKeyOrAltNamesOrDataKeyOptions.keyAltNames;
            keyMaterial = masterKeyOrAltNamesOrDataKeyOptions === null || masterKeyOrAltNamesOrDataKeyOptions === void 0 ? void 0 : masterKeyOrAltNamesOrDataKeyOptions.keyMaterial;
        }
        else if (isMasterKey(masterKeyOrAltNamesOrDataKeyOptions)) {
            masterKey = masterKeyOrAltNamesOrDataKeyOptions;
        }
        if (legacyKeyAltNames) {
            keyAltNames = legacyKeyAltNames;
        }
        (0, helpers_1.assertArgsDefinedType)([kms], [true], 'KeyVault.createKey');
        if (typeof masterKeyOrAltNamesOrDataKeyOptions === 'string') {
            if (kms === 'local' && masterKeyOrAltNamesOrDataKeyOptions === '') {
                masterKey = undefined;
            }
            else {
                throw new errors_1.MongoshInvalidInputError('KeyVault.createKey does not support providing masterKey as string anymore. For AWS please use createKey("aws", { region: ..., key: ... })', errors_1.CommonErrors.Deprecated);
            }
        }
        else if (Array.isArray(masterKeyOrAltNamesOrDataKeyOptions)) {
            if (kms !== 'local') {
                throw new errors_1.MongoshInvalidInputError('KeyVault.createKey requires masterKey to be given as second argument if KMS is not local', errors_1.CommonErrors.InvalidArgument);
            }
            else {
                if (keyAltNames) {
                    throw new errors_1.MongoshInvalidInputError('KeyVault.createKey was supplied with an array for the masterKey and keyAltNames - either specify keyAltNames as second argument or set undefined for masterKey', errors_1.CommonErrors.InvalidArgument);
                }
                keyAltNames = masterKeyOrAltNamesOrDataKeyOptions;
                masterKey = undefined;
            }
        }
        let options;
        if (masterKey) {
            options = { ...(options !== null && options !== void 0 ? options : {}), masterKey };
        }
        if (keyAltNames) {
            options = { ...(options !== null && options !== void 0 ? options : {}), keyAltNames };
        }
        if (keyMaterial) {
            options = { ...(options !== null && options !== void 0 ? options : {}), keyMaterial };
        }
        return await this._clientEncryption._libmongocrypt.createDataKey(kms, options);
    }
    async getKey(keyId) {
        (0, helpers_1.assertArgsDefinedType)([keyId], [true], 'KeyVault.getKey');
        return await makeSingleDocReturnValue(() => this._keyColl.find({ '_id': keyId }), 'KeyVault.getKey', this._instanceState);
    }
    async getKeyByAltName(keyAltName) {
        (0, helpers_1.assertArgsDefinedType)([keyAltName], ['string'], 'KeyVault.getKeyByAltName');
        return await makeSingleDocReturnValue(() => this._keyColl.find({ 'keyAltNames': keyAltName }), 'KeyVault.getKeyByAltName', this._instanceState);
    }
    async getKeys() {
        return new cursor_1.default(this._mongo, this._clientEncryption._libmongocrypt.getKeys());
    }
    async deleteKey(keyId) {
        (0, helpers_1.assertArgsDefinedType)([keyId], [true], 'KeyVault.deleteKey');
        return this._clientEncryption._libmongocrypt.deleteKey(keyId);
    }
    async addKeyAlternateName(keyId, keyAltName) {
        (0, helpers_1.assertArgsDefinedType)([keyId, keyAltName], [true, 'string'], 'KeyVault.addKeyAlternateName');
        return this._clientEncryption._libmongocrypt.addKeyAltName(keyId, keyAltName);
    }
    async removeKeyAlternateName(keyId, keyAltName) {
        (0, helpers_1.assertArgsDefinedType)([keyId, keyAltName], [true, 'string'], 'KeyVault.removeKeyAlternateName');
        return this._clientEncryption._libmongocrypt.removeKeyAltName(keyId, keyAltName);
    }
    async rewrapManyDataKey(filter, options) {
        return this._clientEncryption._libmongocrypt.rewrapManyDataKey(filter, options);
    }
    async createDataKey(...args) {
        return await this.createKey(...args);
    }
    async removeKeyAltName(...args) {
        return await this.removeKeyAlternateName(...args);
    }
    async addKeyAltName(...args) {
        return await this.addKeyAlternateName(...args);
    }
};
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], KeyVault.prototype, "createKey", null);
__decorate([
    (0, decorators_1.returnType)('Cursor'),
    (0, decorators_1.apiVersions)([1]),
    decorators_1.returnsPromise
], KeyVault.prototype, "getKey", null);
__decorate([
    (0, decorators_1.returnType)('Cursor'),
    (0, decorators_1.apiVersions)([1]),
    decorators_1.returnsPromise
], KeyVault.prototype, "getKeyByAltName", null);
__decorate([
    (0, decorators_1.returnType)('Cursor'),
    (0, decorators_1.apiVersions)([1]),
    decorators_1.returnsPromise
], KeyVault.prototype, "getKeys", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], KeyVault.prototype, "deleteKey", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], KeyVault.prototype, "addKeyAlternateName", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], KeyVault.prototype, "removeKeyAlternateName", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], KeyVault.prototype, "rewrapManyDataKey", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], KeyVault.prototype, "createDataKey", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], KeyVault.prototype, "removeKeyAltName", null);
__decorate([
    decorators_1.returnsPromise,
    (0, decorators_1.apiVersions)([1])
], KeyVault.prototype, "addKeyAltName", null);
KeyVault = __decorate([
    decorators_1.shellApiClassDefault,
    (0, decorators_1.classPlatforms)(['CLI'])
], KeyVault);
exports.KeyVault = KeyVault;
//# sourceMappingURL=field-level-encryption.js.map