"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSecureHTTPUrl = exports.normalizeObject = exports.withLock = exports.timeoutSignal = exports.AbortSignal = exports.AbortController = exports.errorString = exports.withAbortCheck = exports.throwIfAborted = void 0;
class AbortError extends Error {
    constructor() {
        super('The operation was aborted');
    }
}
function throwIfAborted(signal) {
    if (signal?.aborted)
        throw signal.reason ?? new AbortError();
}
exports.throwIfAborted = throwIfAborted;
async function withAbortCheck(signal, fn) {
    const signalCheck = () => throwIfAborted(signal);
    let reject;
    const signalPromise = new Promise((resolve, rej) => {
        reject = rej;
    });
    function listener() {
        reject(signal?.reason ?? new AbortError());
    }
    signalPromise.catch(() => {
        /* squelch UnhandledPromiseRejectionWarning */
    });
    signalCheck();
    signal?.addEventListener('abort', listener, { once: true });
    try {
        return await fn({ signalCheck, signalPromise });
    }
    finally {
        signal?.removeEventListener('abort', listener);
    }
}
exports.withAbortCheck = withAbortCheck;
function errorString(err) {
    return String(typeof err === 'object' && err && 'message' in err ? err.message : err);
}
exports.errorString = errorString;
exports.AbortController = 
// eslint-disable-next-line @typescript-eslint/no-var-requires
globalThis.AbortController ?? require('abort-controller').AbortController;
exports.AbortSignal = 
// eslint-disable-next-line @typescript-eslint/no-var-requires
globalThis.AbortSignal ?? require('abort-controller').AbortSignal;
// AbortSignal.timeout, but consistently .unref()ed
function timeoutSignal(ms) {
    const controller = new exports.AbortController();
    setTimeout(() => controller.abort(), ms).unref();
    return controller.signal;
}
exports.timeoutSignal = timeoutSignal;
// Ensure that only one call to the target `fn` is active at a time.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function withLock(fn) {
    // `lock` represents the completion of the current call to fn(), if any.
    let lock = Promise.resolve();
    return (...args) => {
        const result = lock
            .then(() => fn(...args))
            .finally(() => {
            lock = Promise.resolve();
        });
        lock = result.catch(() => {
            /* handled by caller */
        });
        return result;
    };
}
exports.withLock = withLock;
// Normalize JS objects by sorting keys so that {a:1,b:2} and {b:2,a:1} are equivalent.
function normalizeObject(obj) {
    return Object.fromEntries(Object.entries(obj).sort());
}
exports.normalizeObject = normalizeObject;
// Throws if the url does not refer to an https: endpoint or a local endpoint, or null or undefined.
function validateSecureHTTPUrl(url, diagnosticId) {
    try {
        if (url == null)
            return;
        if (typeof url !== 'string')
            throw new Error(`Expected string, got ${typeof url} instead`);
        const parsed = new URL(url);
        if (parsed.protocol === 'https:')
            return;
        if (parsed.protocol !== 'http:') {
            throw new Error(`Unknown protocol '${parsed.protocol}' '${url}'`);
        }
        if (!/^(\[::1\]|127(\.\d+){3}|localhost)$/.test(parsed.hostname)) {
            throw new Error(`Need to specify https: when accessing non-local URL '${url}'`);
        }
    }
    catch (err) {
        if (!err ||
            typeof err !== 'object' ||
            !('message' in err) ||
            typeof err.message !== 'string') {
            throw err;
        }
        err.message += ` (validating: ${diagnosticId})`;
        throw err;
    }
}
exports.validateSecureHTTPUrl = validateSecureHTTPUrl;
//# sourceMappingURL=util.js.map