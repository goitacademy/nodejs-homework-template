"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoDBOIDCPluginImpl = exports.automaticRefreshTimeoutMS = void 0;
const types_1 = require("./types");
const util_1 = require("./util");
const openid_client_1 = require("openid-client");
const openid_client_2 = require("openid-client");
const rfc_8252_http_server_1 = require("./rfc-8252-http-server");
const util_2 = require("util");
const crypto_1 = require("crypto");
const events_1 = require("events");
const api_1 = require("./api");
const child_process_1 = require("child_process");
// eslint-disable-next-line @typescript-eslint/consistent-type-imports
let _electron = undefined;
async function getDefaultOpenBrowser() {
    // If running electron, use electron.shell.openExternal() by default
    // to open a browser.
    if (process.versions.electron && _electron !== 'cannot-require') {
        try {
            _electron ?? (_electron = await Promise.resolve().then(() => __importStar(require('electron'))));
            return ({ url }) => 
            // eslint-disable-next-line @typescript-eslint/consistent-type-imports
            _electron.shell.openExternal(url);
        }
        catch {
            _electron = 'cannot-require';
        }
    }
    // Otherwise, use open() from npm.
    return async ({ url }) => {
        // 'open' 9.x+ is ESM-only. However, TypeScript transpiles
        // the `await import()` here to `require()`, which fails to load
        // the package at runtime. We cannot use one of the typical workarounds
        // for loading ESM packages unconditionally, because we need to be
        // able to webpack this file (e.g. in Compass), which means that we
        // need to use imports with constant string literal arguments.
        // eslint-disable-next-line @typescript-eslint/consistent-type-imports
        let open;
        try {
            open = (await Promise.resolve().then(() => __importStar(require('open')))).default;
        }
        catch (err) {
            if (err &&
                typeof err === 'object' &&
                'code' in err &&
                err.code === 'ERR_REQUIRE_ESM' &&
                typeof __webpack_require__ === 'undefined') {
                // This means that the import() above was transpiled to require()
                // and that that require() called failed because it saw actual on-disk ESM.
                // In this case, it should be safe to use eval'ed import().
                open = (await eval("import('open')")).default;
            }
            else {
                throw err;
            }
        }
        const child = await open(url);
        child.unref();
        return child;
    };
}
/** @internal Exported for testing only */
function automaticRefreshTimeoutMS(tokenSet) {
    // If the tokens expire in more than 1 minute, automatically register
    // a refresh handler. (They should not expire in less; however,
    // if we didn't handle that case, we'd run the risk of refreshing very
    // frequently.) Refresh the token 5 minutes before expiration or
    // halfway between now and the expiration time, whichever comes later
    // (expires in 1 hour -> refresh in 55 min, expires in 5 min -> refresh in 2.5 min).
    if (tokenSet.refresh_token &&
        tokenSet.expires_in &&
        tokenSet.expires_in >= 60 /* 1 minute */) {
        return (Math.max(tokenSet.expires_in - 300 /* 5 minutes */, tokenSet.expires_in / 2) * 1000);
    }
}
exports.automaticRefreshTimeoutMS = automaticRefreshTimeoutMS;
const kEnableFallback = Symbol.for('@@mdb.oidcplugin.kEnableFallback');
function allowFallbackIfFailed(promise) {
    return promise.catch((err) => {
        // Tell the outer logic here to fallback to device auth flow if it is
        // available if any of the steps above failed.
        if (Object.isExtensible(err)) {
            err[kEnableFallback] = true;
        }
        throw err;
    });
}
/** @internal */
class MongoDBOIDCPluginImpl {
    constructor(options) {
        this.mapIdpToAuthState = new Map();
        this.destroyed = false;
        this.options = options;
        this.logger = options.logger ?? new events_1.EventEmitter();
        this.mongoClientOptions = {
            authMechanismProperties: {
                REQUEST_TOKEN_CALLBACK: this.requestToken.bind(this),
                REFRESH_TOKEN_CALLBACK: this.requestToken.bind(this),
            },
        };
        this.timers = { setTimeout, clearTimeout };
        if (options.serializedState) {
            this._deserialize(options.serializedState);
        }
    }
    _deserialize(serialized) {
        try {
            let original;
            try {
                original = JSON.parse(Buffer.from(serialized, 'base64').toString('utf8'));
            }
            catch (err) {
                throw new types_1.MongoDBOIDCError(`Stored OIDC data could not be deserialized: ${err.message}`);
            }
            if (original.oidcPluginStateVersion !== 0) {
                throw new types_1.MongoDBOIDCError(`Stored OIDC data could not be deserialized because of a version mismatch (got ${JSON.stringify(original.oidcPluginStateVersion)}, expected 0)`);
            }
            for (const [key, serializedState] of original.state) {
                const state = {
                    serverOIDCMetadata: { ...serializedState.serverOIDCMetadata },
                    currentAuthAttempt: null,
                    currentTokenSet: null,
                    lastIdTokenClaims: serializedState.lastIdTokenClaims
                        ? { ...serializedState.lastIdTokenClaims }
                        : undefined,
                };
                this.updateStateWithTokenSet(state, new openid_client_1.TokenSet(serializedState.currentTokenSet.set));
                this.mapIdpToAuthState.set(key, state);
            }
        }
        catch (err) {
            this.logger.emit('mongodb-oidc-plugin:deserialization-failed', {
                error: err.message,
            });
            // It's not necessary to throw by default here since failure to
            // deserialize previous state means that, at worst, users will have
            // to re-authenticate.
            if (this.options.throwOnIncompatibleSerializedState)
                throw err;
        }
    }
    // Separate method so we can re-use the inferred return type in _deserialize()
    _serialize() {
        return {
            oidcPluginStateVersion: 0,
            state: [...this.mapIdpToAuthState]
                .filter(([, state]) => !!state.currentTokenSet)
                .map(([key, state]) => {
                return [
                    key,
                    {
                        serverOIDCMetadata: { ...state.serverOIDCMetadata },
                        currentTokenSet: {
                            set: { ...state.currentTokenSet?.set },
                        },
                        lastIdTokenClaims: state.lastIdTokenClaims
                            ? { ...state.lastIdTokenClaims }
                            : undefined,
                    },
                ];
            }),
        };
    }
    serialize() {
        // Wrap the result using JS-to-JSON-to-UTF8-to-Base64. We could probably
        // omit the base64 encoding, but this makes it clearer that it's an opaque
        // value that's not intended to be inspected or modified.
        return Promise.resolve(Buffer.from(JSON.stringify(this._serialize()), 'utf8').toString('base64'));
    }
    // Is this flow supported and allowed?
    async getAllowedFlows({ signal, }) {
        const flowList = new Set(typeof this.options.allowedFlows === 'function'
            ? await this.options.allowedFlows({ signal })
            : this.options.allowedFlows ?? ['auth-code']);
        // Remove flows from the set whose prerequisites aren't fulfilled.
        if (this.options.openBrowser === false)
            flowList.delete('auth-code');
        if (!this.options.notifyDeviceFlow)
            flowList.delete('device-auth');
        return [...flowList];
    }
    // Return the current state for a given [server, username] configuration,
    // or create a new one if none exists.
    getAuthState(serverMetadata) {
        if (!serverMetadata.issuer || typeof serverMetadata.issuer !== 'string') {
            throw new types_1.MongoDBOIDCError(`'issuer' is missing`);
        }
        (0, util_1.validateSecureHTTPUrl)(serverMetadata.issuer, 'issuer');
        if (!serverMetadata.clientId) {
            throw new types_1.MongoDBOIDCError('No clientId passed in server OIDC metadata object');
        }
        const key = JSON.stringify({
            // If any part of the server metadata changes, we should probably use
            // a new cache entry.
            ...(0, util_1.normalizeObject)(serverMetadata),
        });
        const existing = this.mapIdpToAuthState.get(key);
        if (existing)
            return existing;
        const newState = {
            serverOIDCMetadata: serverMetadata,
            currentAuthAttempt: null,
            currentTokenSet: null,
        };
        this.mapIdpToAuthState.set(key, newState);
        return newState;
    }
    async getOIDCClient(state, redirectURIs) {
        const serverMetadata = state.serverOIDCMetadata;
        const scope = [
            ...new Set([
                'openid',
                'offline_access',
                ...(serverMetadata.requestScopes ?? []),
            ]),
        ].join(' ');
        if (state.client) {
            return {
                scope,
                issuer: state.client.issuer,
                // need to re-create Client here because redirect_uris might
                // differ between calls to this method
                client: new state.client.issuer.Client({
                    ...state.client.metadata,
                    redirect_uris: redirectURIs,
                }),
            };
        }
        (0, util_1.validateSecureHTTPUrl)(serverMetadata.issuer, 'issuer');
        const issuer = await openid_client_2.Issuer.discover(serverMetadata.issuer);
        (0, util_1.validateSecureHTTPUrl)(issuer.metadata.authorization_endpoint, 'authorization_endpoint');
        (0, util_1.validateSecureHTTPUrl)(issuer.metadata.device_authorization_endpoint, 'device_authorization_endpoint');
        (0, util_1.validateSecureHTTPUrl)(issuer.metadata.token_endpoint, 'token_endpoint');
        (0, util_1.validateSecureHTTPUrl)(issuer.metadata.jwks_uri, 'jwks_uri');
        const client = new issuer.Client({
            client_id: serverMetadata.clientId,
            redirect_uris: redirectURIs,
            response_types: ['code'],
            token_endpoint_auth_method: 'none',
        });
        state.client = client;
        return {
            scope,
            issuer,
            client,
        };
    }
    async openBrowser(options) {
        // Consistency check: options.url is a valid URL and does not contain
        // characters that would have special semantics when passed to a
        // child process spawned with `shell: true`.
        // That might not be true for the URL we got from the IdP, but since we
        // wrap it in our own redirect first anyway, we can guarantee that the
        // URL has this format.
        new URL(options.url);
        if (!/^[a-zA-Z0-9%/:;_.,=@-]+$/.test(options.url)) {
            throw new types_1.MongoDBOIDCError(`Unexpected format for internally generated URL: '${options.url}'`);
        }
        this.logger.emit('mongodb-oidc-plugin:open-browser', {
            customOpener: !!this.options.openBrowser,
        });
        if (this.options.openBrowser === false) {
            // We should never really get to this point
            throw new types_1.MongoDBOIDCError('Cannot open browser if `openBrowser` is false');
        }
        if (typeof this.options.openBrowser === 'function') {
            return await this.options.openBrowser(options);
        }
        if (this.options.openBrowser === undefined) {
            const defaultOpener = await getDefaultOpenBrowser();
            return await defaultOpener(options);
        }
        if (typeof this.options.openBrowser?.command === 'string') {
            const child = (0, child_process_1.spawn)(this.options.openBrowser.command, [options.url], {
                shell: true,
                stdio: 'ignore',
                detached: true,
                signal: this.options.openBrowser.abortable ? options.signal : undefined,
            });
            child.unref();
            return child;
        }
        throw new types_1.MongoDBOIDCError('Unknown format for `openBrowser`');
    }
    async notifyDeviceFlow(deviceFlowInformation) {
        (0, util_1.validateSecureHTTPUrl)(deviceFlowInformation.verificationUrl, 'verificationUrl');
        if (!this.options.notifyDeviceFlow) {
            // Should never happen.
            throw new types_1.MongoDBOIDCError('notifyDeviceFlow() requested but not provided');
        }
        this.logger.emit('mongodb-oidc-plugin:notify-device-flow');
        await this.options.notifyDeviceFlow(deviceFlowInformation);
    }
    updateStateWithTokenSet(state, tokenSet) {
        // We intend to be able to pass plugin instances to multiple MongoClient
        // instances that are connecting to the same MongoDB endpoint.
        // We need to prevent a scenario in which a requestToken callback is called
        // for client A, the token expires before it is requested again by client A,
        // then the plugin is passed to client B which requests a token, and we
        // receive mismatching tokens for different users or different audiences.
        const idTokenClaims = tokenSet.claims();
        if (state.lastIdTokenClaims) {
            for (const claim of ['aud', 'sub']) {
                const normalize = (value) => {
                    return JSON.stringify(Array.isArray(value) ? [...value].sort() : value);
                };
                const knownClaim = normalize(state.lastIdTokenClaims[claim]);
                const newClaim = normalize(idTokenClaims[claim]);
                if (knownClaim !== newClaim) {
                    throw new types_1.MongoDBOIDCError(`Unexpected '${claim}' field in id token: Expected ${knownClaim}, saw ${newClaim}`);
                }
            }
        }
        state.lastIdTokenClaims = {
            aud: idTokenClaims.aud,
            sub: idTokenClaims.sub,
        };
        const timerDuration = automaticRefreshTimeoutMS(tokenSet);
        // Use `.call()` because in browsers, `setTimeout()` requires that it is called
        // without a `this` value. `.unref()` is not available in browsers either.
        if (state.timer)
            this.timers.clearTimeout.call(null, state.timer);
        state.timer = timerDuration
            ? this.timers.setTimeout.call(null, () => void tryRefresh(), timerDuration)
            : undefined;
        state.timer?.unref?.();
        const tryRefresh = (0, util_1.withLock)(async () => {
            if (state.timer) {
                this.timers.clearTimeout.call(null, state.timer);
                state.timer = undefined;
            }
            // Only refresh this token set if it is the one currently
            // being used.
            if (state.currentTokenSet?.set !== tokenSet)
                return false;
            try {
                this.logger.emit('mongodb-oidc-plugin:refresh-started');
                const { client } = await this.getOIDCClient(state);
                const refreshedTokens = await client.refresh(tokenSet);
                // Check again to avoid race conditions.
                if (state.currentTokenSet?.set === tokenSet) {
                    this.logger.emit('mongodb-oidc-plugin:refresh-succeeded');
                    this.updateStateWithTokenSet(state, refreshedTokens);
                    return true;
                }
            }
            catch (err) {
                this.logger.emit('mongodb-oidc-plugin:refresh-failed', {
                    error: (0, util_1.errorString)(err),
                });
            }
            return false;
        });
        state.currentTokenSet = {
            set: tokenSet,
            tryRefresh,
        };
        this.logger.emit('mongodb-oidc-plugin:state-updated');
    }
    async authorizationCodeFlow(state, signal) {
        const configuredRedirectURI = this.options.redirectURI ?? MongoDBOIDCPluginImpl.defaultRedirectURI;
        const codeVerifier = openid_client_2.generators.codeVerifier();
        const codeChallenge = openid_client_2.generators.codeChallenge(codeVerifier);
        const oidcStateParam = (await (0, util_2.promisify)(crypto_1.randomBytes)(16)).toString('hex');
        const server = new rfc_8252_http_server_1.RFC8252HTTPServer({
            redirectUrl: configuredRedirectURI,
            logger: this.logger,
            redirectServerRequestHandler: this.options.redirectServerRequestHandler,
            oidcStateParam,
        });
        let paramsUrl = '';
        let scope;
        let client;
        let actualRedirectURI;
        try {
            await (0, util_1.withAbortCheck)(signal, async ({ signalCheck, signalPromise }) => {
                // We mark the operations that we want to allow to result in a fallback
                // to potentially less secure flows explicitly.
                // Specifically, we only do so if we cannot open a local HTTP server
                // or a local browser. Once we have done that, we do not want to fall
                // back to another flow anymore, and any error from there on is most likely
                // a genuine authentication error.
                await Promise.race([
                    allowFallbackIfFailed(server.listen()),
                    signalPromise,
                ]);
                actualRedirectURI = server.listeningRedirectUrl;
                ({ scope, client } = await this.getOIDCClient(state, [
                    actualRedirectURI,
                ]));
                const authCodeFlowUrl = client.authorizationUrl({
                    scope,
                    code_challenge: codeChallenge,
                    code_challenge_method: 'S256',
                    state: oidcStateParam,
                });
                (0, util_1.validateSecureHTTPUrl)(authCodeFlowUrl, 'authCodeFlowUrl');
                const { localUrl, onAccessed: onLocalUrlAccessed } = await server.addRedirect(authCodeFlowUrl);
                signalCheck();
                // Handle errors from opening a browser but do not await the Promise
                // in case it only resolves when the browser exits (which is the case
                // for the default `open` handler).
                const browserStatePromise = allowFallbackIfFailed(new Promise((resolve, reject) => {
                    this.openBrowser({ url: localUrl, signal })
                        .then((browserHandle) => {
                        const extraErrorInfo = () => browserHandle?.spawnargs
                            ? ` (${JSON.stringify(browserHandle.spawnargs)})`
                            : '';
                        browserHandle?.once('error', (err) => reject(new types_1.MongoDBOIDCError(`Opening browser failed with '${String(err && typeof err === 'object' && 'message' in err
                            ? err.message
                            : err)}'${extraErrorInfo()}`)));
                        browserHandle?.once('exit', (code) => {
                            if (code !== 0)
                                reject(new types_1.MongoDBOIDCError(`Opening browser failed with exit code ${code}${extraErrorInfo()}`));
                        });
                    })
                        .catch(reject);
                }));
                const timeout = allowFallbackIfFailed(new Promise((resolve, reject) => {
                    if (this.options.openBrowserTimeout !== 0) {
                        setTimeout(reject, this.options.openBrowserTimeout ?? api_1.kDefaultOpenBrowserTimeout, new types_1.MongoDBOIDCError('Opening browser timed out')).unref();
                    }
                }));
                browserStatePromise.catch(() => {
                    /* squelch UnhandledPromiseRejectionWarning */
                });
                timeout.catch(() => {
                    /* ditto */
                });
                await Promise.race([
                    onLocalUrlAccessed,
                    timeout,
                    browserStatePromise,
                    signalPromise,
                ]);
                paramsUrl = await server.waitForOIDCParamsAndClose({ signal });
            });
        }
        finally {
            await server.close();
        }
        const params = client.callbackParams(paramsUrl);
        const tokenSet = await client.callback(actualRedirectURI, params, {
            code_verifier: codeVerifier,
            state: oidcStateParam,
        });
        this.updateStateWithTokenSet(state, tokenSet);
    }
    async deviceAuthorizationFlow(state, signal) {
        const { scope, client } = await this.getOIDCClient(state);
        await (0, util_1.withAbortCheck)(signal, async ({ signalCheck, signalPromise }) => {
            const deviceFlowHandle = await Promise.race([
                client.deviceAuthorization({
                    client_id: client.metadata.client_id,
                    scope,
                }),
                signalPromise,
            ]);
            signalCheck();
            await this.notifyDeviceFlow({
                userCode: deviceFlowHandle.user_code,
                verificationUrl: deviceFlowHandle.verification_uri,
            });
            const tokenSet = await deviceFlowHandle.poll({ signal });
            this.updateStateWithTokenSet(state, tokenSet);
        });
    }
    async initiateAuthAttempt(state, driverAbortSignal) {
        (0, util_1.throwIfAborted)(this.options.signal);
        (0, util_1.throwIfAborted)(driverAbortSignal);
        const combinedAbortController = new util_1.AbortController();
        const optionsAbortCb = () => {
            // @ts-expect-error TS doesn't understand .abort(reason)
            combinedAbortController.abort(this.options.signal.reason);
        };
        const driverAbortCb = () => {
            // @ts-expect-error TS doesn't understand .abort(reason)
            combinedAbortController.abort(driverAbortSignal.reason);
        };
        this.options.signal?.addEventListener('abort', optionsAbortCb);
        driverAbortSignal?.addEventListener('abort', driverAbortCb);
        const signal = combinedAbortController.signal;
        try {
            get_tokens: {
                if ((state.currentTokenSet?.set?.expires_in ?? 0) > 5 * 60) {
                    this.logger.emit('mongodb-oidc-plugin:skip-auth-attempt', {
                        reason: 'not-expired',
                    });
                    break get_tokens;
                }
                if (await state.currentTokenSet?.tryRefresh?.()) {
                    this.logger.emit('mongodb-oidc-plugin:skip-auth-attempt', {
                        reason: 'refresh-succeeded',
                    });
                    break get_tokens;
                }
                state.currentTokenSet = null;
                let error;
                const currentAllowedFlowSet = await this.getAllowedFlows({ signal });
                if (currentAllowedFlowSet.includes('auth-code')) {
                    try {
                        this.logger.emit('mongodb-oidc-plugin:auth-attempt-started', {
                            flow: 'auth-code',
                        });
                        await this.authorizationCodeFlow(state, signal);
                        this.logger.emit('mongodb-oidc-plugin:auth-attempt-succeeded');
                        break get_tokens;
                    }
                    catch (err) {
                        error = err;
                        this.logger.emit('mongodb-oidc-plugin:auth-attempt-failed', {
                            error: (0, util_1.errorString)(err),
                        });
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        if (!err?.[kEnableFallback])
                            throw err;
                    }
                }
                if (currentAllowedFlowSet.includes('device-auth')) {
                    try {
                        this.logger.emit('mongodb-oidc-plugin:auth-attempt-started', {
                            flow: 'device-auth',
                        });
                        await this.deviceAuthorizationFlow(state, signal);
                        this.logger.emit('mongodb-oidc-plugin:auth-attempt-succeeded');
                        break get_tokens;
                    }
                    catch (err) {
                        this.logger.emit('mongodb-oidc-plugin:auth-attempt-failed', {
                            error: (0, util_1.errorString)(err),
                        });
                        throw err;
                    }
                }
                if (error)
                    throw error;
            }
            if (!state.currentTokenSet?.set?.access_token) {
                throw new types_1.MongoDBOIDCError('Could not retrieve valid access token');
            }
        }
        catch (err) {
            this.logger.emit('mongodb-oidc-plugin:auth-failed', {
                error: (0, util_1.errorString)(err),
            });
            throw err;
        }
        finally {
            this.options.signal?.removeEventListener('abort', optionsAbortCb);
            driverAbortSignal?.removeEventListener('abort', driverAbortCb);
        }
        this.logger.emit('mongodb-oidc-plugin:auth-succeeded', {
            hasRefreshToken: !!state.currentTokenSet.set.refresh_token,
            expiresAt: state.currentTokenSet.set.expires_at
                ? new Date(state.currentTokenSet.set.expires_at * 1000).toISOString()
                : null,
        });
        return {
            accessToken: state.currentTokenSet.set.access_token,
            refreshToken: state.currentTokenSet.set.refresh_token,
            // Passing `expiresInSeconds: 0` results in the driver not caching the token.
            // We perform our own caching here inside the plugin, so interactions with the
            // cache of the driver are not really required or necessarily helpful.
            // The driver cache has a finer cache key (host address instead of clientId),
            // so may require more authentication attempts, and is global,
            // not per-MongoClient.
            // It probably would be fine to pass in the actual expiration time here, but
            // there seem to be no benefits to doing so.
            expiresInSeconds: 0,
        };
    }
    async requestToken(serverMetadata, context) {
        if (context.version !== 0) {
            throw new types_1.MongoDBOIDCError(`OIDC MongoDB driver protocol mismatch: unknown version ${context.version}`);
        }
        if (this.destroyed) {
            throw new types_1.MongoDBOIDCError('This OIDC plugin instance has been destroyed and is no longer active');
        }
        const state = this.getAuthState(serverMetadata);
        if (state.currentAuthAttempt) {
            return await state.currentAuthAttempt;
        }
        // The currently plan is for the 6.x driver (which may drop support
        // for Node.js 14.x) to pass in an actual AbortSignal here. For
        // compatibility with the 5.x driver/AbortSignal-less-Node.js, we accept
        // a timeout in milliseconds as well.
        const driverAbortSignal = context.timeoutContext ??
            (context.timeoutSeconds
                ? (0, util_1.timeoutSignal)(context.timeoutSeconds * 1000)
                : undefined);
        const newAuthAttempt = this.initiateAuthAttempt(state, driverAbortSignal);
        try {
            state.currentAuthAttempt = newAuthAttempt;
            return await newAuthAttempt;
        }
        finally {
            if (state.currentAuthAttempt === newAuthAttempt)
                state.currentAuthAttempt = null;
        }
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async destroy() {
        this.destroyed = true;
        for (const [, state] of this.mapIdpToAuthState) {
            if (state.timer) {
                this.timers.clearTimeout.call(null, state.timer);
                state.timer = undefined;
            }
        }
        this.logger.emit('mongodb-oidc-plugin:destroyed');
    }
}
exports.MongoDBOIDCPluginImpl = MongoDBOIDCPluginImpl;
MongoDBOIDCPluginImpl.defaultRedirectURI = 'http://localhost:27097/redirect';
//# sourceMappingURL=plugin.js.map