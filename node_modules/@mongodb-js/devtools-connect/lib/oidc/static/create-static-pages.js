"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateStaticPagesModule = void 0;
const server_1 = require("react-dom/server");
const emotion_1 = require("@leafygreen-ui/emotion");
const pages_source_1 = require("./pages-source");
const react_1 = __importDefault(require("react"));
const crypto_1 = require("crypto");
const zlib_1 = require("zlib");
function* allSubsets(array) {
    if (array.length === 0) {
        yield [];
        return;
    }
    const first = array[0];
    for (const slicedSubset of allSubsets(array.slice(1))) {
        yield [first, ...slicedSubset];
        yield slicedSubset;
    }
}
function placeholder(prop) {
    return `{{prop:${prop}}}`;
}
const S = JSON.stringify;
function generateStaticPage(Component, props, markupTable) {
    let result = `module.exports[${S(Component.name)}] = function(props) {
    const actualProps = JSON.stringify(
      Object.keys(props)
        .filter(prop => ${S(props)}.includes(prop) && props[prop] != null).sort());`;
    for (const availableProps of allSubsets(props)) {
        const propsObject = {};
        const replacers = [];
        for (const prop of availableProps) {
            propsObject[prop] = placeholder(prop);
            replacers.push(`.replaceAll(${S(placeholder(prop))}, escapeHTML(props[${S(prop)}]))`);
        }
        const markup = (0, emotion_1.renderStylesToString)((0, server_1.renderToStaticMarkup)(react_1.default.createElement(Component, propsObject)));
        const markupHash = (0, crypto_1.createHash)('sha256').update(markup).digest('hex');
        markupTable[markupHash] = markup;
        result += `if (actualProps === ${S(S(availableProps.sort()))}) {
      return (getMarkup(${S(markupHash)})${replacers.join('')});
    }`;
    }
    result += '}\n';
    return result;
}
function generateStaticPagesModule(components) {
    let result = `
  'use strict';
  function escapeHTML(str) {
    return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  `;
    const markupTable = {};
    for (const component of components) {
        result += generateStaticPage(...component, markupTable);
    }
    const compressedMarkupTable = (0, zlib_1.brotliCompressSync)(S(markupTable), {
        params: {
            [zlib_1.constants.BROTLI_PARAM_MODE]: zlib_1.constants.BROTLI_MODE_TEXT,
            [zlib_1.constants.BROTLI_PARAM_QUALITY]: zlib_1.constants.BROTLI_MAX_QUALITY
        }
    });
    result += `
  const markupTableSrc = ${S(compressedMarkupTable.toString('base64'))};
  let markupTable;
  function getMarkup(hash) {
    if (markupTable === undefined) {
      markupTable = JSON.parse(
        require('zlib').brotliDecompressSync(
          Buffer.from(markupTableSrc, 'base64')));
    }
    return markupTable[hash];
  }
  `;
    return result;
}
exports.generateStaticPagesModule = generateStaticPagesModule;
if (require.main === module) {
    console.log(generateStaticPagesModule([
        [pages_source_1.OIDCErrorPage, ['error', 'errorDescription', 'errorURI', 'productDocsLink', 'productName']],
        [pages_source_1.OIDCAcceptedPage, ['productDocsLink', 'productName']],
        [pages_source_1.OIDCNotFoundPage, ['productDocsLink', 'productName']]
    ]));
}
//# sourceMappingURL=create-static-pages.js.map