"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHumanOidcFlow = exports.connectMongoClient = exports.DevtoolsConnectionState = exports.MongoAutoencryptionUnavailable = void 0;
const fast_failure_connect_1 = require("./fast-failure-connect");
const system_ca_1 = require("system-ca");
const oidc_plugin_1 = require("@mongodb-js/oidc-plugin");
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const handler_1 = require("./oidc/handler");
const ipc_rpc_state_share_1 = require("./ipc-rpc-state-share");
const mongodb_connection_string_url_1 = __importStar(require("mongodb-connection-string-url"));
const events_1 = __importDefault(require("events"));
function isAtlas(str) {
    try {
        const { hosts } = new mongodb_connection_string_url_1.default(str);
        return hosts.every(host => /(^|\.)mongodb.net(:|$)/.test(host));
    }
    catch {
        return false;
    }
}
class MongoAutoencryptionUnavailable extends Error {
    constructor() {
        super('Automatic encryption is only available with Atlas and MongoDB Enterprise');
    }
}
exports.MongoAutoencryptionUnavailable = MongoAutoencryptionUnavailable;
async function connectWithFailFast(uri, client, logger) {
    const failedConnections = new Map();
    let failEarlyClosePromise = null;
    logger.emit('devtools-connect:connect-attempt-initialized', {
        uri,
        driver: client.options.metadata.driver,
        devtoolsConnectVersion: require('../package.json').version,
        host: client.options.srvHost ?? client.options.hosts.join(',')
    });
    const heartbeatFailureListener = ({ failure, connectionId }) => {
        const topologyDescription = client.topology?.description;
        const servers = topologyDescription?.servers;
        const isFailFast = (0, fast_failure_connect_1.isFastFailureConnectionError)(failure);
        const isKnownServer = !!servers?.has(connectionId);
        logger.emit('devtools-connect:connect-heartbeat-failure', {
            connectionId,
            failure,
            isFailFast,
            isKnownServer
        });
        if (!isKnownServer) {
            return;
        }
        if (isFailFast && servers) {
            failedConnections.set(connectionId, failure);
            if ([...servers.keys()].every(server => failedConnections.has(server))) {
                logger.emit('devtools-connect:connect-fail-early');
                failEarlyClosePromise = client.close();
            }
        }
    };
    const heartbeatSucceededListener = ({ connectionId }) => {
        logger.emit('devtools-connect:connect-heartbeat-succeeded', { connectionId });
        failedConnections.delete(connectionId);
    };
    client.addListener('serverHeartbeatFailed', heartbeatFailureListener);
    client.addListener('serverHeartbeatSucceeded', heartbeatSucceededListener);
    try {
        await client.connect();
    }
    catch (error) {
        let connectErr = error;
        if (failEarlyClosePromise !== null) {
            await failEarlyClosePromise;
            connectErr = failedConnections.values().next().value;
        }
        if (typeof connectErr === 'object' &&
            connectErr?.constructor.name === 'MongoServerSelectionError' &&
            isAtlas(uri)) {
            connectErr.message = `${connectErr.message}. It looks like this is a MongoDB Atlas cluster. Please ensure that your Network Access List allows connections from your IP.`;
        }
        throw connectErr;
    }
    finally {
        client.removeListener('serverHeartbeatFailed', heartbeatFailureListener);
        client.removeListener('serverHeartbeatSucceeded', heartbeatSucceededListener);
        logger.emit('devtools-connect:connect-attempt-finished', {
            cryptSharedLibVersionInfo: client?.autoEncrypter?.cryptSharedLibVersionInfo
        });
    }
}
let resolveDnsHelpers;
async function resolveMongodbSrv(uri, logger) {
    const resolutionDetails = [];
    if (uri.startsWith('mongodb+srv://')) {
        try {
            resolveDnsHelpers ?? (resolveDnsHelpers = {
                resolve: require('resolve-mongodb-srv'),
                osDns: require('os-dns-native')
            });
        }
        catch (error) {
            logger.emit('devtools-connect:resolve-srv-error', {
                from: '', error, duringLoad: true, resolutionDetails
            });
        }
        if (resolveDnsHelpers !== undefined) {
            try {
                const { wasNativelyLookedUp, withNodeFallback: { resolveSrv, resolveTxt } } = resolveDnsHelpers.osDns;
                const resolved = await resolveDnsHelpers.resolve(uri, {
                    dns: {
                        resolveSrv(hostname, cb) {
                            resolveSrv(hostname, (...args) => {
                                resolutionDetails.push({
                                    query: 'SRV', hostname, error: args[0]?.message, wasNativelyLookedUp: wasNativelyLookedUp(args[1])
                                });
                                cb(...args);
                            });
                        },
                        resolveTxt(hostname, cb) {
                            resolveTxt(hostname, (...args) => {
                                resolutionDetails.push({
                                    query: 'TXT', hostname, error: args[0]?.message, wasNativelyLookedUp: wasNativelyLookedUp(args[1])
                                });
                                cb(...args);
                            });
                        }
                    }
                });
                logger.emit('devtools-connect:resolve-srv-succeeded', { from: uri, to: resolved, resolutionDetails });
                return resolved;
            }
            catch (error) {
                logger.emit('devtools-connect:resolve-srv-error', { from: uri, error, duringLoad: false, resolutionDetails });
                throw error;
            }
        }
    }
    return uri;
}
function detectAndLogMissingOptionalDependencies(logger) {
    try {
        require('saslprep');
    }
    catch (error) {
        logger.emit('devtools-connect:missing-optional-dependency', { name: 'saslprep', error });
    }
    try {
        require('mongodb-client-encryption');
    }
    catch (error) {
        logger.emit('devtools-connect:missing-optional-dependency', { name: 'mongodb-client-encryption', error });
    }
    try {
        require('os-dns-native');
    }
    catch (error) {
        logger.emit('devtools-connect:missing-optional-dependency', { name: 'os-dns-native', error });
    }
    try {
        require('resolve-mongodb-srv');
    }
    catch (error) {
        logger.emit('devtools-connect:missing-optional-dependency', { name: 'resolve-mongodb-srv', error });
    }
    try {
        require('kerberos');
    }
    catch (error) {
        logger.emit('devtools-connect:missing-optional-dependency', { name: 'kerberos', error });
    }
}
class DevtoolsConnectionState {
    constructor(options, logger) {
        this.stateShareClient = null;
        this.stateShareServer = null;
        this.productName = options.productName;
        if (options.parentHandle) {
            this.stateShareClient = new ipc_rpc_state_share_1.StateShareClient(options.parentHandle);
            this.oidcPlugin = this.stateShareClient.oidcPlugin;
        }
        else {
            const proxyingLogger = new events_1.default();
            proxyingLogger.setMaxListeners(Infinity);
            proxyingLogger.emit = function (event, ...args) {
                logger.emit(event, ...args);
                return events_1.default.prototype.emit.call(this, event, ...args);
            };
            this.oidcPlugin = (0, oidc_plugin_1.createMongoDBOIDCPlugin)({
                ...options.oidc,
                logger: proxyingLogger,
                redirectServerRequestHandler: handler_1.oidcServerRequestHandler.bind(null, options)
            });
        }
    }
    async getStateShareServer() {
        this.stateShareServer ?? (this.stateShareServer = await ipc_rpc_state_share_1.StateShareServer.create(this));
        return this.stateShareServer.handle;
    }
    async destroy() {
        await this.stateShareServer?.close();
        await this.oidcPlugin?.destroy();
    }
}
exports.DevtoolsConnectionState = DevtoolsConnectionState;
async function connectMongoClient(uri, clientOptions, logger, MongoClientClass) {
    detectAndLogMissingOptionalDependencies(logger);
    if (clientOptions.useSystemCA) {
        const systemCAOpts = { includeNodeCertificates: true };
        const ca = await (0, system_ca_1.systemCertsAsync)(systemCAOpts);
        logger.emit('devtools-connect:used-system-ca', {
            caCount: ca.length,
            asyncFallbackError: systemCAOpts.asyncFallbackError
        });
        clientOptions = {
            ...clientOptions,
            ca: ca.join('\n')
        };
    }
    const shouldAddOidcCallbacks = isHumanOidcFlow(uri, clientOptions);
    const state = clientOptions.parentState ?? new DevtoolsConnectionState(clientOptions, logger);
    const mongoClientOptions = (0, lodash_merge_1.default)({}, clientOptions, shouldAddOidcCallbacks ? state.oidcPlugin.mongoClientOptions : {});
    delete mongoClientOptions.useSystemCA;
    delete mongoClientOptions.productDocsLink;
    delete mongoClientOptions.productName;
    delete mongoClientOptions.oidc;
    delete mongoClientOptions.parentState;
    delete mongoClientOptions.parentHandle;
    if (mongoClientOptions.autoEncryption !== undefined &&
        !mongoClientOptions.autoEncryption.bypassAutoEncryption &&
        !mongoClientOptions.autoEncryption.bypassQueryAnalysis) {
        const optionsWithoutFLE = { ...mongoClientOptions };
        delete optionsWithoutFLE.autoEncryption;
        delete optionsWithoutFLE.serverApi;
        const client = new MongoClientClass(uri, optionsWithoutFLE);
        closeMongoClientWhenAuthFails(state, client);
        await connectWithFailFast(uri, client, logger);
        const buildInfo = await client.db('admin').admin().command({ buildInfo: 1 });
        await client.close();
        if (!(buildInfo.modules?.includes('enterprise')) &&
            !(buildInfo.gitVersion?.match(/enterprise/))) {
            throw new MongoAutoencryptionUnavailable();
        }
    }
    uri = await resolveMongodbSrv(uri, logger);
    const client = new MongoClientClass(uri, mongoClientOptions);
    closeMongoClientWhenAuthFails(state, client);
    await connectWithFailFast(uri, client, logger);
    if (client.autoEncrypter) {
        client.autoEncrypter[Symbol.for('@@mdb.decorateDecryptionResult')] = true;
    }
    return { client, state };
}
exports.connectMongoClient = connectMongoClient;
function isHumanOidcFlow(uri, clientOptions) {
    if ((clientOptions.authMechanism && clientOptions.authMechanism !== 'MONGODB-OIDC') ||
        clientOptions.authMechanismProperties?.PROVIDER_NAME) {
        return false;
    }
    let cs;
    try {
        cs = new mongodb_connection_string_url_1.default(uri, { looseValidation: true });
    }
    catch {
        return false;
    }
    const sp = cs.typedSearchParams();
    const authMechanism = clientOptions.authMechanism ?? sp.get('authMechanism');
    return authMechanism === 'MONGODB-OIDC' && !new mongodb_connection_string_url_1.CommaAndColonSeparatedRecord(sp.get('authMechanismProperties')).get('PROVIDER_NAME');
}
exports.isHumanOidcFlow = isHumanOidcFlow;
function closeMongoClientWhenAuthFails(state, client) {
    const originalClose = client.close;
    client.close = async function (...args) {
        let closeEmitted = false;
        const onClose = () => closeEmitted = true;
        this.on('close', onClose);
        const result = await originalClose.call(this, ...args);
        this.off('close', onClose);
        if (!closeEmitted) {
            this.emit('close');
        }
        return result;
    };
    const onOIDCAuthFailed = () => client.close().catch(() => { });
    state.oidcPlugin.logger.once('mongodb-oidc-plugin:auth-failed', onOIDCAuthFailed);
    client.once('close', () => state.oidcPlugin.logger.off?.('mongodb-oidc-plugin:auth-failed', onOIDCAuthFailed));
}
//# sourceMappingURL=connect.js.map